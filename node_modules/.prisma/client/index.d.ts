
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model PlayerResource
 * 
 */
export type PlayerResource = $Result.DefaultSelection<Prisma.$PlayerResourcePayload>
/**
 * Model Companion
 * 
 */
export type Companion = $Result.DefaultSelection<Prisma.$CompanionPayload>
/**
 * Model PlayerCompanion
 * 
 */
export type PlayerCompanion = $Result.DefaultSelection<Prisma.$PlayerCompanionPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model PlayerAchievement
 * 
 */
export type PlayerAchievement = $Result.DefaultSelection<Prisma.$PlayerAchievementPayload>
/**
 * Model Quest
 * 
 */
export type Quest = $Result.DefaultSelection<Prisma.$QuestPayload>
/**
 * Model PlayerQuest
 * 
 */
export type PlayerQuest = $Result.DefaultSelection<Prisma.$PlayerQuestPayload>
/**
 * Model PlayerStats
 * 
 */
export type PlayerStats = $Result.DefaultSelection<Prisma.$PlayerStatsPayload>
/**
 * Model EquipmentType
 * 
 */
export type EquipmentType = $Result.DefaultSelection<Prisma.$EquipmentTypePayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model PlayerEquipment
 * 
 */
export type PlayerEquipment = $Result.DefaultSelection<Prisma.$PlayerEquipmentPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model PlayerSkill
 * 
 */
export type PlayerSkill = $Result.DefaultSelection<Prisma.$PlayerSkillPayload>
/**
 * Model TalentType
 * 
 */
export type TalentType = $Result.DefaultSelection<Prisma.$TalentTypePayload>
/**
 * Model Talent
 * 
 */
export type Talent = $Result.DefaultSelection<Prisma.$TalentPayload>
/**
 * Model PlayerTalent
 * 
 */
export type PlayerTalent = $Result.DefaultSelection<Prisma.$PlayerTalentPayload>
/**
 * Model Buff
 * 
 */
export type Buff = $Result.DefaultSelection<Prisma.$BuffPayload>
/**
 * Model PlayerBuff
 * 
 */
export type PlayerBuff = $Result.DefaultSelection<Prisma.$PlayerBuffPayload>
/**
 * Model GameConfig
 * 
 */
export type GameConfig = $Result.DefaultSelection<Prisma.$GameConfigPayload>
/**
 * Model Shop
 * 
 */
export type Shop = $Result.DefaultSelection<Prisma.$ShopPayload>
/**
 * Model ShopItem
 * 
 */
export type ShopItem = $Result.DefaultSelection<Prisma.$ShopItemPayload>
/**
 * Model PurchaseHistory
 * 
 */
export type PurchaseHistory = $Result.DefaultSelection<Prisma.$PurchaseHistoryPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model CraftingHistory
 * 
 */
export type CraftingHistory = $Result.DefaultSelection<Prisma.$CraftingHistoryPayload>
/**
 * Model DaoFurnace
 * 
 */
export type DaoFurnace = $Result.DefaultSelection<Prisma.$DaoFurnacePayload>
/**
 * Model PlayerFurnace
 * 
 */
export type PlayerFurnace = $Result.DefaultSelection<Prisma.$PlayerFurnacePayload>
/**
 * Model SpiritBeastType
 * 
 */
export type SpiritBeastType = $Result.DefaultSelection<Prisma.$SpiritBeastTypePayload>
/**
 * Model SpiritBeast
 * 
 */
export type SpiritBeast = $Result.DefaultSelection<Prisma.$SpiritBeastPayload>
/**
 * Model BeastFood
 * 
 */
export type BeastFood = $Result.DefaultSelection<Prisma.$BeastFoodPayload>
/**
 * Model BeastFeedingHistory
 * 
 */
export type BeastFeedingHistory = $Result.DefaultSelection<Prisma.$BeastFeedingHistoryPayload>
/**
 * Model HuntingGround
 * 
 */
export type HuntingGround = $Result.DefaultSelection<Prisma.$HuntingGroundPayload>
/**
 * Model HuntingHistory
 * 
 */
export type HuntingHistory = $Result.DefaultSelection<Prisma.$HuntingHistoryPayload>
/**
 * Model PlayerCultivation
 * 
 */
export type PlayerCultivation = $Result.DefaultSelection<Prisma.$PlayerCultivationPayload>
/**
 * Model CultivationLog
 * 
 */
export type CultivationLog = $Result.DefaultSelection<Prisma.$CultivationLogPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs>;

  /**
   * `prisma.playerResource`: Exposes CRUD operations for the **PlayerResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerResources
    * const playerResources = await prisma.playerResource.findMany()
    * ```
    */
  get playerResource(): Prisma.PlayerResourceDelegate<ExtArgs>;

  /**
   * `prisma.companion`: Exposes CRUD operations for the **Companion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companions
    * const companions = await prisma.companion.findMany()
    * ```
    */
  get companion(): Prisma.CompanionDelegate<ExtArgs>;

  /**
   * `prisma.playerCompanion`: Exposes CRUD operations for the **PlayerCompanion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerCompanions
    * const playerCompanions = await prisma.playerCompanion.findMany()
    * ```
    */
  get playerCompanion(): Prisma.PlayerCompanionDelegate<ExtArgs>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs>;

  /**
   * `prisma.playerAchievement`: Exposes CRUD operations for the **PlayerAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerAchievements
    * const playerAchievements = await prisma.playerAchievement.findMany()
    * ```
    */
  get playerAchievement(): Prisma.PlayerAchievementDelegate<ExtArgs>;

  /**
   * `prisma.quest`: Exposes CRUD operations for the **Quest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quests
    * const quests = await prisma.quest.findMany()
    * ```
    */
  get quest(): Prisma.QuestDelegate<ExtArgs>;

  /**
   * `prisma.playerQuest`: Exposes CRUD operations for the **PlayerQuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerQuests
    * const playerQuests = await prisma.playerQuest.findMany()
    * ```
    */
  get playerQuest(): Prisma.PlayerQuestDelegate<ExtArgs>;

  /**
   * `prisma.playerStats`: Exposes CRUD operations for the **PlayerStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerStats
    * const playerStats = await prisma.playerStats.findMany()
    * ```
    */
  get playerStats(): Prisma.PlayerStatsDelegate<ExtArgs>;

  /**
   * `prisma.equipmentType`: Exposes CRUD operations for the **EquipmentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentTypes
    * const equipmentTypes = await prisma.equipmentType.findMany()
    * ```
    */
  get equipmentType(): Prisma.EquipmentTypeDelegate<ExtArgs>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs>;

  /**
   * `prisma.playerEquipment`: Exposes CRUD operations for the **PlayerEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerEquipments
    * const playerEquipments = await prisma.playerEquipment.findMany()
    * ```
    */
  get playerEquipment(): Prisma.PlayerEquipmentDelegate<ExtArgs>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs>;

  /**
   * `prisma.playerSkill`: Exposes CRUD operations for the **PlayerSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerSkills
    * const playerSkills = await prisma.playerSkill.findMany()
    * ```
    */
  get playerSkill(): Prisma.PlayerSkillDelegate<ExtArgs>;

  /**
   * `prisma.talentType`: Exposes CRUD operations for the **TalentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TalentTypes
    * const talentTypes = await prisma.talentType.findMany()
    * ```
    */
  get talentType(): Prisma.TalentTypeDelegate<ExtArgs>;

  /**
   * `prisma.talent`: Exposes CRUD operations for the **Talent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Talents
    * const talents = await prisma.talent.findMany()
    * ```
    */
  get talent(): Prisma.TalentDelegate<ExtArgs>;

  /**
   * `prisma.playerTalent`: Exposes CRUD operations for the **PlayerTalent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerTalents
    * const playerTalents = await prisma.playerTalent.findMany()
    * ```
    */
  get playerTalent(): Prisma.PlayerTalentDelegate<ExtArgs>;

  /**
   * `prisma.buff`: Exposes CRUD operations for the **Buff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buffs
    * const buffs = await prisma.buff.findMany()
    * ```
    */
  get buff(): Prisma.BuffDelegate<ExtArgs>;

  /**
   * `prisma.playerBuff`: Exposes CRUD operations for the **PlayerBuff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerBuffs
    * const playerBuffs = await prisma.playerBuff.findMany()
    * ```
    */
  get playerBuff(): Prisma.PlayerBuffDelegate<ExtArgs>;

  /**
   * `prisma.gameConfig`: Exposes CRUD operations for the **GameConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameConfigs
    * const gameConfigs = await prisma.gameConfig.findMany()
    * ```
    */
  get gameConfig(): Prisma.GameConfigDelegate<ExtArgs>;

  /**
   * `prisma.shop`: Exposes CRUD operations for the **Shop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shops
    * const shops = await prisma.shop.findMany()
    * ```
    */
  get shop(): Prisma.ShopDelegate<ExtArgs>;

  /**
   * `prisma.shopItem`: Exposes CRUD operations for the **ShopItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopItems
    * const shopItems = await prisma.shopItem.findMany()
    * ```
    */
  get shopItem(): Prisma.ShopItemDelegate<ExtArgs>;

  /**
   * `prisma.purchaseHistory`: Exposes CRUD operations for the **PurchaseHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseHistories
    * const purchaseHistories = await prisma.purchaseHistory.findMany()
    * ```
    */
  get purchaseHistory(): Prisma.PurchaseHistoryDelegate<ExtArgs>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs>;

  /**
   * `prisma.craftingHistory`: Exposes CRUD operations for the **CraftingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CraftingHistories
    * const craftingHistories = await prisma.craftingHistory.findMany()
    * ```
    */
  get craftingHistory(): Prisma.CraftingHistoryDelegate<ExtArgs>;

  /**
   * `prisma.daoFurnace`: Exposes CRUD operations for the **DaoFurnace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DaoFurnaces
    * const daoFurnaces = await prisma.daoFurnace.findMany()
    * ```
    */
  get daoFurnace(): Prisma.DaoFurnaceDelegate<ExtArgs>;

  /**
   * `prisma.playerFurnace`: Exposes CRUD operations for the **PlayerFurnace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerFurnaces
    * const playerFurnaces = await prisma.playerFurnace.findMany()
    * ```
    */
  get playerFurnace(): Prisma.PlayerFurnaceDelegate<ExtArgs>;

  /**
   * `prisma.spiritBeastType`: Exposes CRUD operations for the **SpiritBeastType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpiritBeastTypes
    * const spiritBeastTypes = await prisma.spiritBeastType.findMany()
    * ```
    */
  get spiritBeastType(): Prisma.SpiritBeastTypeDelegate<ExtArgs>;

  /**
   * `prisma.spiritBeast`: Exposes CRUD operations for the **SpiritBeast** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpiritBeasts
    * const spiritBeasts = await prisma.spiritBeast.findMany()
    * ```
    */
  get spiritBeast(): Prisma.SpiritBeastDelegate<ExtArgs>;

  /**
   * `prisma.beastFood`: Exposes CRUD operations for the **BeastFood** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BeastFoods
    * const beastFoods = await prisma.beastFood.findMany()
    * ```
    */
  get beastFood(): Prisma.BeastFoodDelegate<ExtArgs>;

  /**
   * `prisma.beastFeedingHistory`: Exposes CRUD operations for the **BeastFeedingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BeastFeedingHistories
    * const beastFeedingHistories = await prisma.beastFeedingHistory.findMany()
    * ```
    */
  get beastFeedingHistory(): Prisma.BeastFeedingHistoryDelegate<ExtArgs>;

  /**
   * `prisma.huntingGround`: Exposes CRUD operations for the **HuntingGround** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HuntingGrounds
    * const huntingGrounds = await prisma.huntingGround.findMany()
    * ```
    */
  get huntingGround(): Prisma.HuntingGroundDelegate<ExtArgs>;

  /**
   * `prisma.huntingHistory`: Exposes CRUD operations for the **HuntingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HuntingHistories
    * const huntingHistories = await prisma.huntingHistory.findMany()
    * ```
    */
  get huntingHistory(): Prisma.HuntingHistoryDelegate<ExtArgs>;

  /**
   * `prisma.playerCultivation`: Exposes CRUD operations for the **PlayerCultivation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerCultivations
    * const playerCultivations = await prisma.playerCultivation.findMany()
    * ```
    */
  get playerCultivation(): Prisma.PlayerCultivationDelegate<ExtArgs>;

  /**
   * `prisma.cultivationLog`: Exposes CRUD operations for the **CultivationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CultivationLogs
    * const cultivationLogs = await prisma.cultivationLog.findMany()
    * ```
    */
  get cultivationLog(): Prisma.CultivationLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Player: 'Player',
    Resource: 'Resource',
    PlayerResource: 'PlayerResource',
    Companion: 'Companion',
    PlayerCompanion: 'PlayerCompanion',
    Achievement: 'Achievement',
    PlayerAchievement: 'PlayerAchievement',
    Quest: 'Quest',
    PlayerQuest: 'PlayerQuest',
    PlayerStats: 'PlayerStats',
    EquipmentType: 'EquipmentType',
    Equipment: 'Equipment',
    PlayerEquipment: 'PlayerEquipment',
    Skill: 'Skill',
    PlayerSkill: 'PlayerSkill',
    TalentType: 'TalentType',
    Talent: 'Talent',
    PlayerTalent: 'PlayerTalent',
    Buff: 'Buff',
    PlayerBuff: 'PlayerBuff',
    GameConfig: 'GameConfig',
    Shop: 'Shop',
    ShopItem: 'ShopItem',
    PurchaseHistory: 'PurchaseHistory',
    Inventory: 'Inventory',
    Recipe: 'Recipe',
    CraftingHistory: 'CraftingHistory',
    DaoFurnace: 'DaoFurnace',
    PlayerFurnace: 'PlayerFurnace',
    SpiritBeastType: 'SpiritBeastType',
    SpiritBeast: 'SpiritBeast',
    BeastFood: 'BeastFood',
    BeastFeedingHistory: 'BeastFeedingHistory',
    HuntingGround: 'HuntingGround',
    HuntingHistory: 'HuntingHistory',
    PlayerCultivation: 'PlayerCultivation',
    CultivationLog: 'CultivationLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "player" | "resource" | "playerResource" | "companion" | "playerCompanion" | "achievement" | "playerAchievement" | "quest" | "playerQuest" | "playerStats" | "equipmentType" | "equipment" | "playerEquipment" | "skill" | "playerSkill" | "talentType" | "talent" | "playerTalent" | "buff" | "playerBuff" | "gameConfig" | "shop" | "shopItem" | "purchaseHistory" | "inventory" | "recipe" | "craftingHistory" | "daoFurnace" | "playerFurnace" | "spiritBeastType" | "spiritBeast" | "beastFood" | "beastFeedingHistory" | "huntingGround" | "huntingHistory" | "playerCultivation" | "cultivationLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      PlayerResource: {
        payload: Prisma.$PlayerResourcePayload<ExtArgs>
        fields: Prisma.PlayerResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerResourcePayload>
          }
          findFirst: {
            args: Prisma.PlayerResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerResourcePayload>
          }
          findMany: {
            args: Prisma.PlayerResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerResourcePayload>[]
          }
          create: {
            args: Prisma.PlayerResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerResourcePayload>
          }
          createMany: {
            args: Prisma.PlayerResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerResourcePayload>[]
          }
          delete: {
            args: Prisma.PlayerResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerResourcePayload>
          }
          update: {
            args: Prisma.PlayerResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerResourcePayload>
          }
          deleteMany: {
            args: Prisma.PlayerResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerResourcePayload>
          }
          aggregate: {
            args: Prisma.PlayerResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerResource>
          }
          groupBy: {
            args: Prisma.PlayerResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerResourceCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerResourceCountAggregateOutputType> | number
          }
        }
      }
      Companion: {
        payload: Prisma.$CompanionPayload<ExtArgs>
        fields: Prisma.CompanionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanionPayload>
          }
          findFirst: {
            args: Prisma.CompanionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanionPayload>
          }
          findMany: {
            args: Prisma.CompanionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanionPayload>[]
          }
          create: {
            args: Prisma.CompanionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanionPayload>
          }
          createMany: {
            args: Prisma.CompanionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanionPayload>[]
          }
          delete: {
            args: Prisma.CompanionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanionPayload>
          }
          update: {
            args: Prisma.CompanionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanionPayload>
          }
          deleteMany: {
            args: Prisma.CompanionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanionPayload>
          }
          aggregate: {
            args: Prisma.CompanionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanion>
          }
          groupBy: {
            args: Prisma.CompanionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanionCountArgs<ExtArgs>
            result: $Utils.Optional<CompanionCountAggregateOutputType> | number
          }
        }
      }
      PlayerCompanion: {
        payload: Prisma.$PlayerCompanionPayload<ExtArgs>
        fields: Prisma.PlayerCompanionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerCompanionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCompanionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerCompanionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCompanionPayload>
          }
          findFirst: {
            args: Prisma.PlayerCompanionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCompanionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerCompanionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCompanionPayload>
          }
          findMany: {
            args: Prisma.PlayerCompanionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCompanionPayload>[]
          }
          create: {
            args: Prisma.PlayerCompanionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCompanionPayload>
          }
          createMany: {
            args: Prisma.PlayerCompanionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCompanionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCompanionPayload>[]
          }
          delete: {
            args: Prisma.PlayerCompanionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCompanionPayload>
          }
          update: {
            args: Prisma.PlayerCompanionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCompanionPayload>
          }
          deleteMany: {
            args: Prisma.PlayerCompanionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerCompanionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerCompanionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCompanionPayload>
          }
          aggregate: {
            args: Prisma.PlayerCompanionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerCompanion>
          }
          groupBy: {
            args: Prisma.PlayerCompanionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerCompanionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCompanionCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCompanionCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      PlayerAchievement: {
        payload: Prisma.$PlayerAchievementPayload<ExtArgs>
        fields: Prisma.PlayerAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerAchievementPayload>
          }
          findFirst: {
            args: Prisma.PlayerAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerAchievementPayload>
          }
          findMany: {
            args: Prisma.PlayerAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerAchievementPayload>[]
          }
          create: {
            args: Prisma.PlayerAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerAchievementPayload>
          }
          createMany: {
            args: Prisma.PlayerAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerAchievementPayload>[]
          }
          delete: {
            args: Prisma.PlayerAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerAchievementPayload>
          }
          update: {
            args: Prisma.PlayerAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerAchievementPayload>
          }
          deleteMany: {
            args: Prisma.PlayerAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerAchievementPayload>
          }
          aggregate: {
            args: Prisma.PlayerAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerAchievement>
          }
          groupBy: {
            args: Prisma.PlayerAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerAchievementCountAggregateOutputType> | number
          }
        }
      }
      Quest: {
        payload: Prisma.$QuestPayload<ExtArgs>
        fields: Prisma.QuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          findFirst: {
            args: Prisma.QuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          findMany: {
            args: Prisma.QuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          create: {
            args: Prisma.QuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          createMany: {
            args: Prisma.QuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          delete: {
            args: Prisma.QuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          update: {
            args: Prisma.QuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          deleteMany: {
            args: Prisma.QuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          aggregate: {
            args: Prisma.QuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuest>
          }
          groupBy: {
            args: Prisma.QuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestCountArgs<ExtArgs>
            result: $Utils.Optional<QuestCountAggregateOutputType> | number
          }
        }
      }
      PlayerQuest: {
        payload: Prisma.$PlayerQuestPayload<ExtArgs>
        fields: Prisma.PlayerQuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerQuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerQuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerQuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerQuestPayload>
          }
          findFirst: {
            args: Prisma.PlayerQuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerQuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerQuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerQuestPayload>
          }
          findMany: {
            args: Prisma.PlayerQuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerQuestPayload>[]
          }
          create: {
            args: Prisma.PlayerQuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerQuestPayload>
          }
          createMany: {
            args: Prisma.PlayerQuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerQuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerQuestPayload>[]
          }
          delete: {
            args: Prisma.PlayerQuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerQuestPayload>
          }
          update: {
            args: Prisma.PlayerQuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerQuestPayload>
          }
          deleteMany: {
            args: Prisma.PlayerQuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerQuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerQuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerQuestPayload>
          }
          aggregate: {
            args: Prisma.PlayerQuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerQuest>
          }
          groupBy: {
            args: Prisma.PlayerQuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerQuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerQuestCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerQuestCountAggregateOutputType> | number
          }
        }
      }
      PlayerStats: {
        payload: Prisma.$PlayerStatsPayload<ExtArgs>
        fields: Prisma.PlayerStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          findFirst: {
            args: Prisma.PlayerStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          findMany: {
            args: Prisma.PlayerStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>[]
          }
          create: {
            args: Prisma.PlayerStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          createMany: {
            args: Prisma.PlayerStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>[]
          }
          delete: {
            args: Prisma.PlayerStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          update: {
            args: Prisma.PlayerStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          deleteMany: {
            args: Prisma.PlayerStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          aggregate: {
            args: Prisma.PlayerStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerStats>
          }
          groupBy: {
            args: Prisma.PlayerStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerStatsCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerStatsCountAggregateOutputType> | number
          }
        }
      }
      EquipmentType: {
        payload: Prisma.$EquipmentTypePayload<ExtArgs>
        fields: Prisma.EquipmentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          findFirst: {
            args: Prisma.EquipmentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          findMany: {
            args: Prisma.EquipmentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>[]
          }
          create: {
            args: Prisma.EquipmentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          createMany: {
            args: Prisma.EquipmentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>[]
          }
          delete: {
            args: Prisma.EquipmentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          update: {
            args: Prisma.EquipmentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          deleteMany: {
            args: Prisma.EquipmentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          aggregate: {
            args: Prisma.EquipmentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentType>
          }
          groupBy: {
            args: Prisma.EquipmentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentTypeCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      PlayerEquipment: {
        payload: Prisma.$PlayerEquipmentPayload<ExtArgs>
        fields: Prisma.PlayerEquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerEquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerEquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          findFirst: {
            args: Prisma.PlayerEquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerEquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          findMany: {
            args: Prisma.PlayerEquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>[]
          }
          create: {
            args: Prisma.PlayerEquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          createMany: {
            args: Prisma.PlayerEquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerEquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>[]
          }
          delete: {
            args: Prisma.PlayerEquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          update: {
            args: Prisma.PlayerEquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          deleteMany: {
            args: Prisma.PlayerEquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerEquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerEquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          aggregate: {
            args: Prisma.PlayerEquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerEquipment>
          }
          groupBy: {
            args: Prisma.PlayerEquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerEquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerEquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerEquipmentCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      PlayerSkill: {
        payload: Prisma.$PlayerSkillPayload<ExtArgs>
        fields: Prisma.PlayerSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          findFirst: {
            args: Prisma.PlayerSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          findMany: {
            args: Prisma.PlayerSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>[]
          }
          create: {
            args: Prisma.PlayerSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          createMany: {
            args: Prisma.PlayerSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>[]
          }
          delete: {
            args: Prisma.PlayerSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          update: {
            args: Prisma.PlayerSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          deleteMany: {
            args: Prisma.PlayerSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          aggregate: {
            args: Prisma.PlayerSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerSkill>
          }
          groupBy: {
            args: Prisma.PlayerSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerSkillCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerSkillCountAggregateOutputType> | number
          }
        }
      }
      TalentType: {
        payload: Prisma.$TalentTypePayload<ExtArgs>
        fields: Prisma.TalentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TalentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TalentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentTypePayload>
          }
          findFirst: {
            args: Prisma.TalentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TalentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentTypePayload>
          }
          findMany: {
            args: Prisma.TalentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentTypePayload>[]
          }
          create: {
            args: Prisma.TalentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentTypePayload>
          }
          createMany: {
            args: Prisma.TalentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TalentTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentTypePayload>[]
          }
          delete: {
            args: Prisma.TalentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentTypePayload>
          }
          update: {
            args: Prisma.TalentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentTypePayload>
          }
          deleteMany: {
            args: Prisma.TalentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TalentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TalentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentTypePayload>
          }
          aggregate: {
            args: Prisma.TalentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTalentType>
          }
          groupBy: {
            args: Prisma.TalentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TalentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TalentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<TalentTypeCountAggregateOutputType> | number
          }
        }
      }
      Talent: {
        payload: Prisma.$TalentPayload<ExtArgs>
        fields: Prisma.TalentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TalentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TalentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          findFirst: {
            args: Prisma.TalentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TalentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          findMany: {
            args: Prisma.TalentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>[]
          }
          create: {
            args: Prisma.TalentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          createMany: {
            args: Prisma.TalentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TalentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>[]
          }
          delete: {
            args: Prisma.TalentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          update: {
            args: Prisma.TalentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          deleteMany: {
            args: Prisma.TalentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TalentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TalentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          aggregate: {
            args: Prisma.TalentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTalent>
          }
          groupBy: {
            args: Prisma.TalentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TalentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TalentCountArgs<ExtArgs>
            result: $Utils.Optional<TalentCountAggregateOutputType> | number
          }
        }
      }
      PlayerTalent: {
        payload: Prisma.$PlayerTalentPayload<ExtArgs>
        fields: Prisma.PlayerTalentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerTalentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTalentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerTalentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTalentPayload>
          }
          findFirst: {
            args: Prisma.PlayerTalentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTalentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerTalentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTalentPayload>
          }
          findMany: {
            args: Prisma.PlayerTalentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTalentPayload>[]
          }
          create: {
            args: Prisma.PlayerTalentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTalentPayload>
          }
          createMany: {
            args: Prisma.PlayerTalentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerTalentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTalentPayload>[]
          }
          delete: {
            args: Prisma.PlayerTalentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTalentPayload>
          }
          update: {
            args: Prisma.PlayerTalentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTalentPayload>
          }
          deleteMany: {
            args: Prisma.PlayerTalentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerTalentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerTalentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTalentPayload>
          }
          aggregate: {
            args: Prisma.PlayerTalentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerTalent>
          }
          groupBy: {
            args: Prisma.PlayerTalentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerTalentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerTalentCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerTalentCountAggregateOutputType> | number
          }
        }
      }
      Buff: {
        payload: Prisma.$BuffPayload<ExtArgs>
        fields: Prisma.BuffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffPayload>
          }
          findFirst: {
            args: Prisma.BuffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffPayload>
          }
          findMany: {
            args: Prisma.BuffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffPayload>[]
          }
          create: {
            args: Prisma.BuffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffPayload>
          }
          createMany: {
            args: Prisma.BuffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffPayload>[]
          }
          delete: {
            args: Prisma.BuffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffPayload>
          }
          update: {
            args: Prisma.BuffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffPayload>
          }
          deleteMany: {
            args: Prisma.BuffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffPayload>
          }
          aggregate: {
            args: Prisma.BuffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuff>
          }
          groupBy: {
            args: Prisma.BuffGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuffGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuffCountArgs<ExtArgs>
            result: $Utils.Optional<BuffCountAggregateOutputType> | number
          }
        }
      }
      PlayerBuff: {
        payload: Prisma.$PlayerBuffPayload<ExtArgs>
        fields: Prisma.PlayerBuffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerBuffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBuffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerBuffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBuffPayload>
          }
          findFirst: {
            args: Prisma.PlayerBuffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBuffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerBuffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBuffPayload>
          }
          findMany: {
            args: Prisma.PlayerBuffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBuffPayload>[]
          }
          create: {
            args: Prisma.PlayerBuffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBuffPayload>
          }
          createMany: {
            args: Prisma.PlayerBuffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerBuffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBuffPayload>[]
          }
          delete: {
            args: Prisma.PlayerBuffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBuffPayload>
          }
          update: {
            args: Prisma.PlayerBuffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBuffPayload>
          }
          deleteMany: {
            args: Prisma.PlayerBuffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerBuffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerBuffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBuffPayload>
          }
          aggregate: {
            args: Prisma.PlayerBuffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerBuff>
          }
          groupBy: {
            args: Prisma.PlayerBuffGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerBuffGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerBuffCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerBuffCountAggregateOutputType> | number
          }
        }
      }
      GameConfig: {
        payload: Prisma.$GameConfigPayload<ExtArgs>
        fields: Prisma.GameConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          findFirst: {
            args: Prisma.GameConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          findMany: {
            args: Prisma.GameConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>[]
          }
          create: {
            args: Prisma.GameConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          createMany: {
            args: Prisma.GameConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>[]
          }
          delete: {
            args: Prisma.GameConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          update: {
            args: Prisma.GameConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          deleteMany: {
            args: Prisma.GameConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          aggregate: {
            args: Prisma.GameConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameConfig>
          }
          groupBy: {
            args: Prisma.GameConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameConfigCountArgs<ExtArgs>
            result: $Utils.Optional<GameConfigCountAggregateOutputType> | number
          }
        }
      }
      Shop: {
        payload: Prisma.$ShopPayload<ExtArgs>
        fields: Prisma.ShopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findFirst: {
            args: Prisma.ShopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findMany: {
            args: Prisma.ShopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          create: {
            args: Prisma.ShopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          createMany: {
            args: Prisma.ShopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          delete: {
            args: Prisma.ShopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          update: {
            args: Prisma.ShopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          deleteMany: {
            args: Prisma.ShopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          aggregate: {
            args: Prisma.ShopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShop>
          }
          groupBy: {
            args: Prisma.ShopGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopCountArgs<ExtArgs>
            result: $Utils.Optional<ShopCountAggregateOutputType> | number
          }
        }
      }
      ShopItem: {
        payload: Prisma.$ShopItemPayload<ExtArgs>
        fields: Prisma.ShopItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          findFirst: {
            args: Prisma.ShopItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          findMany: {
            args: Prisma.ShopItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>[]
          }
          create: {
            args: Prisma.ShopItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          createMany: {
            args: Prisma.ShopItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>[]
          }
          delete: {
            args: Prisma.ShopItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          update: {
            args: Prisma.ShopItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          deleteMany: {
            args: Prisma.ShopItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShopItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          aggregate: {
            args: Prisma.ShopItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopItem>
          }
          groupBy: {
            args: Prisma.ShopItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopItemCountArgs<ExtArgs>
            result: $Utils.Optional<ShopItemCountAggregateOutputType> | number
          }
        }
      }
      PurchaseHistory: {
        payload: Prisma.$PurchaseHistoryPayload<ExtArgs>
        fields: Prisma.PurchaseHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          findFirst: {
            args: Prisma.PurchaseHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          findMany: {
            args: Prisma.PurchaseHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>[]
          }
          create: {
            args: Prisma.PurchaseHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          createMany: {
            args: Prisma.PurchaseHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>[]
          }
          delete: {
            args: Prisma.PurchaseHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          update: {
            args: Prisma.PurchaseHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          aggregate: {
            args: Prisma.PurchaseHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseHistory>
          }
          groupBy: {
            args: Prisma.PurchaseHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseHistoryCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      CraftingHistory: {
        payload: Prisma.$CraftingHistoryPayload<ExtArgs>
        fields: Prisma.CraftingHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CraftingHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftingHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CraftingHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftingHistoryPayload>
          }
          findFirst: {
            args: Prisma.CraftingHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftingHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CraftingHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftingHistoryPayload>
          }
          findMany: {
            args: Prisma.CraftingHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftingHistoryPayload>[]
          }
          create: {
            args: Prisma.CraftingHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftingHistoryPayload>
          }
          createMany: {
            args: Prisma.CraftingHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CraftingHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftingHistoryPayload>[]
          }
          delete: {
            args: Prisma.CraftingHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftingHistoryPayload>
          }
          update: {
            args: Prisma.CraftingHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftingHistoryPayload>
          }
          deleteMany: {
            args: Prisma.CraftingHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CraftingHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CraftingHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftingHistoryPayload>
          }
          aggregate: {
            args: Prisma.CraftingHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCraftingHistory>
          }
          groupBy: {
            args: Prisma.CraftingHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CraftingHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CraftingHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<CraftingHistoryCountAggregateOutputType> | number
          }
        }
      }
      DaoFurnace: {
        payload: Prisma.$DaoFurnacePayload<ExtArgs>
        fields: Prisma.DaoFurnaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DaoFurnaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaoFurnacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DaoFurnaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaoFurnacePayload>
          }
          findFirst: {
            args: Prisma.DaoFurnaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaoFurnacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DaoFurnaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaoFurnacePayload>
          }
          findMany: {
            args: Prisma.DaoFurnaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaoFurnacePayload>[]
          }
          create: {
            args: Prisma.DaoFurnaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaoFurnacePayload>
          }
          createMany: {
            args: Prisma.DaoFurnaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DaoFurnaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaoFurnacePayload>[]
          }
          delete: {
            args: Prisma.DaoFurnaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaoFurnacePayload>
          }
          update: {
            args: Prisma.DaoFurnaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaoFurnacePayload>
          }
          deleteMany: {
            args: Prisma.DaoFurnaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DaoFurnaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DaoFurnaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaoFurnacePayload>
          }
          aggregate: {
            args: Prisma.DaoFurnaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDaoFurnace>
          }
          groupBy: {
            args: Prisma.DaoFurnaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DaoFurnaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DaoFurnaceCountArgs<ExtArgs>
            result: $Utils.Optional<DaoFurnaceCountAggregateOutputType> | number
          }
        }
      }
      PlayerFurnace: {
        payload: Prisma.$PlayerFurnacePayload<ExtArgs>
        fields: Prisma.PlayerFurnaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFurnaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFurnacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFurnaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFurnacePayload>
          }
          findFirst: {
            args: Prisma.PlayerFurnaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFurnacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFurnaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFurnacePayload>
          }
          findMany: {
            args: Prisma.PlayerFurnaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFurnacePayload>[]
          }
          create: {
            args: Prisma.PlayerFurnaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFurnacePayload>
          }
          createMany: {
            args: Prisma.PlayerFurnaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerFurnaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFurnacePayload>[]
          }
          delete: {
            args: Prisma.PlayerFurnaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFurnacePayload>
          }
          update: {
            args: Prisma.PlayerFurnaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFurnacePayload>
          }
          deleteMany: {
            args: Prisma.PlayerFurnaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerFurnaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerFurnaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFurnacePayload>
          }
          aggregate: {
            args: Prisma.PlayerFurnaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerFurnace>
          }
          groupBy: {
            args: Prisma.PlayerFurnaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerFurnaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerFurnaceCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerFurnaceCountAggregateOutputType> | number
          }
        }
      }
      SpiritBeastType: {
        payload: Prisma.$SpiritBeastTypePayload<ExtArgs>
        fields: Prisma.SpiritBeastTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpiritBeastTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpiritBeastTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastTypePayload>
          }
          findFirst: {
            args: Prisma.SpiritBeastTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpiritBeastTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastTypePayload>
          }
          findMany: {
            args: Prisma.SpiritBeastTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastTypePayload>[]
          }
          create: {
            args: Prisma.SpiritBeastTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastTypePayload>
          }
          createMany: {
            args: Prisma.SpiritBeastTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpiritBeastTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastTypePayload>[]
          }
          delete: {
            args: Prisma.SpiritBeastTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastTypePayload>
          }
          update: {
            args: Prisma.SpiritBeastTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastTypePayload>
          }
          deleteMany: {
            args: Prisma.SpiritBeastTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpiritBeastTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpiritBeastTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastTypePayload>
          }
          aggregate: {
            args: Prisma.SpiritBeastTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpiritBeastType>
          }
          groupBy: {
            args: Prisma.SpiritBeastTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpiritBeastTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpiritBeastTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SpiritBeastTypeCountAggregateOutputType> | number
          }
        }
      }
      SpiritBeast: {
        payload: Prisma.$SpiritBeastPayload<ExtArgs>
        fields: Prisma.SpiritBeastFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpiritBeastFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpiritBeastFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastPayload>
          }
          findFirst: {
            args: Prisma.SpiritBeastFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpiritBeastFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastPayload>
          }
          findMany: {
            args: Prisma.SpiritBeastFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastPayload>[]
          }
          create: {
            args: Prisma.SpiritBeastCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastPayload>
          }
          createMany: {
            args: Prisma.SpiritBeastCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpiritBeastCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastPayload>[]
          }
          delete: {
            args: Prisma.SpiritBeastDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastPayload>
          }
          update: {
            args: Prisma.SpiritBeastUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastPayload>
          }
          deleteMany: {
            args: Prisma.SpiritBeastDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpiritBeastUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpiritBeastUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiritBeastPayload>
          }
          aggregate: {
            args: Prisma.SpiritBeastAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpiritBeast>
          }
          groupBy: {
            args: Prisma.SpiritBeastGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpiritBeastGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpiritBeastCountArgs<ExtArgs>
            result: $Utils.Optional<SpiritBeastCountAggregateOutputType> | number
          }
        }
      }
      BeastFood: {
        payload: Prisma.$BeastFoodPayload<ExtArgs>
        fields: Prisma.BeastFoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BeastFoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BeastFoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFoodPayload>
          }
          findFirst: {
            args: Prisma.BeastFoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BeastFoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFoodPayload>
          }
          findMany: {
            args: Prisma.BeastFoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFoodPayload>[]
          }
          create: {
            args: Prisma.BeastFoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFoodPayload>
          }
          createMany: {
            args: Prisma.BeastFoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BeastFoodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFoodPayload>[]
          }
          delete: {
            args: Prisma.BeastFoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFoodPayload>
          }
          update: {
            args: Prisma.BeastFoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFoodPayload>
          }
          deleteMany: {
            args: Prisma.BeastFoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BeastFoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BeastFoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFoodPayload>
          }
          aggregate: {
            args: Prisma.BeastFoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBeastFood>
          }
          groupBy: {
            args: Prisma.BeastFoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<BeastFoodGroupByOutputType>[]
          }
          count: {
            args: Prisma.BeastFoodCountArgs<ExtArgs>
            result: $Utils.Optional<BeastFoodCountAggregateOutputType> | number
          }
        }
      }
      BeastFeedingHistory: {
        payload: Prisma.$BeastFeedingHistoryPayload<ExtArgs>
        fields: Prisma.BeastFeedingHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BeastFeedingHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFeedingHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BeastFeedingHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFeedingHistoryPayload>
          }
          findFirst: {
            args: Prisma.BeastFeedingHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFeedingHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BeastFeedingHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFeedingHistoryPayload>
          }
          findMany: {
            args: Prisma.BeastFeedingHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFeedingHistoryPayload>[]
          }
          create: {
            args: Prisma.BeastFeedingHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFeedingHistoryPayload>
          }
          createMany: {
            args: Prisma.BeastFeedingHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BeastFeedingHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFeedingHistoryPayload>[]
          }
          delete: {
            args: Prisma.BeastFeedingHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFeedingHistoryPayload>
          }
          update: {
            args: Prisma.BeastFeedingHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFeedingHistoryPayload>
          }
          deleteMany: {
            args: Prisma.BeastFeedingHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BeastFeedingHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BeastFeedingHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeastFeedingHistoryPayload>
          }
          aggregate: {
            args: Prisma.BeastFeedingHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBeastFeedingHistory>
          }
          groupBy: {
            args: Prisma.BeastFeedingHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BeastFeedingHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BeastFeedingHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<BeastFeedingHistoryCountAggregateOutputType> | number
          }
        }
      }
      HuntingGround: {
        payload: Prisma.$HuntingGroundPayload<ExtArgs>
        fields: Prisma.HuntingGroundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HuntingGroundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingGroundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HuntingGroundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingGroundPayload>
          }
          findFirst: {
            args: Prisma.HuntingGroundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingGroundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HuntingGroundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingGroundPayload>
          }
          findMany: {
            args: Prisma.HuntingGroundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingGroundPayload>[]
          }
          create: {
            args: Prisma.HuntingGroundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingGroundPayload>
          }
          createMany: {
            args: Prisma.HuntingGroundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HuntingGroundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingGroundPayload>[]
          }
          delete: {
            args: Prisma.HuntingGroundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingGroundPayload>
          }
          update: {
            args: Prisma.HuntingGroundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingGroundPayload>
          }
          deleteMany: {
            args: Prisma.HuntingGroundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HuntingGroundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HuntingGroundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingGroundPayload>
          }
          aggregate: {
            args: Prisma.HuntingGroundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHuntingGround>
          }
          groupBy: {
            args: Prisma.HuntingGroundGroupByArgs<ExtArgs>
            result: $Utils.Optional<HuntingGroundGroupByOutputType>[]
          }
          count: {
            args: Prisma.HuntingGroundCountArgs<ExtArgs>
            result: $Utils.Optional<HuntingGroundCountAggregateOutputType> | number
          }
        }
      }
      HuntingHistory: {
        payload: Prisma.$HuntingHistoryPayload<ExtArgs>
        fields: Prisma.HuntingHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HuntingHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HuntingHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingHistoryPayload>
          }
          findFirst: {
            args: Prisma.HuntingHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HuntingHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingHistoryPayload>
          }
          findMany: {
            args: Prisma.HuntingHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingHistoryPayload>[]
          }
          create: {
            args: Prisma.HuntingHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingHistoryPayload>
          }
          createMany: {
            args: Prisma.HuntingHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HuntingHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingHistoryPayload>[]
          }
          delete: {
            args: Prisma.HuntingHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingHistoryPayload>
          }
          update: {
            args: Prisma.HuntingHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingHistoryPayload>
          }
          deleteMany: {
            args: Prisma.HuntingHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HuntingHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HuntingHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HuntingHistoryPayload>
          }
          aggregate: {
            args: Prisma.HuntingHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHuntingHistory>
          }
          groupBy: {
            args: Prisma.HuntingHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<HuntingHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.HuntingHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<HuntingHistoryCountAggregateOutputType> | number
          }
        }
      }
      PlayerCultivation: {
        payload: Prisma.$PlayerCultivationPayload<ExtArgs>
        fields: Prisma.PlayerCultivationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerCultivationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCultivationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerCultivationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCultivationPayload>
          }
          findFirst: {
            args: Prisma.PlayerCultivationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCultivationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerCultivationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCultivationPayload>
          }
          findMany: {
            args: Prisma.PlayerCultivationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCultivationPayload>[]
          }
          create: {
            args: Prisma.PlayerCultivationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCultivationPayload>
          }
          createMany: {
            args: Prisma.PlayerCultivationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCultivationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCultivationPayload>[]
          }
          delete: {
            args: Prisma.PlayerCultivationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCultivationPayload>
          }
          update: {
            args: Prisma.PlayerCultivationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCultivationPayload>
          }
          deleteMany: {
            args: Prisma.PlayerCultivationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerCultivationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerCultivationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCultivationPayload>
          }
          aggregate: {
            args: Prisma.PlayerCultivationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerCultivation>
          }
          groupBy: {
            args: Prisma.PlayerCultivationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerCultivationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCultivationCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCultivationCountAggregateOutputType> | number
          }
        }
      }
      CultivationLog: {
        payload: Prisma.$CultivationLogPayload<ExtArgs>
        fields: Prisma.CultivationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CultivationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CultivationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationLogPayload>
          }
          findFirst: {
            args: Prisma.CultivationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CultivationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationLogPayload>
          }
          findMany: {
            args: Prisma.CultivationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationLogPayload>[]
          }
          create: {
            args: Prisma.CultivationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationLogPayload>
          }
          createMany: {
            args: Prisma.CultivationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CultivationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationLogPayload>[]
          }
          delete: {
            args: Prisma.CultivationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationLogPayload>
          }
          update: {
            args: Prisma.CultivationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationLogPayload>
          }
          deleteMany: {
            args: Prisma.CultivationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CultivationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CultivationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationLogPayload>
          }
          aggregate: {
            args: Prisma.CultivationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCultivationLog>
          }
          groupBy: {
            args: Prisma.CultivationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CultivationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CultivationLogCountArgs<ExtArgs>
            result: $Utils.Optional<CultivationLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type PlayerCountOutputType
   */

  export type PlayerCountOutputType = {
    resources: number
    companions: number
    achievements: number
    quests: number
    equipments: number
    skills: number
    talents: number
    buffs: number
    purchases: number
    inventory: number
    craftingHistory: number
    furnaces: number
    spiritBeasts: number
    beastFeedingHistory: number
    huntingHistory: number
    cultivationLogs: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | PlayerCountOutputTypeCountResourcesArgs
    companions?: boolean | PlayerCountOutputTypeCountCompanionsArgs
    achievements?: boolean | PlayerCountOutputTypeCountAchievementsArgs
    quests?: boolean | PlayerCountOutputTypeCountQuestsArgs
    equipments?: boolean | PlayerCountOutputTypeCountEquipmentsArgs
    skills?: boolean | PlayerCountOutputTypeCountSkillsArgs
    talents?: boolean | PlayerCountOutputTypeCountTalentsArgs
    buffs?: boolean | PlayerCountOutputTypeCountBuffsArgs
    purchases?: boolean | PlayerCountOutputTypeCountPurchasesArgs
    inventory?: boolean | PlayerCountOutputTypeCountInventoryArgs
    craftingHistory?: boolean | PlayerCountOutputTypeCountCraftingHistoryArgs
    furnaces?: boolean | PlayerCountOutputTypeCountFurnacesArgs
    spiritBeasts?: boolean | PlayerCountOutputTypeCountSpiritBeastsArgs
    beastFeedingHistory?: boolean | PlayerCountOutputTypeCountBeastFeedingHistoryArgs
    huntingHistory?: boolean | PlayerCountOutputTypeCountHuntingHistoryArgs
    cultivationLogs?: boolean | PlayerCountOutputTypeCountCultivationLogsArgs
  }

  // Custom InputTypes
  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerResourceWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountCompanionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerCompanionWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerAchievementWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerQuestWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountEquipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerEquipmentWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerSkillWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountTalentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerTalentWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountBuffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerBuffWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseHistoryWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountCraftingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CraftingHistoryWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountFurnacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerFurnaceWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountSpiritBeastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpiritBeastWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountBeastFeedingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeastFeedingHistoryWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountHuntingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HuntingHistoryWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountCultivationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultivationLogWhereInput
  }


  /**
   * Count Type ResourceCountOutputType
   */

  export type ResourceCountOutputType = {
    playerResources: number
  }

  export type ResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerResources?: boolean | ResourceCountOutputTypeCountPlayerResourcesArgs
  }

  // Custom InputTypes
  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCountOutputType
     */
    select?: ResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountPlayerResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerResourceWhereInput
  }


  /**
   * Count Type CompanionCountOutputType
   */

  export type CompanionCountOutputType = {
    playerCompanions: number
  }

  export type CompanionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerCompanions?: boolean | CompanionCountOutputTypeCountPlayerCompanionsArgs
  }

  // Custom InputTypes
  /**
   * CompanionCountOutputType without action
   */
  export type CompanionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanionCountOutputType
     */
    select?: CompanionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanionCountOutputType without action
   */
  export type CompanionCountOutputTypeCountPlayerCompanionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerCompanionWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    playerAchievements: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerAchievements?: boolean | AchievementCountOutputTypeCountPlayerAchievementsArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountPlayerAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerAchievementWhereInput
  }


  /**
   * Count Type QuestCountOutputType
   */

  export type QuestCountOutputType = {
    playerQuests: number
  }

  export type QuestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerQuests?: boolean | QuestCountOutputTypeCountPlayerQuestsArgs
  }

  // Custom InputTypes
  /**
   * QuestCountOutputType without action
   */
  export type QuestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestCountOutputType
     */
    select?: QuestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestCountOutputType without action
   */
  export type QuestCountOutputTypeCountPlayerQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerQuestWhereInput
  }


  /**
   * Count Type EquipmentTypeCountOutputType
   */

  export type EquipmentTypeCountOutputType = {
    equipments: number
  }

  export type EquipmentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipments?: boolean | EquipmentTypeCountOutputTypeCountEquipmentsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentTypeCountOutputType without action
   */
  export type EquipmentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentTypeCountOutputType
     */
    select?: EquipmentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentTypeCountOutputType without action
   */
  export type EquipmentTypeCountOutputTypeCountEquipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    playerEquipments: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerEquipments?: boolean | EquipmentCountOutputTypeCountPlayerEquipmentsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountPlayerEquipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerEquipmentWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    playerSkills: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerSkills?: boolean | SkillCountOutputTypeCountPlayerSkillsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountPlayerSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerSkillWhereInput
  }


  /**
   * Count Type TalentTypeCountOutputType
   */

  export type TalentTypeCountOutputType = {
    talents: number
  }

  export type TalentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    talents?: boolean | TalentTypeCountOutputTypeCountTalentsArgs
  }

  // Custom InputTypes
  /**
   * TalentTypeCountOutputType without action
   */
  export type TalentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentTypeCountOutputType
     */
    select?: TalentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TalentTypeCountOutputType without action
   */
  export type TalentTypeCountOutputTypeCountTalentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TalentWhereInput
  }


  /**
   * Count Type TalentCountOutputType
   */

  export type TalentCountOutputType = {
    playerTalents: number
  }

  export type TalentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerTalents?: boolean | TalentCountOutputTypeCountPlayerTalentsArgs
  }

  // Custom InputTypes
  /**
   * TalentCountOutputType without action
   */
  export type TalentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentCountOutputType
     */
    select?: TalentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TalentCountOutputType without action
   */
  export type TalentCountOutputTypeCountPlayerTalentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerTalentWhereInput
  }


  /**
   * Count Type BuffCountOutputType
   */

  export type BuffCountOutputType = {
    playerBuffs: number
  }

  export type BuffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerBuffs?: boolean | BuffCountOutputTypeCountPlayerBuffsArgs
  }

  // Custom InputTypes
  /**
   * BuffCountOutputType without action
   */
  export type BuffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffCountOutputType
     */
    select?: BuffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuffCountOutputType without action
   */
  export type BuffCountOutputTypeCountPlayerBuffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerBuffWhereInput
  }


  /**
   * Count Type ShopCountOutputType
   */

  export type ShopCountOutputType = {
    items: number
    purchases: number
  }

  export type ShopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ShopCountOutputTypeCountItemsArgs
    purchases?: boolean | ShopCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCountOutputType
     */
    select?: ShopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseHistoryWhereInput
  }


  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    craftingHistory: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    craftingHistory?: boolean | RecipeCountOutputTypeCountCraftingHistoryArgs
  }

  // Custom InputTypes
  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountCraftingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CraftingHistoryWhereInput
  }


  /**
   * Count Type DaoFurnaceCountOutputType
   */

  export type DaoFurnaceCountOutputType = {
    playerFurnaces: number
  }

  export type DaoFurnaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerFurnaces?: boolean | DaoFurnaceCountOutputTypeCountPlayerFurnacesArgs
  }

  // Custom InputTypes
  /**
   * DaoFurnaceCountOutputType without action
   */
  export type DaoFurnaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnaceCountOutputType
     */
    select?: DaoFurnaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DaoFurnaceCountOutputType without action
   */
  export type DaoFurnaceCountOutputTypeCountPlayerFurnacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerFurnaceWhereInput
  }


  /**
   * Count Type SpiritBeastTypeCountOutputType
   */

  export type SpiritBeastTypeCountOutputType = {
    beasts: number
  }

  export type SpiritBeastTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beasts?: boolean | SpiritBeastTypeCountOutputTypeCountBeastsArgs
  }

  // Custom InputTypes
  /**
   * SpiritBeastTypeCountOutputType without action
   */
  export type SpiritBeastTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastTypeCountOutputType
     */
    select?: SpiritBeastTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpiritBeastTypeCountOutputType without action
   */
  export type SpiritBeastTypeCountOutputTypeCountBeastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpiritBeastWhereInput
  }


  /**
   * Count Type SpiritBeastCountOutputType
   */

  export type SpiritBeastCountOutputType = {
    feedingHistory: number
    huntingHistory: number
  }

  export type SpiritBeastCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedingHistory?: boolean | SpiritBeastCountOutputTypeCountFeedingHistoryArgs
    huntingHistory?: boolean | SpiritBeastCountOutputTypeCountHuntingHistoryArgs
  }

  // Custom InputTypes
  /**
   * SpiritBeastCountOutputType without action
   */
  export type SpiritBeastCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastCountOutputType
     */
    select?: SpiritBeastCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpiritBeastCountOutputType without action
   */
  export type SpiritBeastCountOutputTypeCountFeedingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeastFeedingHistoryWhereInput
  }

  /**
   * SpiritBeastCountOutputType without action
   */
  export type SpiritBeastCountOutputTypeCountHuntingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HuntingHistoryWhereInput
  }


  /**
   * Count Type BeastFoodCountOutputType
   */

  export type BeastFoodCountOutputType = {
    feedingHistory: number
  }

  export type BeastFoodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedingHistory?: boolean | BeastFoodCountOutputTypeCountFeedingHistoryArgs
  }

  // Custom InputTypes
  /**
   * BeastFoodCountOutputType without action
   */
  export type BeastFoodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFoodCountOutputType
     */
    select?: BeastFoodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BeastFoodCountOutputType without action
   */
  export type BeastFoodCountOutputTypeCountFeedingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeastFeedingHistoryWhereInput
  }


  /**
   * Count Type HuntingGroundCountOutputType
   */

  export type HuntingGroundCountOutputType = {
    huntingHistory: number
  }

  export type HuntingGroundCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    huntingHistory?: boolean | HuntingGroundCountOutputTypeCountHuntingHistoryArgs
  }

  // Custom InputTypes
  /**
   * HuntingGroundCountOutputType without action
   */
  export type HuntingGroundCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGroundCountOutputType
     */
    select?: HuntingGroundCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HuntingGroundCountOutputType without action
   */
  export type HuntingGroundCountOutputTypeCountHuntingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HuntingHistoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    password: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | User$playerArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | User$playerArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      password: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends User$playerArgs<ExtArgs> = {}>(args?: Subset<T, User$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.player
   */
  export type User$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    level: number | null
    experience: number | null
  }

  export type PlayerSumAggregateOutputType = {
    level: number | null
    experience: bigint | null
  }

  export type PlayerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    level: number | null
    realm: string | null
    experience: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    level: number | null
    realm: string | null
    experience: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    level: number
    realm: number
    experience: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    level?: true
    experience?: true
  }

  export type PlayerSumAggregateInputType = {
    level?: true
    experience?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    level?: true
    realm?: true
    experience?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    level?: true
    realm?: true
    experience?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    level?: true
    realm?: true
    experience?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: string
    userId: string
    name: string
    level: number
    realm: string
    experience: bigint
    createdAt: Date
    updatedAt: Date
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    level?: boolean
    realm?: boolean
    experience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resources?: boolean | Player$resourcesArgs<ExtArgs>
    companions?: boolean | Player$companionsArgs<ExtArgs>
    achievements?: boolean | Player$achievementsArgs<ExtArgs>
    quests?: boolean | Player$questsArgs<ExtArgs>
    stats?: boolean | Player$statsArgs<ExtArgs>
    equipments?: boolean | Player$equipmentsArgs<ExtArgs>
    skills?: boolean | Player$skillsArgs<ExtArgs>
    talents?: boolean | Player$talentsArgs<ExtArgs>
    buffs?: boolean | Player$buffsArgs<ExtArgs>
    purchases?: boolean | Player$purchasesArgs<ExtArgs>
    inventory?: boolean | Player$inventoryArgs<ExtArgs>
    craftingHistory?: boolean | Player$craftingHistoryArgs<ExtArgs>
    furnaces?: boolean | Player$furnacesArgs<ExtArgs>
    spiritBeasts?: boolean | Player$spiritBeastsArgs<ExtArgs>
    beastFeedingHistory?: boolean | Player$beastFeedingHistoryArgs<ExtArgs>
    huntingHistory?: boolean | Player$huntingHistoryArgs<ExtArgs>
    cultivationLogs?: boolean | Player$cultivationLogsArgs<ExtArgs>
    cultivation?: boolean | Player$cultivationArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    level?: boolean
    realm?: boolean
    experience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    level?: boolean
    realm?: boolean
    experience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resources?: boolean | Player$resourcesArgs<ExtArgs>
    companions?: boolean | Player$companionsArgs<ExtArgs>
    achievements?: boolean | Player$achievementsArgs<ExtArgs>
    quests?: boolean | Player$questsArgs<ExtArgs>
    stats?: boolean | Player$statsArgs<ExtArgs>
    equipments?: boolean | Player$equipmentsArgs<ExtArgs>
    skills?: boolean | Player$skillsArgs<ExtArgs>
    talents?: boolean | Player$talentsArgs<ExtArgs>
    buffs?: boolean | Player$buffsArgs<ExtArgs>
    purchases?: boolean | Player$purchasesArgs<ExtArgs>
    inventory?: boolean | Player$inventoryArgs<ExtArgs>
    craftingHistory?: boolean | Player$craftingHistoryArgs<ExtArgs>
    furnaces?: boolean | Player$furnacesArgs<ExtArgs>
    spiritBeasts?: boolean | Player$spiritBeastsArgs<ExtArgs>
    beastFeedingHistory?: boolean | Player$beastFeedingHistoryArgs<ExtArgs>
    huntingHistory?: boolean | Player$huntingHistoryArgs<ExtArgs>
    cultivationLogs?: boolean | Player$cultivationLogsArgs<ExtArgs>
    cultivation?: boolean | Player$cultivationArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resources: Prisma.$PlayerResourcePayload<ExtArgs>[]
      companions: Prisma.$PlayerCompanionPayload<ExtArgs>[]
      achievements: Prisma.$PlayerAchievementPayload<ExtArgs>[]
      quests: Prisma.$PlayerQuestPayload<ExtArgs>[]
      stats: Prisma.$PlayerStatsPayload<ExtArgs> | null
      equipments: Prisma.$PlayerEquipmentPayload<ExtArgs>[]
      skills: Prisma.$PlayerSkillPayload<ExtArgs>[]
      talents: Prisma.$PlayerTalentPayload<ExtArgs>[]
      buffs: Prisma.$PlayerBuffPayload<ExtArgs>[]
      purchases: Prisma.$PurchaseHistoryPayload<ExtArgs>[]
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      craftingHistory: Prisma.$CraftingHistoryPayload<ExtArgs>[]
      furnaces: Prisma.$PlayerFurnacePayload<ExtArgs>[]
      spiritBeasts: Prisma.$SpiritBeastPayload<ExtArgs>[]
      beastFeedingHistory: Prisma.$BeastFeedingHistoryPayload<ExtArgs>[]
      huntingHistory: Prisma.$HuntingHistoryPayload<ExtArgs>[]
      cultivationLogs: Prisma.$CultivationLogPayload<ExtArgs>[]
      cultivation: Prisma.$PlayerCultivationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      level: number
      realm: string
      experience: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resources<T extends Player$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Player$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "findMany"> | Null>
    companions<T extends Player$companionsArgs<ExtArgs> = {}>(args?: Subset<T, Player$companionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "findMany"> | Null>
    achievements<T extends Player$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, Player$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    quests<T extends Player$questsArgs<ExtArgs> = {}>(args?: Subset<T, Player$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "findMany"> | Null>
    stats<T extends Player$statsArgs<ExtArgs> = {}>(args?: Subset<T, Player$statsArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    equipments<T extends Player$equipmentsArgs<ExtArgs> = {}>(args?: Subset<T, Player$equipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findMany"> | Null>
    skills<T extends Player$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Player$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findMany"> | Null>
    talents<T extends Player$talentsArgs<ExtArgs> = {}>(args?: Subset<T, Player$talentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "findMany"> | Null>
    buffs<T extends Player$buffsArgs<ExtArgs> = {}>(args?: Subset<T, Player$buffsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "findMany"> | Null>
    purchases<T extends Player$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Player$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    inventory<T extends Player$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Player$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany"> | Null>
    craftingHistory<T extends Player$craftingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Player$craftingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    furnaces<T extends Player$furnacesArgs<ExtArgs> = {}>(args?: Subset<T, Player$furnacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "findMany"> | Null>
    spiritBeasts<T extends Player$spiritBeastsArgs<ExtArgs> = {}>(args?: Subset<T, Player$spiritBeastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "findMany"> | Null>
    beastFeedingHistory<T extends Player$beastFeedingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Player$beastFeedingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    huntingHistory<T extends Player$huntingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Player$huntingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    cultivationLogs<T extends Player$cultivationLogsArgs<ExtArgs> = {}>(args?: Subset<T, Player$cultivationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "findMany"> | Null>
    cultivation<T extends Player$cultivationArgs<ExtArgs> = {}>(args?: Subset<T, Player$cultivationArgs<ExtArgs>>): Prisma__PlayerCultivationClient<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */ 
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'String'>
    readonly userId: FieldRef<"Player", 'String'>
    readonly name: FieldRef<"Player", 'String'>
    readonly level: FieldRef<"Player", 'Int'>
    readonly realm: FieldRef<"Player", 'String'>
    readonly experience: FieldRef<"Player", 'BigInt'>
    readonly createdAt: FieldRef<"Player", 'DateTime'>
    readonly updatedAt: FieldRef<"Player", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
  }

  /**
   * Player.resources
   */
  export type Player$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    where?: PlayerResourceWhereInput
    orderBy?: PlayerResourceOrderByWithRelationInput | PlayerResourceOrderByWithRelationInput[]
    cursor?: PlayerResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerResourceScalarFieldEnum | PlayerResourceScalarFieldEnum[]
  }

  /**
   * Player.companions
   */
  export type Player$companionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    where?: PlayerCompanionWhereInput
    orderBy?: PlayerCompanionOrderByWithRelationInput | PlayerCompanionOrderByWithRelationInput[]
    cursor?: PlayerCompanionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerCompanionScalarFieldEnum | PlayerCompanionScalarFieldEnum[]
  }

  /**
   * Player.achievements
   */
  export type Player$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    where?: PlayerAchievementWhereInput
    orderBy?: PlayerAchievementOrderByWithRelationInput | PlayerAchievementOrderByWithRelationInput[]
    cursor?: PlayerAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerAchievementScalarFieldEnum | PlayerAchievementScalarFieldEnum[]
  }

  /**
   * Player.quests
   */
  export type Player$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    where?: PlayerQuestWhereInput
    orderBy?: PlayerQuestOrderByWithRelationInput | PlayerQuestOrderByWithRelationInput[]
    cursor?: PlayerQuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerQuestScalarFieldEnum | PlayerQuestScalarFieldEnum[]
  }

  /**
   * Player.stats
   */
  export type Player$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    where?: PlayerStatsWhereInput
  }

  /**
   * Player.equipments
   */
  export type Player$equipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    where?: PlayerEquipmentWhereInput
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    cursor?: PlayerEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerEquipmentScalarFieldEnum | PlayerEquipmentScalarFieldEnum[]
  }

  /**
   * Player.skills
   */
  export type Player$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    where?: PlayerSkillWhereInput
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    cursor?: PlayerSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerSkillScalarFieldEnum | PlayerSkillScalarFieldEnum[]
  }

  /**
   * Player.talents
   */
  export type Player$talentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    where?: PlayerTalentWhereInput
    orderBy?: PlayerTalentOrderByWithRelationInput | PlayerTalentOrderByWithRelationInput[]
    cursor?: PlayerTalentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerTalentScalarFieldEnum | PlayerTalentScalarFieldEnum[]
  }

  /**
   * Player.buffs
   */
  export type Player$buffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    where?: PlayerBuffWhereInput
    orderBy?: PlayerBuffOrderByWithRelationInput | PlayerBuffOrderByWithRelationInput[]
    cursor?: PlayerBuffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerBuffScalarFieldEnum | PlayerBuffScalarFieldEnum[]
  }

  /**
   * Player.purchases
   */
  export type Player$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    where?: PurchaseHistoryWhereInput
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    cursor?: PurchaseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * Player.inventory
   */
  export type Player$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Player.craftingHistory
   */
  export type Player$craftingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    where?: CraftingHistoryWhereInput
    orderBy?: CraftingHistoryOrderByWithRelationInput | CraftingHistoryOrderByWithRelationInput[]
    cursor?: CraftingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CraftingHistoryScalarFieldEnum | CraftingHistoryScalarFieldEnum[]
  }

  /**
   * Player.furnaces
   */
  export type Player$furnacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    where?: PlayerFurnaceWhereInput
    orderBy?: PlayerFurnaceOrderByWithRelationInput | PlayerFurnaceOrderByWithRelationInput[]
    cursor?: PlayerFurnaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerFurnaceScalarFieldEnum | PlayerFurnaceScalarFieldEnum[]
  }

  /**
   * Player.spiritBeasts
   */
  export type Player$spiritBeastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    where?: SpiritBeastWhereInput
    orderBy?: SpiritBeastOrderByWithRelationInput | SpiritBeastOrderByWithRelationInput[]
    cursor?: SpiritBeastWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpiritBeastScalarFieldEnum | SpiritBeastScalarFieldEnum[]
  }

  /**
   * Player.beastFeedingHistory
   */
  export type Player$beastFeedingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    where?: BeastFeedingHistoryWhereInput
    orderBy?: BeastFeedingHistoryOrderByWithRelationInput | BeastFeedingHistoryOrderByWithRelationInput[]
    cursor?: BeastFeedingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeastFeedingHistoryScalarFieldEnum | BeastFeedingHistoryScalarFieldEnum[]
  }

  /**
   * Player.huntingHistory
   */
  export type Player$huntingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    where?: HuntingHistoryWhereInput
    orderBy?: HuntingHistoryOrderByWithRelationInput | HuntingHistoryOrderByWithRelationInput[]
    cursor?: HuntingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HuntingHistoryScalarFieldEnum | HuntingHistoryScalarFieldEnum[]
  }

  /**
   * Player.cultivationLogs
   */
  export type Player$cultivationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
    where?: CultivationLogWhereInput
    orderBy?: CultivationLogOrderByWithRelationInput | CultivationLogOrderByWithRelationInput[]
    cursor?: CultivationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultivationLogScalarFieldEnum | CultivationLogScalarFieldEnum[]
  }

  /**
   * Player.cultivation
   */
  export type Player$cultivationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
    where?: PlayerCultivationWhereInput
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    icon: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    icon: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    icon: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    icon: string | null
    color: string | null
    createdAt: Date
    updatedAt: Date
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playerResources?: boolean | Resource$playerResourcesArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerResources?: boolean | Resource$playerResourcesArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      playerResources: Prisma.$PlayerResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      icon: string | null
      color: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playerResources<T extends Resource$playerResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Resource$playerResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */ 
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'String'>
    readonly name: FieldRef<"Resource", 'String'>
    readonly displayName: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly icon: FieldRef<"Resource", 'String'>
    readonly color: FieldRef<"Resource", 'String'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly updatedAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource.playerResources
   */
  export type Resource$playerResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    where?: PlayerResourceWhereInput
    orderBy?: PlayerResourceOrderByWithRelationInput | PlayerResourceOrderByWithRelationInput[]
    cursor?: PlayerResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerResourceScalarFieldEnum | PlayerResourceScalarFieldEnum[]
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model PlayerResource
   */

  export type AggregatePlayerResource = {
    _count: PlayerResourceCountAggregateOutputType | null
    _avg: PlayerResourceAvgAggregateOutputType | null
    _sum: PlayerResourceSumAggregateOutputType | null
    _min: PlayerResourceMinAggregateOutputType | null
    _max: PlayerResourceMaxAggregateOutputType | null
  }

  export type PlayerResourceAvgAggregateOutputType = {
    amount: Decimal | null
    locked: Decimal | null
  }

  export type PlayerResourceSumAggregateOutputType = {
    amount: Decimal | null
    locked: Decimal | null
  }

  export type PlayerResourceMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    resourceId: string | null
    amount: Decimal | null
    locked: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerResourceMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    resourceId: string | null
    amount: Decimal | null
    locked: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerResourceCountAggregateOutputType = {
    id: number
    playerId: number
    resourceId: number
    amount: number
    locked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerResourceAvgAggregateInputType = {
    amount?: true
    locked?: true
  }

  export type PlayerResourceSumAggregateInputType = {
    amount?: true
    locked?: true
  }

  export type PlayerResourceMinAggregateInputType = {
    id?: true
    playerId?: true
    resourceId?: true
    amount?: true
    locked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerResourceMaxAggregateInputType = {
    id?: true
    playerId?: true
    resourceId?: true
    amount?: true
    locked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerResourceCountAggregateInputType = {
    id?: true
    playerId?: true
    resourceId?: true
    amount?: true
    locked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerResource to aggregate.
     */
    where?: PlayerResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerResources to fetch.
     */
    orderBy?: PlayerResourceOrderByWithRelationInput | PlayerResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerResources
    **/
    _count?: true | PlayerResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerResourceMaxAggregateInputType
  }

  export type GetPlayerResourceAggregateType<T extends PlayerResourceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerResource[P]>
      : GetScalarType<T[P], AggregatePlayerResource[P]>
  }




  export type PlayerResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerResourceWhereInput
    orderBy?: PlayerResourceOrderByWithAggregationInput | PlayerResourceOrderByWithAggregationInput[]
    by: PlayerResourceScalarFieldEnum[] | PlayerResourceScalarFieldEnum
    having?: PlayerResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerResourceCountAggregateInputType | true
    _avg?: PlayerResourceAvgAggregateInputType
    _sum?: PlayerResourceSumAggregateInputType
    _min?: PlayerResourceMinAggregateInputType
    _max?: PlayerResourceMaxAggregateInputType
  }

  export type PlayerResourceGroupByOutputType = {
    id: string
    playerId: string
    resourceId: string
    amount: Decimal
    locked: Decimal
    createdAt: Date
    updatedAt: Date
    _count: PlayerResourceCountAggregateOutputType | null
    _avg: PlayerResourceAvgAggregateOutputType | null
    _sum: PlayerResourceSumAggregateOutputType | null
    _min: PlayerResourceMinAggregateOutputType | null
    _max: PlayerResourceMaxAggregateOutputType | null
  }

  type GetPlayerResourceGroupByPayload<T extends PlayerResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerResourceGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerResourceGroupByOutputType[P]>
        }
      >
    >


  export type PlayerResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    resourceId?: boolean
    amount?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerResource"]>

  export type PlayerResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    resourceId?: boolean
    amount?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerResource"]>

  export type PlayerResourceSelectScalar = {
    id?: boolean
    playerId?: boolean
    resourceId?: boolean
    amount?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type PlayerResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $PlayerResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerResource"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      resourceId: string
      amount: Prisma.Decimal
      locked: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerResource"]>
    composites: {}
  }

  type PlayerResourceGetPayload<S extends boolean | null | undefined | PlayerResourceDefaultArgs> = $Result.GetResult<Prisma.$PlayerResourcePayload, S>

  type PlayerResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerResourceCountAggregateInputType | true
    }

  export interface PlayerResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerResource'], meta: { name: 'PlayerResource' } }
    /**
     * Find zero or one PlayerResource that matches the filter.
     * @param {PlayerResourceFindUniqueArgs} args - Arguments to find a PlayerResource
     * @example
     * // Get one PlayerResource
     * const playerResource = await prisma.playerResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerResourceFindUniqueArgs>(args: SelectSubset<T, PlayerResourceFindUniqueArgs<ExtArgs>>): Prisma__PlayerResourceClient<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerResource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerResourceFindUniqueOrThrowArgs} args - Arguments to find a PlayerResource
     * @example
     * // Get one PlayerResource
     * const playerResource = await prisma.playerResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerResourceClient<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerResourceFindFirstArgs} args - Arguments to find a PlayerResource
     * @example
     * // Get one PlayerResource
     * const playerResource = await prisma.playerResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerResourceFindFirstArgs>(args?: SelectSubset<T, PlayerResourceFindFirstArgs<ExtArgs>>): Prisma__PlayerResourceClient<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerResourceFindFirstOrThrowArgs} args - Arguments to find a PlayerResource
     * @example
     * // Get one PlayerResource
     * const playerResource = await prisma.playerResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerResourceClient<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerResources
     * const playerResources = await prisma.playerResource.findMany()
     * 
     * // Get first 10 PlayerResources
     * const playerResources = await prisma.playerResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerResourceWithIdOnly = await prisma.playerResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerResourceFindManyArgs>(args?: SelectSubset<T, PlayerResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerResource.
     * @param {PlayerResourceCreateArgs} args - Arguments to create a PlayerResource.
     * @example
     * // Create one PlayerResource
     * const PlayerResource = await prisma.playerResource.create({
     *   data: {
     *     // ... data to create a PlayerResource
     *   }
     * })
     * 
     */
    create<T extends PlayerResourceCreateArgs>(args: SelectSubset<T, PlayerResourceCreateArgs<ExtArgs>>): Prisma__PlayerResourceClient<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerResources.
     * @param {PlayerResourceCreateManyArgs} args - Arguments to create many PlayerResources.
     * @example
     * // Create many PlayerResources
     * const playerResource = await prisma.playerResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerResourceCreateManyArgs>(args?: SelectSubset<T, PlayerResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerResources and returns the data saved in the database.
     * @param {PlayerResourceCreateManyAndReturnArgs} args - Arguments to create many PlayerResources.
     * @example
     * // Create many PlayerResources
     * const playerResource = await prisma.playerResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerResources and only return the `id`
     * const playerResourceWithIdOnly = await prisma.playerResource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerResource.
     * @param {PlayerResourceDeleteArgs} args - Arguments to delete one PlayerResource.
     * @example
     * // Delete one PlayerResource
     * const PlayerResource = await prisma.playerResource.delete({
     *   where: {
     *     // ... filter to delete one PlayerResource
     *   }
     * })
     * 
     */
    delete<T extends PlayerResourceDeleteArgs>(args: SelectSubset<T, PlayerResourceDeleteArgs<ExtArgs>>): Prisma__PlayerResourceClient<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerResource.
     * @param {PlayerResourceUpdateArgs} args - Arguments to update one PlayerResource.
     * @example
     * // Update one PlayerResource
     * const playerResource = await prisma.playerResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerResourceUpdateArgs>(args: SelectSubset<T, PlayerResourceUpdateArgs<ExtArgs>>): Prisma__PlayerResourceClient<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerResources.
     * @param {PlayerResourceDeleteManyArgs} args - Arguments to filter PlayerResources to delete.
     * @example
     * // Delete a few PlayerResources
     * const { count } = await prisma.playerResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerResourceDeleteManyArgs>(args?: SelectSubset<T, PlayerResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerResources
     * const playerResource = await prisma.playerResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerResourceUpdateManyArgs>(args: SelectSubset<T, PlayerResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerResource.
     * @param {PlayerResourceUpsertArgs} args - Arguments to update or create a PlayerResource.
     * @example
     * // Update or create a PlayerResource
     * const playerResource = await prisma.playerResource.upsert({
     *   create: {
     *     // ... data to create a PlayerResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerResource we want to update
     *   }
     * })
     */
    upsert<T extends PlayerResourceUpsertArgs>(args: SelectSubset<T, PlayerResourceUpsertArgs<ExtArgs>>): Prisma__PlayerResourceClient<$Result.GetResult<Prisma.$PlayerResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerResourceCountArgs} args - Arguments to filter PlayerResources to count.
     * @example
     * // Count the number of PlayerResources
     * const count = await prisma.playerResource.count({
     *   where: {
     *     // ... the filter for the PlayerResources we want to count
     *   }
     * })
    **/
    count<T extends PlayerResourceCountArgs>(
      args?: Subset<T, PlayerResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerResourceAggregateArgs>(args: Subset<T, PlayerResourceAggregateArgs>): Prisma.PrismaPromise<GetPlayerResourceAggregateType<T>>

    /**
     * Group by PlayerResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerResourceGroupByArgs['orderBy'] }
        : { orderBy?: PlayerResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerResource model
   */
  readonly fields: PlayerResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerResource model
   */ 
  interface PlayerResourceFieldRefs {
    readonly id: FieldRef<"PlayerResource", 'String'>
    readonly playerId: FieldRef<"PlayerResource", 'String'>
    readonly resourceId: FieldRef<"PlayerResource", 'String'>
    readonly amount: FieldRef<"PlayerResource", 'Decimal'>
    readonly locked: FieldRef<"PlayerResource", 'Decimal'>
    readonly createdAt: FieldRef<"PlayerResource", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerResource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerResource findUnique
   */
  export type PlayerResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    /**
     * Filter, which PlayerResource to fetch.
     */
    where: PlayerResourceWhereUniqueInput
  }

  /**
   * PlayerResource findUniqueOrThrow
   */
  export type PlayerResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    /**
     * Filter, which PlayerResource to fetch.
     */
    where: PlayerResourceWhereUniqueInput
  }

  /**
   * PlayerResource findFirst
   */
  export type PlayerResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    /**
     * Filter, which PlayerResource to fetch.
     */
    where?: PlayerResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerResources to fetch.
     */
    orderBy?: PlayerResourceOrderByWithRelationInput | PlayerResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerResources.
     */
    cursor?: PlayerResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerResources.
     */
    distinct?: PlayerResourceScalarFieldEnum | PlayerResourceScalarFieldEnum[]
  }

  /**
   * PlayerResource findFirstOrThrow
   */
  export type PlayerResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    /**
     * Filter, which PlayerResource to fetch.
     */
    where?: PlayerResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerResources to fetch.
     */
    orderBy?: PlayerResourceOrderByWithRelationInput | PlayerResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerResources.
     */
    cursor?: PlayerResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerResources.
     */
    distinct?: PlayerResourceScalarFieldEnum | PlayerResourceScalarFieldEnum[]
  }

  /**
   * PlayerResource findMany
   */
  export type PlayerResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    /**
     * Filter, which PlayerResources to fetch.
     */
    where?: PlayerResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerResources to fetch.
     */
    orderBy?: PlayerResourceOrderByWithRelationInput | PlayerResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerResources.
     */
    cursor?: PlayerResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerResources.
     */
    skip?: number
    distinct?: PlayerResourceScalarFieldEnum | PlayerResourceScalarFieldEnum[]
  }

  /**
   * PlayerResource create
   */
  export type PlayerResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerResource.
     */
    data: XOR<PlayerResourceCreateInput, PlayerResourceUncheckedCreateInput>
  }

  /**
   * PlayerResource createMany
   */
  export type PlayerResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerResources.
     */
    data: PlayerResourceCreateManyInput | PlayerResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerResource createManyAndReturn
   */
  export type PlayerResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerResources.
     */
    data: PlayerResourceCreateManyInput | PlayerResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerResource update
   */
  export type PlayerResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerResource.
     */
    data: XOR<PlayerResourceUpdateInput, PlayerResourceUncheckedUpdateInput>
    /**
     * Choose, which PlayerResource to update.
     */
    where: PlayerResourceWhereUniqueInput
  }

  /**
   * PlayerResource updateMany
   */
  export type PlayerResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerResources.
     */
    data: XOR<PlayerResourceUpdateManyMutationInput, PlayerResourceUncheckedUpdateManyInput>
    /**
     * Filter which PlayerResources to update
     */
    where?: PlayerResourceWhereInput
  }

  /**
   * PlayerResource upsert
   */
  export type PlayerResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerResource to update in case it exists.
     */
    where: PlayerResourceWhereUniqueInput
    /**
     * In case the PlayerResource found by the `where` argument doesn't exist, create a new PlayerResource with this data.
     */
    create: XOR<PlayerResourceCreateInput, PlayerResourceUncheckedCreateInput>
    /**
     * In case the PlayerResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerResourceUpdateInput, PlayerResourceUncheckedUpdateInput>
  }

  /**
   * PlayerResource delete
   */
  export type PlayerResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
    /**
     * Filter which PlayerResource to delete.
     */
    where: PlayerResourceWhereUniqueInput
  }

  /**
   * PlayerResource deleteMany
   */
  export type PlayerResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerResources to delete
     */
    where?: PlayerResourceWhereInput
  }

  /**
   * PlayerResource without action
   */
  export type PlayerResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerResource
     */
    select?: PlayerResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerResourceInclude<ExtArgs> | null
  }


  /**
   * Model Companion
   */

  export type AggregateCompanion = {
    _count: CompanionCountAggregateOutputType | null
    _avg: CompanionAvgAggregateOutputType | null
    _sum: CompanionSumAggregateOutputType | null
    _min: CompanionMinAggregateOutputType | null
    _max: CompanionMaxAggregateOutputType | null
  }

  export type CompanionAvgAggregateOutputType = {
    basePower: number | null
  }

  export type CompanionSumAggregateOutputType = {
    basePower: number | null
  }

  export type CompanionMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    icon: string | null
    rarity: string | null
    basePower: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    icon: string | null
    rarity: string | null
    basePower: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanionCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    icon: number
    rarity: number
    basePower: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanionAvgAggregateInputType = {
    basePower?: true
  }

  export type CompanionSumAggregateInputType = {
    basePower?: true
  }

  export type CompanionMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    rarity?: true
    basePower?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanionMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    rarity?: true
    basePower?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanionCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    rarity?: true
    basePower?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companion to aggregate.
     */
    where?: CompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companions to fetch.
     */
    orderBy?: CompanionOrderByWithRelationInput | CompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companions
    **/
    _count?: true | CompanionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanionMaxAggregateInputType
  }

  export type GetCompanionAggregateType<T extends CompanionAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanion[P]>
      : GetScalarType<T[P], AggregateCompanion[P]>
  }




  export type CompanionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanionWhereInput
    orderBy?: CompanionOrderByWithAggregationInput | CompanionOrderByWithAggregationInput[]
    by: CompanionScalarFieldEnum[] | CompanionScalarFieldEnum
    having?: CompanionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanionCountAggregateInputType | true
    _avg?: CompanionAvgAggregateInputType
    _sum?: CompanionSumAggregateInputType
    _min?: CompanionMinAggregateInputType
    _max?: CompanionMaxAggregateInputType
  }

  export type CompanionGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    icon: string | null
    rarity: string
    basePower: number
    createdAt: Date
    updatedAt: Date
    _count: CompanionCountAggregateOutputType | null
    _avg: CompanionAvgAggregateOutputType | null
    _sum: CompanionSumAggregateOutputType | null
    _min: CompanionMinAggregateOutputType | null
    _max: CompanionMaxAggregateOutputType | null
  }

  type GetCompanionGroupByPayload<T extends CompanionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanionGroupByOutputType[P]>
            : GetScalarType<T[P], CompanionGroupByOutputType[P]>
        }
      >
    >


  export type CompanionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    rarity?: boolean
    basePower?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playerCompanions?: boolean | Companion$playerCompanionsArgs<ExtArgs>
    _count?: boolean | CompanionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companion"]>

  export type CompanionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    rarity?: boolean
    basePower?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companion"]>

  export type CompanionSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    rarity?: boolean
    basePower?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerCompanions?: boolean | Companion$playerCompanionsArgs<ExtArgs>
    _count?: boolean | CompanionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Companion"
    objects: {
      playerCompanions: Prisma.$PlayerCompanionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      icon: string | null
      rarity: string
      basePower: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companion"]>
    composites: {}
  }

  type CompanionGetPayload<S extends boolean | null | undefined | CompanionDefaultArgs> = $Result.GetResult<Prisma.$CompanionPayload, S>

  type CompanionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanionCountAggregateInputType | true
    }

  export interface CompanionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Companion'], meta: { name: 'Companion' } }
    /**
     * Find zero or one Companion that matches the filter.
     * @param {CompanionFindUniqueArgs} args - Arguments to find a Companion
     * @example
     * // Get one Companion
     * const companion = await prisma.companion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanionFindUniqueArgs>(args: SelectSubset<T, CompanionFindUniqueArgs<ExtArgs>>): Prisma__CompanionClient<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Companion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanionFindUniqueOrThrowArgs} args - Arguments to find a Companion
     * @example
     * // Get one Companion
     * const companion = await prisma.companion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanionFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanionClient<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Companion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanionFindFirstArgs} args - Arguments to find a Companion
     * @example
     * // Get one Companion
     * const companion = await prisma.companion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanionFindFirstArgs>(args?: SelectSubset<T, CompanionFindFirstArgs<ExtArgs>>): Prisma__CompanionClient<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Companion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanionFindFirstOrThrowArgs} args - Arguments to find a Companion
     * @example
     * // Get one Companion
     * const companion = await prisma.companion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanionFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanionClient<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companions
     * const companions = await prisma.companion.findMany()
     * 
     * // Get first 10 Companions
     * const companions = await prisma.companion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companionWithIdOnly = await prisma.companion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanionFindManyArgs>(args?: SelectSubset<T, CompanionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Companion.
     * @param {CompanionCreateArgs} args - Arguments to create a Companion.
     * @example
     * // Create one Companion
     * const Companion = await prisma.companion.create({
     *   data: {
     *     // ... data to create a Companion
     *   }
     * })
     * 
     */
    create<T extends CompanionCreateArgs>(args: SelectSubset<T, CompanionCreateArgs<ExtArgs>>): Prisma__CompanionClient<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companions.
     * @param {CompanionCreateManyArgs} args - Arguments to create many Companions.
     * @example
     * // Create many Companions
     * const companion = await prisma.companion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanionCreateManyArgs>(args?: SelectSubset<T, CompanionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companions and returns the data saved in the database.
     * @param {CompanionCreateManyAndReturnArgs} args - Arguments to create many Companions.
     * @example
     * // Create many Companions
     * const companion = await prisma.companion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companions and only return the `id`
     * const companionWithIdOnly = await prisma.companion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanionCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Companion.
     * @param {CompanionDeleteArgs} args - Arguments to delete one Companion.
     * @example
     * // Delete one Companion
     * const Companion = await prisma.companion.delete({
     *   where: {
     *     // ... filter to delete one Companion
     *   }
     * })
     * 
     */
    delete<T extends CompanionDeleteArgs>(args: SelectSubset<T, CompanionDeleteArgs<ExtArgs>>): Prisma__CompanionClient<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Companion.
     * @param {CompanionUpdateArgs} args - Arguments to update one Companion.
     * @example
     * // Update one Companion
     * const companion = await prisma.companion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanionUpdateArgs>(args: SelectSubset<T, CompanionUpdateArgs<ExtArgs>>): Prisma__CompanionClient<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companions.
     * @param {CompanionDeleteManyArgs} args - Arguments to filter Companions to delete.
     * @example
     * // Delete a few Companions
     * const { count } = await prisma.companion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanionDeleteManyArgs>(args?: SelectSubset<T, CompanionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companions
     * const companion = await prisma.companion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanionUpdateManyArgs>(args: SelectSubset<T, CompanionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Companion.
     * @param {CompanionUpsertArgs} args - Arguments to update or create a Companion.
     * @example
     * // Update or create a Companion
     * const companion = await prisma.companion.upsert({
     *   create: {
     *     // ... data to create a Companion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companion we want to update
     *   }
     * })
     */
    upsert<T extends CompanionUpsertArgs>(args: SelectSubset<T, CompanionUpsertArgs<ExtArgs>>): Prisma__CompanionClient<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanionCountArgs} args - Arguments to filter Companions to count.
     * @example
     * // Count the number of Companions
     * const count = await prisma.companion.count({
     *   where: {
     *     // ... the filter for the Companions we want to count
     *   }
     * })
    **/
    count<T extends CompanionCountArgs>(
      args?: Subset<T, CompanionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanionAggregateArgs>(args: Subset<T, CompanionAggregateArgs>): Prisma.PrismaPromise<GetCompanionAggregateType<T>>

    /**
     * Group by Companion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanionGroupByArgs['orderBy'] }
        : { orderBy?: CompanionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Companion model
   */
  readonly fields: CompanionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Companion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playerCompanions<T extends Companion$playerCompanionsArgs<ExtArgs> = {}>(args?: Subset<T, Companion$playerCompanionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Companion model
   */ 
  interface CompanionFieldRefs {
    readonly id: FieldRef<"Companion", 'String'>
    readonly name: FieldRef<"Companion", 'String'>
    readonly displayName: FieldRef<"Companion", 'String'>
    readonly description: FieldRef<"Companion", 'String'>
    readonly icon: FieldRef<"Companion", 'String'>
    readonly rarity: FieldRef<"Companion", 'String'>
    readonly basePower: FieldRef<"Companion", 'Int'>
    readonly createdAt: FieldRef<"Companion", 'DateTime'>
    readonly updatedAt: FieldRef<"Companion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Companion findUnique
   */
  export type CompanionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanionInclude<ExtArgs> | null
    /**
     * Filter, which Companion to fetch.
     */
    where: CompanionWhereUniqueInput
  }

  /**
   * Companion findUniqueOrThrow
   */
  export type CompanionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanionInclude<ExtArgs> | null
    /**
     * Filter, which Companion to fetch.
     */
    where: CompanionWhereUniqueInput
  }

  /**
   * Companion findFirst
   */
  export type CompanionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanionInclude<ExtArgs> | null
    /**
     * Filter, which Companion to fetch.
     */
    where?: CompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companions to fetch.
     */
    orderBy?: CompanionOrderByWithRelationInput | CompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companions.
     */
    cursor?: CompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companions.
     */
    distinct?: CompanionScalarFieldEnum | CompanionScalarFieldEnum[]
  }

  /**
   * Companion findFirstOrThrow
   */
  export type CompanionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanionInclude<ExtArgs> | null
    /**
     * Filter, which Companion to fetch.
     */
    where?: CompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companions to fetch.
     */
    orderBy?: CompanionOrderByWithRelationInput | CompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companions.
     */
    cursor?: CompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companions.
     */
    distinct?: CompanionScalarFieldEnum | CompanionScalarFieldEnum[]
  }

  /**
   * Companion findMany
   */
  export type CompanionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanionInclude<ExtArgs> | null
    /**
     * Filter, which Companions to fetch.
     */
    where?: CompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companions to fetch.
     */
    orderBy?: CompanionOrderByWithRelationInput | CompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companions.
     */
    cursor?: CompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companions.
     */
    skip?: number
    distinct?: CompanionScalarFieldEnum | CompanionScalarFieldEnum[]
  }

  /**
   * Companion create
   */
  export type CompanionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanionInclude<ExtArgs> | null
    /**
     * The data needed to create a Companion.
     */
    data: XOR<CompanionCreateInput, CompanionUncheckedCreateInput>
  }

  /**
   * Companion createMany
   */
  export type CompanionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companions.
     */
    data: CompanionCreateManyInput | CompanionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Companion createManyAndReturn
   */
  export type CompanionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companions.
     */
    data: CompanionCreateManyInput | CompanionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Companion update
   */
  export type CompanionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanionInclude<ExtArgs> | null
    /**
     * The data needed to update a Companion.
     */
    data: XOR<CompanionUpdateInput, CompanionUncheckedUpdateInput>
    /**
     * Choose, which Companion to update.
     */
    where: CompanionWhereUniqueInput
  }

  /**
   * Companion updateMany
   */
  export type CompanionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companions.
     */
    data: XOR<CompanionUpdateManyMutationInput, CompanionUncheckedUpdateManyInput>
    /**
     * Filter which Companions to update
     */
    where?: CompanionWhereInput
  }

  /**
   * Companion upsert
   */
  export type CompanionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanionInclude<ExtArgs> | null
    /**
     * The filter to search for the Companion to update in case it exists.
     */
    where: CompanionWhereUniqueInput
    /**
     * In case the Companion found by the `where` argument doesn't exist, create a new Companion with this data.
     */
    create: XOR<CompanionCreateInput, CompanionUncheckedCreateInput>
    /**
     * In case the Companion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanionUpdateInput, CompanionUncheckedUpdateInput>
  }

  /**
   * Companion delete
   */
  export type CompanionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanionInclude<ExtArgs> | null
    /**
     * Filter which Companion to delete.
     */
    where: CompanionWhereUniqueInput
  }

  /**
   * Companion deleteMany
   */
  export type CompanionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companions to delete
     */
    where?: CompanionWhereInput
  }

  /**
   * Companion.playerCompanions
   */
  export type Companion$playerCompanionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    where?: PlayerCompanionWhereInput
    orderBy?: PlayerCompanionOrderByWithRelationInput | PlayerCompanionOrderByWithRelationInput[]
    cursor?: PlayerCompanionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerCompanionScalarFieldEnum | PlayerCompanionScalarFieldEnum[]
  }

  /**
   * Companion without action
   */
  export type CompanionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companion
     */
    select?: CompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanionInclude<ExtArgs> | null
  }


  /**
   * Model PlayerCompanion
   */

  export type AggregatePlayerCompanion = {
    _count: PlayerCompanionCountAggregateOutputType | null
    _avg: PlayerCompanionAvgAggregateOutputType | null
    _sum: PlayerCompanionSumAggregateOutputType | null
    _min: PlayerCompanionMinAggregateOutputType | null
    _max: PlayerCompanionMaxAggregateOutputType | null
  }

  export type PlayerCompanionAvgAggregateOutputType = {
    level: number | null
    power: number | null
  }

  export type PlayerCompanionSumAggregateOutputType = {
    level: number | null
    power: number | null
  }

  export type PlayerCompanionMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    companionId: string | null
    level: number | null
    power: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCompanionMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    companionId: string | null
    level: number | null
    power: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCompanionCountAggregateOutputType = {
    id: number
    playerId: number
    companionId: number
    level: number
    power: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerCompanionAvgAggregateInputType = {
    level?: true
    power?: true
  }

  export type PlayerCompanionSumAggregateInputType = {
    level?: true
    power?: true
  }

  export type PlayerCompanionMinAggregateInputType = {
    id?: true
    playerId?: true
    companionId?: true
    level?: true
    power?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCompanionMaxAggregateInputType = {
    id?: true
    playerId?: true
    companionId?: true
    level?: true
    power?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCompanionCountAggregateInputType = {
    id?: true
    playerId?: true
    companionId?: true
    level?: true
    power?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerCompanionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerCompanion to aggregate.
     */
    where?: PlayerCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCompanions to fetch.
     */
    orderBy?: PlayerCompanionOrderByWithRelationInput | PlayerCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCompanions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerCompanions
    **/
    _count?: true | PlayerCompanionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerCompanionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerCompanionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerCompanionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerCompanionMaxAggregateInputType
  }

  export type GetPlayerCompanionAggregateType<T extends PlayerCompanionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerCompanion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerCompanion[P]>
      : GetScalarType<T[P], AggregatePlayerCompanion[P]>
  }




  export type PlayerCompanionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerCompanionWhereInput
    orderBy?: PlayerCompanionOrderByWithAggregationInput | PlayerCompanionOrderByWithAggregationInput[]
    by: PlayerCompanionScalarFieldEnum[] | PlayerCompanionScalarFieldEnum
    having?: PlayerCompanionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCompanionCountAggregateInputType | true
    _avg?: PlayerCompanionAvgAggregateInputType
    _sum?: PlayerCompanionSumAggregateInputType
    _min?: PlayerCompanionMinAggregateInputType
    _max?: PlayerCompanionMaxAggregateInputType
  }

  export type PlayerCompanionGroupByOutputType = {
    id: string
    playerId: string
    companionId: string
    level: number
    power: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlayerCompanionCountAggregateOutputType | null
    _avg: PlayerCompanionAvgAggregateOutputType | null
    _sum: PlayerCompanionSumAggregateOutputType | null
    _min: PlayerCompanionMinAggregateOutputType | null
    _max: PlayerCompanionMaxAggregateOutputType | null
  }

  type GetPlayerCompanionGroupByPayload<T extends PlayerCompanionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerCompanionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerCompanionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerCompanionGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerCompanionGroupByOutputType[P]>
        }
      >
    >


  export type PlayerCompanionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    companionId?: boolean
    level?: boolean
    power?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    companion?: boolean | CompanionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerCompanion"]>

  export type PlayerCompanionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    companionId?: boolean
    level?: boolean
    power?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    companion?: boolean | CompanionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerCompanion"]>

  export type PlayerCompanionSelectScalar = {
    id?: boolean
    playerId?: boolean
    companionId?: boolean
    level?: boolean
    power?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerCompanionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    companion?: boolean | CompanionDefaultArgs<ExtArgs>
  }
  export type PlayerCompanionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    companion?: boolean | CompanionDefaultArgs<ExtArgs>
  }

  export type $PlayerCompanionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerCompanion"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      companion: Prisma.$CompanionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      companionId: string
      level: number
      power: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerCompanion"]>
    composites: {}
  }

  type PlayerCompanionGetPayload<S extends boolean | null | undefined | PlayerCompanionDefaultArgs> = $Result.GetResult<Prisma.$PlayerCompanionPayload, S>

  type PlayerCompanionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerCompanionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerCompanionCountAggregateInputType | true
    }

  export interface PlayerCompanionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerCompanion'], meta: { name: 'PlayerCompanion' } }
    /**
     * Find zero or one PlayerCompanion that matches the filter.
     * @param {PlayerCompanionFindUniqueArgs} args - Arguments to find a PlayerCompanion
     * @example
     * // Get one PlayerCompanion
     * const playerCompanion = await prisma.playerCompanion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerCompanionFindUniqueArgs>(args: SelectSubset<T, PlayerCompanionFindUniqueArgs<ExtArgs>>): Prisma__PlayerCompanionClient<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerCompanion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerCompanionFindUniqueOrThrowArgs} args - Arguments to find a PlayerCompanion
     * @example
     * // Get one PlayerCompanion
     * const playerCompanion = await prisma.playerCompanion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerCompanionFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerCompanionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerCompanionClient<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerCompanion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCompanionFindFirstArgs} args - Arguments to find a PlayerCompanion
     * @example
     * // Get one PlayerCompanion
     * const playerCompanion = await prisma.playerCompanion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerCompanionFindFirstArgs>(args?: SelectSubset<T, PlayerCompanionFindFirstArgs<ExtArgs>>): Prisma__PlayerCompanionClient<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerCompanion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCompanionFindFirstOrThrowArgs} args - Arguments to find a PlayerCompanion
     * @example
     * // Get one PlayerCompanion
     * const playerCompanion = await prisma.playerCompanion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerCompanionFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerCompanionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerCompanionClient<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerCompanions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCompanionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerCompanions
     * const playerCompanions = await prisma.playerCompanion.findMany()
     * 
     * // Get first 10 PlayerCompanions
     * const playerCompanions = await prisma.playerCompanion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerCompanionWithIdOnly = await prisma.playerCompanion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerCompanionFindManyArgs>(args?: SelectSubset<T, PlayerCompanionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerCompanion.
     * @param {PlayerCompanionCreateArgs} args - Arguments to create a PlayerCompanion.
     * @example
     * // Create one PlayerCompanion
     * const PlayerCompanion = await prisma.playerCompanion.create({
     *   data: {
     *     // ... data to create a PlayerCompanion
     *   }
     * })
     * 
     */
    create<T extends PlayerCompanionCreateArgs>(args: SelectSubset<T, PlayerCompanionCreateArgs<ExtArgs>>): Prisma__PlayerCompanionClient<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerCompanions.
     * @param {PlayerCompanionCreateManyArgs} args - Arguments to create many PlayerCompanions.
     * @example
     * // Create many PlayerCompanions
     * const playerCompanion = await prisma.playerCompanion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCompanionCreateManyArgs>(args?: SelectSubset<T, PlayerCompanionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerCompanions and returns the data saved in the database.
     * @param {PlayerCompanionCreateManyAndReturnArgs} args - Arguments to create many PlayerCompanions.
     * @example
     * // Create many PlayerCompanions
     * const playerCompanion = await prisma.playerCompanion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerCompanions and only return the `id`
     * const playerCompanionWithIdOnly = await prisma.playerCompanion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCompanionCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCompanionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerCompanion.
     * @param {PlayerCompanionDeleteArgs} args - Arguments to delete one PlayerCompanion.
     * @example
     * // Delete one PlayerCompanion
     * const PlayerCompanion = await prisma.playerCompanion.delete({
     *   where: {
     *     // ... filter to delete one PlayerCompanion
     *   }
     * })
     * 
     */
    delete<T extends PlayerCompanionDeleteArgs>(args: SelectSubset<T, PlayerCompanionDeleteArgs<ExtArgs>>): Prisma__PlayerCompanionClient<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerCompanion.
     * @param {PlayerCompanionUpdateArgs} args - Arguments to update one PlayerCompanion.
     * @example
     * // Update one PlayerCompanion
     * const playerCompanion = await prisma.playerCompanion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerCompanionUpdateArgs>(args: SelectSubset<T, PlayerCompanionUpdateArgs<ExtArgs>>): Prisma__PlayerCompanionClient<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerCompanions.
     * @param {PlayerCompanionDeleteManyArgs} args - Arguments to filter PlayerCompanions to delete.
     * @example
     * // Delete a few PlayerCompanions
     * const { count } = await prisma.playerCompanion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerCompanionDeleteManyArgs>(args?: SelectSubset<T, PlayerCompanionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerCompanions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCompanionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerCompanions
     * const playerCompanion = await prisma.playerCompanion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerCompanionUpdateManyArgs>(args: SelectSubset<T, PlayerCompanionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerCompanion.
     * @param {PlayerCompanionUpsertArgs} args - Arguments to update or create a PlayerCompanion.
     * @example
     * // Update or create a PlayerCompanion
     * const playerCompanion = await prisma.playerCompanion.upsert({
     *   create: {
     *     // ... data to create a PlayerCompanion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerCompanion we want to update
     *   }
     * })
     */
    upsert<T extends PlayerCompanionUpsertArgs>(args: SelectSubset<T, PlayerCompanionUpsertArgs<ExtArgs>>): Prisma__PlayerCompanionClient<$Result.GetResult<Prisma.$PlayerCompanionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerCompanions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCompanionCountArgs} args - Arguments to filter PlayerCompanions to count.
     * @example
     * // Count the number of PlayerCompanions
     * const count = await prisma.playerCompanion.count({
     *   where: {
     *     // ... the filter for the PlayerCompanions we want to count
     *   }
     * })
    **/
    count<T extends PlayerCompanionCountArgs>(
      args?: Subset<T, PlayerCompanionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCompanionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerCompanion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCompanionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerCompanionAggregateArgs>(args: Subset<T, PlayerCompanionAggregateArgs>): Prisma.PrismaPromise<GetPlayerCompanionAggregateType<T>>

    /**
     * Group by PlayerCompanion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCompanionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerCompanionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerCompanionGroupByArgs['orderBy'] }
        : { orderBy?: PlayerCompanionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerCompanionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerCompanionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerCompanion model
   */
  readonly fields: PlayerCompanionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerCompanion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerCompanionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    companion<T extends CompanionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanionDefaultArgs<ExtArgs>>): Prisma__CompanionClient<$Result.GetResult<Prisma.$CompanionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerCompanion model
   */ 
  interface PlayerCompanionFieldRefs {
    readonly id: FieldRef<"PlayerCompanion", 'String'>
    readonly playerId: FieldRef<"PlayerCompanion", 'String'>
    readonly companionId: FieldRef<"PlayerCompanion", 'String'>
    readonly level: FieldRef<"PlayerCompanion", 'Int'>
    readonly power: FieldRef<"PlayerCompanion", 'Int'>
    readonly isActive: FieldRef<"PlayerCompanion", 'Boolean'>
    readonly createdAt: FieldRef<"PlayerCompanion", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerCompanion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerCompanion findUnique
   */
  export type PlayerCompanionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCompanion to fetch.
     */
    where: PlayerCompanionWhereUniqueInput
  }

  /**
   * PlayerCompanion findUniqueOrThrow
   */
  export type PlayerCompanionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCompanion to fetch.
     */
    where: PlayerCompanionWhereUniqueInput
  }

  /**
   * PlayerCompanion findFirst
   */
  export type PlayerCompanionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCompanion to fetch.
     */
    where?: PlayerCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCompanions to fetch.
     */
    orderBy?: PlayerCompanionOrderByWithRelationInput | PlayerCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerCompanions.
     */
    cursor?: PlayerCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCompanions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerCompanions.
     */
    distinct?: PlayerCompanionScalarFieldEnum | PlayerCompanionScalarFieldEnum[]
  }

  /**
   * PlayerCompanion findFirstOrThrow
   */
  export type PlayerCompanionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCompanion to fetch.
     */
    where?: PlayerCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCompanions to fetch.
     */
    orderBy?: PlayerCompanionOrderByWithRelationInput | PlayerCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerCompanions.
     */
    cursor?: PlayerCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCompanions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerCompanions.
     */
    distinct?: PlayerCompanionScalarFieldEnum | PlayerCompanionScalarFieldEnum[]
  }

  /**
   * PlayerCompanion findMany
   */
  export type PlayerCompanionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCompanions to fetch.
     */
    where?: PlayerCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCompanions to fetch.
     */
    orderBy?: PlayerCompanionOrderByWithRelationInput | PlayerCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerCompanions.
     */
    cursor?: PlayerCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCompanions.
     */
    skip?: number
    distinct?: PlayerCompanionScalarFieldEnum | PlayerCompanionScalarFieldEnum[]
  }

  /**
   * PlayerCompanion create
   */
  export type PlayerCompanionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerCompanion.
     */
    data: XOR<PlayerCompanionCreateInput, PlayerCompanionUncheckedCreateInput>
  }

  /**
   * PlayerCompanion createMany
   */
  export type PlayerCompanionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerCompanions.
     */
    data: PlayerCompanionCreateManyInput | PlayerCompanionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerCompanion createManyAndReturn
   */
  export type PlayerCompanionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerCompanions.
     */
    data: PlayerCompanionCreateManyInput | PlayerCompanionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerCompanion update
   */
  export type PlayerCompanionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerCompanion.
     */
    data: XOR<PlayerCompanionUpdateInput, PlayerCompanionUncheckedUpdateInput>
    /**
     * Choose, which PlayerCompanion to update.
     */
    where: PlayerCompanionWhereUniqueInput
  }

  /**
   * PlayerCompanion updateMany
   */
  export type PlayerCompanionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerCompanions.
     */
    data: XOR<PlayerCompanionUpdateManyMutationInput, PlayerCompanionUncheckedUpdateManyInput>
    /**
     * Filter which PlayerCompanions to update
     */
    where?: PlayerCompanionWhereInput
  }

  /**
   * PlayerCompanion upsert
   */
  export type PlayerCompanionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerCompanion to update in case it exists.
     */
    where: PlayerCompanionWhereUniqueInput
    /**
     * In case the PlayerCompanion found by the `where` argument doesn't exist, create a new PlayerCompanion with this data.
     */
    create: XOR<PlayerCompanionCreateInput, PlayerCompanionUncheckedCreateInput>
    /**
     * In case the PlayerCompanion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerCompanionUpdateInput, PlayerCompanionUncheckedUpdateInput>
  }

  /**
   * PlayerCompanion delete
   */
  export type PlayerCompanionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
    /**
     * Filter which PlayerCompanion to delete.
     */
    where: PlayerCompanionWhereUniqueInput
  }

  /**
   * PlayerCompanion deleteMany
   */
  export type PlayerCompanionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerCompanions to delete
     */
    where?: PlayerCompanionWhereInput
  }

  /**
   * PlayerCompanion without action
   */
  export type PlayerCompanionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCompanion
     */
    select?: PlayerCompanionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCompanionInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    points: number | null
  }

  export type AchievementSumAggregateOutputType = {
    points: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    icon: string | null
    category: string | null
    points: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    icon: string | null
    category: string | null
    points: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    icon: number
    category: number
    points: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    points?: true
  }

  export type AchievementSumAggregateInputType = {
    points?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    category?: true
    points?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    category?: true
    points?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    category?: true
    points?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    icon: string | null
    category: string
    points: number
    createdAt: Date
    updatedAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playerAchievements?: boolean | Achievement$playerAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerAchievements?: boolean | Achievement$playerAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      playerAchievements: Prisma.$PlayerAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      icon: string | null
      category: string
      points: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playerAchievements<T extends Achievement$playerAchievementsArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$playerAchievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */ 
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly displayName: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'String'>
    readonly points: FieldRef<"Achievement", 'Int'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
    readonly updatedAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement.playerAchievements
   */
  export type Achievement$playerAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    where?: PlayerAchievementWhereInput
    orderBy?: PlayerAchievementOrderByWithRelationInput | PlayerAchievementOrderByWithRelationInput[]
    cursor?: PlayerAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerAchievementScalarFieldEnum | PlayerAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model PlayerAchievement
   */

  export type AggregatePlayerAchievement = {
    _count: PlayerAchievementCountAggregateOutputType | null
    _min: PlayerAchievementMinAggregateOutputType | null
    _max: PlayerAchievementMaxAggregateOutputType | null
  }

  export type PlayerAchievementMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    achievementId: string | null
    unlockedAt: Date | null
  }

  export type PlayerAchievementMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    achievementId: string | null
    unlockedAt: Date | null
  }

  export type PlayerAchievementCountAggregateOutputType = {
    id: number
    playerId: number
    achievementId: number
    unlockedAt: number
    _all: number
  }


  export type PlayerAchievementMinAggregateInputType = {
    id?: true
    playerId?: true
    achievementId?: true
    unlockedAt?: true
  }

  export type PlayerAchievementMaxAggregateInputType = {
    id?: true
    playerId?: true
    achievementId?: true
    unlockedAt?: true
  }

  export type PlayerAchievementCountAggregateInputType = {
    id?: true
    playerId?: true
    achievementId?: true
    unlockedAt?: true
    _all?: true
  }

  export type PlayerAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerAchievement to aggregate.
     */
    where?: PlayerAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerAchievements to fetch.
     */
    orderBy?: PlayerAchievementOrderByWithRelationInput | PlayerAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerAchievements
    **/
    _count?: true | PlayerAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerAchievementMaxAggregateInputType
  }

  export type GetPlayerAchievementAggregateType<T extends PlayerAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerAchievement[P]>
      : GetScalarType<T[P], AggregatePlayerAchievement[P]>
  }




  export type PlayerAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerAchievementWhereInput
    orderBy?: PlayerAchievementOrderByWithAggregationInput | PlayerAchievementOrderByWithAggregationInput[]
    by: PlayerAchievementScalarFieldEnum[] | PlayerAchievementScalarFieldEnum
    having?: PlayerAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerAchievementCountAggregateInputType | true
    _min?: PlayerAchievementMinAggregateInputType
    _max?: PlayerAchievementMaxAggregateInputType
  }

  export type PlayerAchievementGroupByOutputType = {
    id: string
    playerId: string
    achievementId: string
    unlockedAt: Date
    _count: PlayerAchievementCountAggregateOutputType | null
    _min: PlayerAchievementMinAggregateOutputType | null
    _max: PlayerAchievementMaxAggregateOutputType | null
  }

  type GetPlayerAchievementGroupByPayload<T extends PlayerAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerAchievementGroupByOutputType[P]>
        }
      >
    >


  export type PlayerAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerAchievement"]>

  export type PlayerAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerAchievement"]>

  export type PlayerAchievementSelectScalar = {
    id?: boolean
    playerId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
  }

  export type PlayerAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type PlayerAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $PlayerAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerAchievement"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      achievementId: string
      unlockedAt: Date
    }, ExtArgs["result"]["playerAchievement"]>
    composites: {}
  }

  type PlayerAchievementGetPayload<S extends boolean | null | undefined | PlayerAchievementDefaultArgs> = $Result.GetResult<Prisma.$PlayerAchievementPayload, S>

  type PlayerAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerAchievementCountAggregateInputType | true
    }

  export interface PlayerAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerAchievement'], meta: { name: 'PlayerAchievement' } }
    /**
     * Find zero or one PlayerAchievement that matches the filter.
     * @param {PlayerAchievementFindUniqueArgs} args - Arguments to find a PlayerAchievement
     * @example
     * // Get one PlayerAchievement
     * const playerAchievement = await prisma.playerAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerAchievementFindUniqueArgs>(args: SelectSubset<T, PlayerAchievementFindUniqueArgs<ExtArgs>>): Prisma__PlayerAchievementClient<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerAchievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerAchievementFindUniqueOrThrowArgs} args - Arguments to find a PlayerAchievement
     * @example
     * // Get one PlayerAchievement
     * const playerAchievement = await prisma.playerAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerAchievementClient<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAchievementFindFirstArgs} args - Arguments to find a PlayerAchievement
     * @example
     * // Get one PlayerAchievement
     * const playerAchievement = await prisma.playerAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerAchievementFindFirstArgs>(args?: SelectSubset<T, PlayerAchievementFindFirstArgs<ExtArgs>>): Prisma__PlayerAchievementClient<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAchievementFindFirstOrThrowArgs} args - Arguments to find a PlayerAchievement
     * @example
     * // Get one PlayerAchievement
     * const playerAchievement = await prisma.playerAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerAchievementClient<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerAchievements
     * const playerAchievements = await prisma.playerAchievement.findMany()
     * 
     * // Get first 10 PlayerAchievements
     * const playerAchievements = await prisma.playerAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerAchievementWithIdOnly = await prisma.playerAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerAchievementFindManyArgs>(args?: SelectSubset<T, PlayerAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerAchievement.
     * @param {PlayerAchievementCreateArgs} args - Arguments to create a PlayerAchievement.
     * @example
     * // Create one PlayerAchievement
     * const PlayerAchievement = await prisma.playerAchievement.create({
     *   data: {
     *     // ... data to create a PlayerAchievement
     *   }
     * })
     * 
     */
    create<T extends PlayerAchievementCreateArgs>(args: SelectSubset<T, PlayerAchievementCreateArgs<ExtArgs>>): Prisma__PlayerAchievementClient<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerAchievements.
     * @param {PlayerAchievementCreateManyArgs} args - Arguments to create many PlayerAchievements.
     * @example
     * // Create many PlayerAchievements
     * const playerAchievement = await prisma.playerAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerAchievementCreateManyArgs>(args?: SelectSubset<T, PlayerAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerAchievements and returns the data saved in the database.
     * @param {PlayerAchievementCreateManyAndReturnArgs} args - Arguments to create many PlayerAchievements.
     * @example
     * // Create many PlayerAchievements
     * const playerAchievement = await prisma.playerAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerAchievements and only return the `id`
     * const playerAchievementWithIdOnly = await prisma.playerAchievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerAchievement.
     * @param {PlayerAchievementDeleteArgs} args - Arguments to delete one PlayerAchievement.
     * @example
     * // Delete one PlayerAchievement
     * const PlayerAchievement = await prisma.playerAchievement.delete({
     *   where: {
     *     // ... filter to delete one PlayerAchievement
     *   }
     * })
     * 
     */
    delete<T extends PlayerAchievementDeleteArgs>(args: SelectSubset<T, PlayerAchievementDeleteArgs<ExtArgs>>): Prisma__PlayerAchievementClient<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerAchievement.
     * @param {PlayerAchievementUpdateArgs} args - Arguments to update one PlayerAchievement.
     * @example
     * // Update one PlayerAchievement
     * const playerAchievement = await prisma.playerAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerAchievementUpdateArgs>(args: SelectSubset<T, PlayerAchievementUpdateArgs<ExtArgs>>): Prisma__PlayerAchievementClient<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerAchievements.
     * @param {PlayerAchievementDeleteManyArgs} args - Arguments to filter PlayerAchievements to delete.
     * @example
     * // Delete a few PlayerAchievements
     * const { count } = await prisma.playerAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerAchievementDeleteManyArgs>(args?: SelectSubset<T, PlayerAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerAchievements
     * const playerAchievement = await prisma.playerAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerAchievementUpdateManyArgs>(args: SelectSubset<T, PlayerAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerAchievement.
     * @param {PlayerAchievementUpsertArgs} args - Arguments to update or create a PlayerAchievement.
     * @example
     * // Update or create a PlayerAchievement
     * const playerAchievement = await prisma.playerAchievement.upsert({
     *   create: {
     *     // ... data to create a PlayerAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerAchievement we want to update
     *   }
     * })
     */
    upsert<T extends PlayerAchievementUpsertArgs>(args: SelectSubset<T, PlayerAchievementUpsertArgs<ExtArgs>>): Prisma__PlayerAchievementClient<$Result.GetResult<Prisma.$PlayerAchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAchievementCountArgs} args - Arguments to filter PlayerAchievements to count.
     * @example
     * // Count the number of PlayerAchievements
     * const count = await prisma.playerAchievement.count({
     *   where: {
     *     // ... the filter for the PlayerAchievements we want to count
     *   }
     * })
    **/
    count<T extends PlayerAchievementCountArgs>(
      args?: Subset<T, PlayerAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAchievementAggregateArgs>(args: Subset<T, PlayerAchievementAggregateArgs>): Prisma.PrismaPromise<GetPlayerAchievementAggregateType<T>>

    /**
     * Group by PlayerAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerAchievementGroupByArgs['orderBy'] }
        : { orderBy?: PlayerAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerAchievement model
   */
  readonly fields: PlayerAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerAchievement model
   */ 
  interface PlayerAchievementFieldRefs {
    readonly id: FieldRef<"PlayerAchievement", 'String'>
    readonly playerId: FieldRef<"PlayerAchievement", 'String'>
    readonly achievementId: FieldRef<"PlayerAchievement", 'String'>
    readonly unlockedAt: FieldRef<"PlayerAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerAchievement findUnique
   */
  export type PlayerAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    /**
     * Filter, which PlayerAchievement to fetch.
     */
    where: PlayerAchievementWhereUniqueInput
  }

  /**
   * PlayerAchievement findUniqueOrThrow
   */
  export type PlayerAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    /**
     * Filter, which PlayerAchievement to fetch.
     */
    where: PlayerAchievementWhereUniqueInput
  }

  /**
   * PlayerAchievement findFirst
   */
  export type PlayerAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    /**
     * Filter, which PlayerAchievement to fetch.
     */
    where?: PlayerAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerAchievements to fetch.
     */
    orderBy?: PlayerAchievementOrderByWithRelationInput | PlayerAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerAchievements.
     */
    cursor?: PlayerAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerAchievements.
     */
    distinct?: PlayerAchievementScalarFieldEnum | PlayerAchievementScalarFieldEnum[]
  }

  /**
   * PlayerAchievement findFirstOrThrow
   */
  export type PlayerAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    /**
     * Filter, which PlayerAchievement to fetch.
     */
    where?: PlayerAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerAchievements to fetch.
     */
    orderBy?: PlayerAchievementOrderByWithRelationInput | PlayerAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerAchievements.
     */
    cursor?: PlayerAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerAchievements.
     */
    distinct?: PlayerAchievementScalarFieldEnum | PlayerAchievementScalarFieldEnum[]
  }

  /**
   * PlayerAchievement findMany
   */
  export type PlayerAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    /**
     * Filter, which PlayerAchievements to fetch.
     */
    where?: PlayerAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerAchievements to fetch.
     */
    orderBy?: PlayerAchievementOrderByWithRelationInput | PlayerAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerAchievements.
     */
    cursor?: PlayerAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerAchievements.
     */
    skip?: number
    distinct?: PlayerAchievementScalarFieldEnum | PlayerAchievementScalarFieldEnum[]
  }

  /**
   * PlayerAchievement create
   */
  export type PlayerAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerAchievement.
     */
    data: XOR<PlayerAchievementCreateInput, PlayerAchievementUncheckedCreateInput>
  }

  /**
   * PlayerAchievement createMany
   */
  export type PlayerAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerAchievements.
     */
    data: PlayerAchievementCreateManyInput | PlayerAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerAchievement createManyAndReturn
   */
  export type PlayerAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerAchievements.
     */
    data: PlayerAchievementCreateManyInput | PlayerAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerAchievement update
   */
  export type PlayerAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerAchievement.
     */
    data: XOR<PlayerAchievementUpdateInput, PlayerAchievementUncheckedUpdateInput>
    /**
     * Choose, which PlayerAchievement to update.
     */
    where: PlayerAchievementWhereUniqueInput
  }

  /**
   * PlayerAchievement updateMany
   */
  export type PlayerAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerAchievements.
     */
    data: XOR<PlayerAchievementUpdateManyMutationInput, PlayerAchievementUncheckedUpdateManyInput>
    /**
     * Filter which PlayerAchievements to update
     */
    where?: PlayerAchievementWhereInput
  }

  /**
   * PlayerAchievement upsert
   */
  export type PlayerAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerAchievement to update in case it exists.
     */
    where: PlayerAchievementWhereUniqueInput
    /**
     * In case the PlayerAchievement found by the `where` argument doesn't exist, create a new PlayerAchievement with this data.
     */
    create: XOR<PlayerAchievementCreateInput, PlayerAchievementUncheckedCreateInput>
    /**
     * In case the PlayerAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerAchievementUpdateInput, PlayerAchievementUncheckedUpdateInput>
  }

  /**
   * PlayerAchievement delete
   */
  export type PlayerAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
    /**
     * Filter which PlayerAchievement to delete.
     */
    where: PlayerAchievementWhereUniqueInput
  }

  /**
   * PlayerAchievement deleteMany
   */
  export type PlayerAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerAchievements to delete
     */
    where?: PlayerAchievementWhereInput
  }

  /**
   * PlayerAchievement without action
   */
  export type PlayerAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerAchievement
     */
    select?: PlayerAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Quest
   */

  export type AggregateQuest = {
    _count: QuestCountAggregateOutputType | null
    _avg: QuestAvgAggregateOutputType | null
    _sum: QuestSumAggregateOutputType | null
    _min: QuestMinAggregateOutputType | null
    _max: QuestMaxAggregateOutputType | null
  }

  export type QuestAvgAggregateOutputType = {
    repeatInterval: number | null
  }

  export type QuestSumAggregateOutputType = {
    repeatInterval: number | null
  }

  export type QuestMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    difficulty: string | null
    rewards: string | null
    requirements: string | null
    isActive: boolean | null
    isRepeatable: boolean | null
    repeatInterval: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    difficulty: string | null
    rewards: string | null
    requirements: string | null
    isActive: boolean | null
    isRepeatable: boolean | null
    repeatInterval: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    category: number
    difficulty: number
    rewards: number
    requirements: number
    isActive: number
    isRepeatable: number
    repeatInterval: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestAvgAggregateInputType = {
    repeatInterval?: true
  }

  export type QuestSumAggregateInputType = {
    repeatInterval?: true
  }

  export type QuestMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    difficulty?: true
    rewards?: true
    requirements?: true
    isActive?: true
    isRepeatable?: true
    repeatInterval?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    difficulty?: true
    rewards?: true
    requirements?: true
    isActive?: true
    isRepeatable?: true
    repeatInterval?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    difficulty?: true
    rewards?: true
    requirements?: true
    isActive?: true
    isRepeatable?: true
    repeatInterval?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quest to aggregate.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quests
    **/
    _count?: true | QuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestMaxAggregateInputType
  }

  export type GetQuestAggregateType<T extends QuestAggregateArgs> = {
        [P in keyof T & keyof AggregateQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuest[P]>
      : GetScalarType<T[P], AggregateQuest[P]>
  }




  export type QuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithAggregationInput | QuestOrderByWithAggregationInput[]
    by: QuestScalarFieldEnum[] | QuestScalarFieldEnum
    having?: QuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestCountAggregateInputType | true
    _avg?: QuestAvgAggregateInputType
    _sum?: QuestSumAggregateInputType
    _min?: QuestMinAggregateInputType
    _max?: QuestMaxAggregateInputType
  }

  export type QuestGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    category: string
    difficulty: string
    rewards: string | null
    requirements: string | null
    isActive: boolean
    isRepeatable: boolean
    repeatInterval: number | null
    createdAt: Date
    updatedAt: Date
    _count: QuestCountAggregateOutputType | null
    _avg: QuestAvgAggregateOutputType | null
    _sum: QuestSumAggregateOutputType | null
    _min: QuestMinAggregateOutputType | null
    _max: QuestMaxAggregateOutputType | null
  }

  type GetQuestGroupByPayload<T extends QuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestGroupByOutputType[P]>
            : GetScalarType<T[P], QuestGroupByOutputType[P]>
        }
      >
    >


  export type QuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    rewards?: boolean
    requirements?: boolean
    isActive?: boolean
    isRepeatable?: boolean
    repeatInterval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playerQuests?: boolean | Quest$playerQuestsArgs<ExtArgs>
    _count?: boolean | QuestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    rewards?: boolean
    requirements?: boolean
    isActive?: boolean
    isRepeatable?: boolean
    repeatInterval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    rewards?: boolean
    requirements?: boolean
    isActive?: boolean
    isRepeatable?: boolean
    repeatInterval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerQuests?: boolean | Quest$playerQuestsArgs<ExtArgs>
    _count?: boolean | QuestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quest"
    objects: {
      playerQuests: Prisma.$PlayerQuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      category: string
      difficulty: string
      rewards: string | null
      requirements: string | null
      isActive: boolean
      isRepeatable: boolean
      repeatInterval: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quest"]>
    composites: {}
  }

  type QuestGetPayload<S extends boolean | null | undefined | QuestDefaultArgs> = $Result.GetResult<Prisma.$QuestPayload, S>

  type QuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestCountAggregateInputType | true
    }

  export interface QuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quest'], meta: { name: 'Quest' } }
    /**
     * Find zero or one Quest that matches the filter.
     * @param {QuestFindUniqueArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestFindUniqueArgs>(args: SelectSubset<T, QuestFindUniqueArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestFindUniqueOrThrowArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindFirstArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestFindFirstArgs>(args?: SelectSubset<T, QuestFindFirstArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindFirstOrThrowArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quests
     * const quests = await prisma.quest.findMany()
     * 
     * // Get first 10 Quests
     * const quests = await prisma.quest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questWithIdOnly = await prisma.quest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestFindManyArgs>(args?: SelectSubset<T, QuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quest.
     * @param {QuestCreateArgs} args - Arguments to create a Quest.
     * @example
     * // Create one Quest
     * const Quest = await prisma.quest.create({
     *   data: {
     *     // ... data to create a Quest
     *   }
     * })
     * 
     */
    create<T extends QuestCreateArgs>(args: SelectSubset<T, QuestCreateArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quests.
     * @param {QuestCreateManyArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quest = await prisma.quest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestCreateManyArgs>(args?: SelectSubset<T, QuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quests and returns the data saved in the database.
     * @param {QuestCreateManyAndReturnArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quest = await prisma.quest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quests and only return the `id`
     * const questWithIdOnly = await prisma.quest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Quest.
     * @param {QuestDeleteArgs} args - Arguments to delete one Quest.
     * @example
     * // Delete one Quest
     * const Quest = await prisma.quest.delete({
     *   where: {
     *     // ... filter to delete one Quest
     *   }
     * })
     * 
     */
    delete<T extends QuestDeleteArgs>(args: SelectSubset<T, QuestDeleteArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quest.
     * @param {QuestUpdateArgs} args - Arguments to update one Quest.
     * @example
     * // Update one Quest
     * const quest = await prisma.quest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestUpdateArgs>(args: SelectSubset<T, QuestUpdateArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quests.
     * @param {QuestDeleteManyArgs} args - Arguments to filter Quests to delete.
     * @example
     * // Delete a few Quests
     * const { count } = await prisma.quest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestDeleteManyArgs>(args?: SelectSubset<T, QuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quests
     * const quest = await prisma.quest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestUpdateManyArgs>(args: SelectSubset<T, QuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quest.
     * @param {QuestUpsertArgs} args - Arguments to update or create a Quest.
     * @example
     * // Update or create a Quest
     * const quest = await prisma.quest.upsert({
     *   create: {
     *     // ... data to create a Quest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quest we want to update
     *   }
     * })
     */
    upsert<T extends QuestUpsertArgs>(args: SelectSubset<T, QuestUpsertArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestCountArgs} args - Arguments to filter Quests to count.
     * @example
     * // Count the number of Quests
     * const count = await prisma.quest.count({
     *   where: {
     *     // ... the filter for the Quests we want to count
     *   }
     * })
    **/
    count<T extends QuestCountArgs>(
      args?: Subset<T, QuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestAggregateArgs>(args: Subset<T, QuestAggregateArgs>): Prisma.PrismaPromise<GetQuestAggregateType<T>>

    /**
     * Group by Quest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestGroupByArgs['orderBy'] }
        : { orderBy?: QuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quest model
   */
  readonly fields: QuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playerQuests<T extends Quest$playerQuestsArgs<ExtArgs> = {}>(args?: Subset<T, Quest$playerQuestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quest model
   */ 
  interface QuestFieldRefs {
    readonly id: FieldRef<"Quest", 'String'>
    readonly name: FieldRef<"Quest", 'String'>
    readonly displayName: FieldRef<"Quest", 'String'>
    readonly description: FieldRef<"Quest", 'String'>
    readonly category: FieldRef<"Quest", 'String'>
    readonly difficulty: FieldRef<"Quest", 'String'>
    readonly rewards: FieldRef<"Quest", 'String'>
    readonly requirements: FieldRef<"Quest", 'String'>
    readonly isActive: FieldRef<"Quest", 'Boolean'>
    readonly isRepeatable: FieldRef<"Quest", 'Boolean'>
    readonly repeatInterval: FieldRef<"Quest", 'Int'>
    readonly createdAt: FieldRef<"Quest", 'DateTime'>
    readonly updatedAt: FieldRef<"Quest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quest findUnique
   */
  export type QuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest findUniqueOrThrow
   */
  export type QuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest findFirst
   */
  export type QuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest findFirstOrThrow
   */
  export type QuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest findMany
   */
  export type QuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest create
   */
  export type QuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The data needed to create a Quest.
     */
    data: XOR<QuestCreateInput, QuestUncheckedCreateInput>
  }

  /**
   * Quest createMany
   */
  export type QuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quests.
     */
    data: QuestCreateManyInput | QuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quest createManyAndReturn
   */
  export type QuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Quests.
     */
    data: QuestCreateManyInput | QuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quest update
   */
  export type QuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The data needed to update a Quest.
     */
    data: XOR<QuestUpdateInput, QuestUncheckedUpdateInput>
    /**
     * Choose, which Quest to update.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest updateMany
   */
  export type QuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quests.
     */
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyInput>
    /**
     * Filter which Quests to update
     */
    where?: QuestWhereInput
  }

  /**
   * Quest upsert
   */
  export type QuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The filter to search for the Quest to update in case it exists.
     */
    where: QuestWhereUniqueInput
    /**
     * In case the Quest found by the `where` argument doesn't exist, create a new Quest with this data.
     */
    create: XOR<QuestCreateInput, QuestUncheckedCreateInput>
    /**
     * In case the Quest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestUpdateInput, QuestUncheckedUpdateInput>
  }

  /**
   * Quest delete
   */
  export type QuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter which Quest to delete.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest deleteMany
   */
  export type QuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quests to delete
     */
    where?: QuestWhereInput
  }

  /**
   * Quest.playerQuests
   */
  export type Quest$playerQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    where?: PlayerQuestWhereInput
    orderBy?: PlayerQuestOrderByWithRelationInput | PlayerQuestOrderByWithRelationInput[]
    cursor?: PlayerQuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerQuestScalarFieldEnum | PlayerQuestScalarFieldEnum[]
  }

  /**
   * Quest without action
   */
  export type QuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
  }


  /**
   * Model PlayerQuest
   */

  export type AggregatePlayerQuest = {
    _count: PlayerQuestCountAggregateOutputType | null
    _min: PlayerQuestMinAggregateOutputType | null
    _max: PlayerQuestMaxAggregateOutputType | null
  }

  export type PlayerQuestMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    questId: string | null
    status: string | null
    progress: string | null
    startedAt: Date | null
    completedAt: Date | null
    lastCompletedAt: Date | null
    cooldownUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerQuestMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    questId: string | null
    status: string | null
    progress: string | null
    startedAt: Date | null
    completedAt: Date | null
    lastCompletedAt: Date | null
    cooldownUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerQuestCountAggregateOutputType = {
    id: number
    playerId: number
    questId: number
    status: number
    progress: number
    startedAt: number
    completedAt: number
    lastCompletedAt: number
    cooldownUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerQuestMinAggregateInputType = {
    id?: true
    playerId?: true
    questId?: true
    status?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    lastCompletedAt?: true
    cooldownUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerQuestMaxAggregateInputType = {
    id?: true
    playerId?: true
    questId?: true
    status?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    lastCompletedAt?: true
    cooldownUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerQuestCountAggregateInputType = {
    id?: true
    playerId?: true
    questId?: true
    status?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    lastCompletedAt?: true
    cooldownUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerQuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerQuest to aggregate.
     */
    where?: PlayerQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerQuests to fetch.
     */
    orderBy?: PlayerQuestOrderByWithRelationInput | PlayerQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerQuests
    **/
    _count?: true | PlayerQuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerQuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerQuestMaxAggregateInputType
  }

  export type GetPlayerQuestAggregateType<T extends PlayerQuestAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerQuest[P]>
      : GetScalarType<T[P], AggregatePlayerQuest[P]>
  }




  export type PlayerQuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerQuestWhereInput
    orderBy?: PlayerQuestOrderByWithAggregationInput | PlayerQuestOrderByWithAggregationInput[]
    by: PlayerQuestScalarFieldEnum[] | PlayerQuestScalarFieldEnum
    having?: PlayerQuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerQuestCountAggregateInputType | true
    _min?: PlayerQuestMinAggregateInputType
    _max?: PlayerQuestMaxAggregateInputType
  }

  export type PlayerQuestGroupByOutputType = {
    id: string
    playerId: string
    questId: string
    status: string
    progress: string | null
    startedAt: Date | null
    completedAt: Date | null
    lastCompletedAt: Date | null
    cooldownUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PlayerQuestCountAggregateOutputType | null
    _min: PlayerQuestMinAggregateOutputType | null
    _max: PlayerQuestMaxAggregateOutputType | null
  }

  type GetPlayerQuestGroupByPayload<T extends PlayerQuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerQuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerQuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerQuestGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerQuestGroupByOutputType[P]>
        }
      >
    >


  export type PlayerQuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    questId?: boolean
    status?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lastCompletedAt?: boolean
    cooldownUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    quest?: boolean | QuestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerQuest"]>

  export type PlayerQuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    questId?: boolean
    status?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lastCompletedAt?: boolean
    cooldownUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    quest?: boolean | QuestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerQuest"]>

  export type PlayerQuestSelectScalar = {
    id?: boolean
    playerId?: boolean
    questId?: boolean
    status?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lastCompletedAt?: boolean
    cooldownUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerQuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    quest?: boolean | QuestDefaultArgs<ExtArgs>
  }
  export type PlayerQuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    quest?: boolean | QuestDefaultArgs<ExtArgs>
  }

  export type $PlayerQuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerQuest"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      quest: Prisma.$QuestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      questId: string
      status: string
      progress: string | null
      startedAt: Date | null
      completedAt: Date | null
      lastCompletedAt: Date | null
      cooldownUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerQuest"]>
    composites: {}
  }

  type PlayerQuestGetPayload<S extends boolean | null | undefined | PlayerQuestDefaultArgs> = $Result.GetResult<Prisma.$PlayerQuestPayload, S>

  type PlayerQuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerQuestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerQuestCountAggregateInputType | true
    }

  export interface PlayerQuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerQuest'], meta: { name: 'PlayerQuest' } }
    /**
     * Find zero or one PlayerQuest that matches the filter.
     * @param {PlayerQuestFindUniqueArgs} args - Arguments to find a PlayerQuest
     * @example
     * // Get one PlayerQuest
     * const playerQuest = await prisma.playerQuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerQuestFindUniqueArgs>(args: SelectSubset<T, PlayerQuestFindUniqueArgs<ExtArgs>>): Prisma__PlayerQuestClient<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerQuest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerQuestFindUniqueOrThrowArgs} args - Arguments to find a PlayerQuest
     * @example
     * // Get one PlayerQuest
     * const playerQuest = await prisma.playerQuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerQuestFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerQuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerQuestClient<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerQuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerQuestFindFirstArgs} args - Arguments to find a PlayerQuest
     * @example
     * // Get one PlayerQuest
     * const playerQuest = await prisma.playerQuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerQuestFindFirstArgs>(args?: SelectSubset<T, PlayerQuestFindFirstArgs<ExtArgs>>): Prisma__PlayerQuestClient<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerQuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerQuestFindFirstOrThrowArgs} args - Arguments to find a PlayerQuest
     * @example
     * // Get one PlayerQuest
     * const playerQuest = await prisma.playerQuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerQuestFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerQuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerQuestClient<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerQuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerQuests
     * const playerQuests = await prisma.playerQuest.findMany()
     * 
     * // Get first 10 PlayerQuests
     * const playerQuests = await prisma.playerQuest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerQuestWithIdOnly = await prisma.playerQuest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerQuestFindManyArgs>(args?: SelectSubset<T, PlayerQuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerQuest.
     * @param {PlayerQuestCreateArgs} args - Arguments to create a PlayerQuest.
     * @example
     * // Create one PlayerQuest
     * const PlayerQuest = await prisma.playerQuest.create({
     *   data: {
     *     // ... data to create a PlayerQuest
     *   }
     * })
     * 
     */
    create<T extends PlayerQuestCreateArgs>(args: SelectSubset<T, PlayerQuestCreateArgs<ExtArgs>>): Prisma__PlayerQuestClient<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerQuests.
     * @param {PlayerQuestCreateManyArgs} args - Arguments to create many PlayerQuests.
     * @example
     * // Create many PlayerQuests
     * const playerQuest = await prisma.playerQuest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerQuestCreateManyArgs>(args?: SelectSubset<T, PlayerQuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerQuests and returns the data saved in the database.
     * @param {PlayerQuestCreateManyAndReturnArgs} args - Arguments to create many PlayerQuests.
     * @example
     * // Create many PlayerQuests
     * const playerQuest = await prisma.playerQuest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerQuests and only return the `id`
     * const playerQuestWithIdOnly = await prisma.playerQuest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerQuestCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerQuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerQuest.
     * @param {PlayerQuestDeleteArgs} args - Arguments to delete one PlayerQuest.
     * @example
     * // Delete one PlayerQuest
     * const PlayerQuest = await prisma.playerQuest.delete({
     *   where: {
     *     // ... filter to delete one PlayerQuest
     *   }
     * })
     * 
     */
    delete<T extends PlayerQuestDeleteArgs>(args: SelectSubset<T, PlayerQuestDeleteArgs<ExtArgs>>): Prisma__PlayerQuestClient<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerQuest.
     * @param {PlayerQuestUpdateArgs} args - Arguments to update one PlayerQuest.
     * @example
     * // Update one PlayerQuest
     * const playerQuest = await prisma.playerQuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerQuestUpdateArgs>(args: SelectSubset<T, PlayerQuestUpdateArgs<ExtArgs>>): Prisma__PlayerQuestClient<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerQuests.
     * @param {PlayerQuestDeleteManyArgs} args - Arguments to filter PlayerQuests to delete.
     * @example
     * // Delete a few PlayerQuests
     * const { count } = await prisma.playerQuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerQuestDeleteManyArgs>(args?: SelectSubset<T, PlayerQuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerQuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerQuests
     * const playerQuest = await prisma.playerQuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerQuestUpdateManyArgs>(args: SelectSubset<T, PlayerQuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerQuest.
     * @param {PlayerQuestUpsertArgs} args - Arguments to update or create a PlayerQuest.
     * @example
     * // Update or create a PlayerQuest
     * const playerQuest = await prisma.playerQuest.upsert({
     *   create: {
     *     // ... data to create a PlayerQuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerQuest we want to update
     *   }
     * })
     */
    upsert<T extends PlayerQuestUpsertArgs>(args: SelectSubset<T, PlayerQuestUpsertArgs<ExtArgs>>): Prisma__PlayerQuestClient<$Result.GetResult<Prisma.$PlayerQuestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerQuestCountArgs} args - Arguments to filter PlayerQuests to count.
     * @example
     * // Count the number of PlayerQuests
     * const count = await prisma.playerQuest.count({
     *   where: {
     *     // ... the filter for the PlayerQuests we want to count
     *   }
     * })
    **/
    count<T extends PlayerQuestCountArgs>(
      args?: Subset<T, PlayerQuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerQuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerQuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerQuestAggregateArgs>(args: Subset<T, PlayerQuestAggregateArgs>): Prisma.PrismaPromise<GetPlayerQuestAggregateType<T>>

    /**
     * Group by PlayerQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerQuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerQuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerQuestGroupByArgs['orderBy'] }
        : { orderBy?: PlayerQuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerQuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerQuest model
   */
  readonly fields: PlayerQuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerQuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerQuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    quest<T extends QuestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestDefaultArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerQuest model
   */ 
  interface PlayerQuestFieldRefs {
    readonly id: FieldRef<"PlayerQuest", 'String'>
    readonly playerId: FieldRef<"PlayerQuest", 'String'>
    readonly questId: FieldRef<"PlayerQuest", 'String'>
    readonly status: FieldRef<"PlayerQuest", 'String'>
    readonly progress: FieldRef<"PlayerQuest", 'String'>
    readonly startedAt: FieldRef<"PlayerQuest", 'DateTime'>
    readonly completedAt: FieldRef<"PlayerQuest", 'DateTime'>
    readonly lastCompletedAt: FieldRef<"PlayerQuest", 'DateTime'>
    readonly cooldownUntil: FieldRef<"PlayerQuest", 'DateTime'>
    readonly createdAt: FieldRef<"PlayerQuest", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerQuest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerQuest findUnique
   */
  export type PlayerQuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    /**
     * Filter, which PlayerQuest to fetch.
     */
    where: PlayerQuestWhereUniqueInput
  }

  /**
   * PlayerQuest findUniqueOrThrow
   */
  export type PlayerQuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    /**
     * Filter, which PlayerQuest to fetch.
     */
    where: PlayerQuestWhereUniqueInput
  }

  /**
   * PlayerQuest findFirst
   */
  export type PlayerQuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    /**
     * Filter, which PlayerQuest to fetch.
     */
    where?: PlayerQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerQuests to fetch.
     */
    orderBy?: PlayerQuestOrderByWithRelationInput | PlayerQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerQuests.
     */
    cursor?: PlayerQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerQuests.
     */
    distinct?: PlayerQuestScalarFieldEnum | PlayerQuestScalarFieldEnum[]
  }

  /**
   * PlayerQuest findFirstOrThrow
   */
  export type PlayerQuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    /**
     * Filter, which PlayerQuest to fetch.
     */
    where?: PlayerQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerQuests to fetch.
     */
    orderBy?: PlayerQuestOrderByWithRelationInput | PlayerQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerQuests.
     */
    cursor?: PlayerQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerQuests.
     */
    distinct?: PlayerQuestScalarFieldEnum | PlayerQuestScalarFieldEnum[]
  }

  /**
   * PlayerQuest findMany
   */
  export type PlayerQuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    /**
     * Filter, which PlayerQuests to fetch.
     */
    where?: PlayerQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerQuests to fetch.
     */
    orderBy?: PlayerQuestOrderByWithRelationInput | PlayerQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerQuests.
     */
    cursor?: PlayerQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerQuests.
     */
    skip?: number
    distinct?: PlayerQuestScalarFieldEnum | PlayerQuestScalarFieldEnum[]
  }

  /**
   * PlayerQuest create
   */
  export type PlayerQuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerQuest.
     */
    data: XOR<PlayerQuestCreateInput, PlayerQuestUncheckedCreateInput>
  }

  /**
   * PlayerQuest createMany
   */
  export type PlayerQuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerQuests.
     */
    data: PlayerQuestCreateManyInput | PlayerQuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerQuest createManyAndReturn
   */
  export type PlayerQuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerQuests.
     */
    data: PlayerQuestCreateManyInput | PlayerQuestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerQuest update
   */
  export type PlayerQuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerQuest.
     */
    data: XOR<PlayerQuestUpdateInput, PlayerQuestUncheckedUpdateInput>
    /**
     * Choose, which PlayerQuest to update.
     */
    where: PlayerQuestWhereUniqueInput
  }

  /**
   * PlayerQuest updateMany
   */
  export type PlayerQuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerQuests.
     */
    data: XOR<PlayerQuestUpdateManyMutationInput, PlayerQuestUncheckedUpdateManyInput>
    /**
     * Filter which PlayerQuests to update
     */
    where?: PlayerQuestWhereInput
  }

  /**
   * PlayerQuest upsert
   */
  export type PlayerQuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerQuest to update in case it exists.
     */
    where: PlayerQuestWhereUniqueInput
    /**
     * In case the PlayerQuest found by the `where` argument doesn't exist, create a new PlayerQuest with this data.
     */
    create: XOR<PlayerQuestCreateInput, PlayerQuestUncheckedCreateInput>
    /**
     * In case the PlayerQuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerQuestUpdateInput, PlayerQuestUncheckedUpdateInput>
  }

  /**
   * PlayerQuest delete
   */
  export type PlayerQuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
    /**
     * Filter which PlayerQuest to delete.
     */
    where: PlayerQuestWhereUniqueInput
  }

  /**
   * PlayerQuest deleteMany
   */
  export type PlayerQuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerQuests to delete
     */
    where?: PlayerQuestWhereInput
  }

  /**
   * PlayerQuest without action
   */
  export type PlayerQuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerQuest
     */
    select?: PlayerQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerQuestInclude<ExtArgs> | null
  }


  /**
   * Model PlayerStats
   */

  export type AggregatePlayerStats = {
    _count: PlayerStatsCountAggregateOutputType | null
    _avg: PlayerStatsAvgAggregateOutputType | null
    _sum: PlayerStatsSumAggregateOutputType | null
    _min: PlayerStatsMinAggregateOutputType | null
    _max: PlayerStatsMaxAggregateOutputType | null
  }

  export type PlayerStatsAvgAggregateOutputType = {
    hp: number | null
    mp: number | null
    attack: number | null
    defense: number | null
    speed: number | null
    luck: number | null
    wisdom: number | null
    strength: number | null
    agility: number | null
    vitality: number | null
    spirit: number | null
  }

  export type PlayerStatsSumAggregateOutputType = {
    hp: number | null
    mp: number | null
    attack: number | null
    defense: number | null
    speed: number | null
    luck: number | null
    wisdom: number | null
    strength: number | null
    agility: number | null
    vitality: number | null
    spirit: number | null
  }

  export type PlayerStatsMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    hp: number | null
    mp: number | null
    attack: number | null
    defense: number | null
    speed: number | null
    luck: number | null
    wisdom: number | null
    strength: number | null
    agility: number | null
    vitality: number | null
    spirit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerStatsMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    hp: number | null
    mp: number | null
    attack: number | null
    defense: number | null
    speed: number | null
    luck: number | null
    wisdom: number | null
    strength: number | null
    agility: number | null
    vitality: number | null
    spirit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerStatsCountAggregateOutputType = {
    id: number
    playerId: number
    hp: number
    mp: number
    attack: number
    defense: number
    speed: number
    luck: number
    wisdom: number
    strength: number
    agility: number
    vitality: number
    spirit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerStatsAvgAggregateInputType = {
    hp?: true
    mp?: true
    attack?: true
    defense?: true
    speed?: true
    luck?: true
    wisdom?: true
    strength?: true
    agility?: true
    vitality?: true
    spirit?: true
  }

  export type PlayerStatsSumAggregateInputType = {
    hp?: true
    mp?: true
    attack?: true
    defense?: true
    speed?: true
    luck?: true
    wisdom?: true
    strength?: true
    agility?: true
    vitality?: true
    spirit?: true
  }

  export type PlayerStatsMinAggregateInputType = {
    id?: true
    playerId?: true
    hp?: true
    mp?: true
    attack?: true
    defense?: true
    speed?: true
    luck?: true
    wisdom?: true
    strength?: true
    agility?: true
    vitality?: true
    spirit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerStatsMaxAggregateInputType = {
    id?: true
    playerId?: true
    hp?: true
    mp?: true
    attack?: true
    defense?: true
    speed?: true
    luck?: true
    wisdom?: true
    strength?: true
    agility?: true
    vitality?: true
    spirit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerStatsCountAggregateInputType = {
    id?: true
    playerId?: true
    hp?: true
    mp?: true
    attack?: true
    defense?: true
    speed?: true
    luck?: true
    wisdom?: true
    strength?: true
    agility?: true
    vitality?: true
    spirit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerStats to aggregate.
     */
    where?: PlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStats to fetch.
     */
    orderBy?: PlayerStatsOrderByWithRelationInput | PlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerStats
    **/
    _count?: true | PlayerStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerStatsMaxAggregateInputType
  }

  export type GetPlayerStatsAggregateType<T extends PlayerStatsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerStats[P]>
      : GetScalarType<T[P], AggregatePlayerStats[P]>
  }




  export type PlayerStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerStatsWhereInput
    orderBy?: PlayerStatsOrderByWithAggregationInput | PlayerStatsOrderByWithAggregationInput[]
    by: PlayerStatsScalarFieldEnum[] | PlayerStatsScalarFieldEnum
    having?: PlayerStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerStatsCountAggregateInputType | true
    _avg?: PlayerStatsAvgAggregateInputType
    _sum?: PlayerStatsSumAggregateInputType
    _min?: PlayerStatsMinAggregateInputType
    _max?: PlayerStatsMaxAggregateInputType
  }

  export type PlayerStatsGroupByOutputType = {
    id: string
    playerId: string
    hp: number
    mp: number
    attack: number
    defense: number
    speed: number
    luck: number
    wisdom: number
    strength: number
    agility: number
    vitality: number
    spirit: number
    createdAt: Date
    updatedAt: Date
    _count: PlayerStatsCountAggregateOutputType | null
    _avg: PlayerStatsAvgAggregateOutputType | null
    _sum: PlayerStatsSumAggregateOutputType | null
    _min: PlayerStatsMinAggregateOutputType | null
    _max: PlayerStatsMaxAggregateOutputType | null
  }

  type GetPlayerStatsGroupByPayload<T extends PlayerStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerStatsGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerStatsGroupByOutputType[P]>
        }
      >
    >


  export type PlayerStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    hp?: boolean
    mp?: boolean
    attack?: boolean
    defense?: boolean
    speed?: boolean
    luck?: boolean
    wisdom?: boolean
    strength?: boolean
    agility?: boolean
    vitality?: boolean
    spirit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerStats"]>

  export type PlayerStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    hp?: boolean
    mp?: boolean
    attack?: boolean
    defense?: boolean
    speed?: boolean
    luck?: boolean
    wisdom?: boolean
    strength?: boolean
    agility?: boolean
    vitality?: boolean
    spirit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerStats"]>

  export type PlayerStatsSelectScalar = {
    id?: boolean
    playerId?: boolean
    hp?: boolean
    mp?: boolean
    attack?: boolean
    defense?: boolean
    speed?: boolean
    luck?: boolean
    wisdom?: boolean
    strength?: boolean
    agility?: boolean
    vitality?: boolean
    spirit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PlayerStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $PlayerStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerStats"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      hp: number
      mp: number
      attack: number
      defense: number
      speed: number
      luck: number
      wisdom: number
      strength: number
      agility: number
      vitality: number
      spirit: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerStats"]>
    composites: {}
  }

  type PlayerStatsGetPayload<S extends boolean | null | undefined | PlayerStatsDefaultArgs> = $Result.GetResult<Prisma.$PlayerStatsPayload, S>

  type PlayerStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerStatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerStatsCountAggregateInputType | true
    }

  export interface PlayerStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerStats'], meta: { name: 'PlayerStats' } }
    /**
     * Find zero or one PlayerStats that matches the filter.
     * @param {PlayerStatsFindUniqueArgs} args - Arguments to find a PlayerStats
     * @example
     * // Get one PlayerStats
     * const playerStats = await prisma.playerStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerStatsFindUniqueArgs>(args: SelectSubset<T, PlayerStatsFindUniqueArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerStats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerStatsFindUniqueOrThrowArgs} args - Arguments to find a PlayerStats
     * @example
     * // Get one PlayerStats
     * const playerStats = await prisma.playerStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsFindFirstArgs} args - Arguments to find a PlayerStats
     * @example
     * // Get one PlayerStats
     * const playerStats = await prisma.playerStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerStatsFindFirstArgs>(args?: SelectSubset<T, PlayerStatsFindFirstArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsFindFirstOrThrowArgs} args - Arguments to find a PlayerStats
     * @example
     * // Get one PlayerStats
     * const playerStats = await prisma.playerStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerStats
     * const playerStats = await prisma.playerStats.findMany()
     * 
     * // Get first 10 PlayerStats
     * const playerStats = await prisma.playerStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerStatsWithIdOnly = await prisma.playerStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerStatsFindManyArgs>(args?: SelectSubset<T, PlayerStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerStats.
     * @param {PlayerStatsCreateArgs} args - Arguments to create a PlayerStats.
     * @example
     * // Create one PlayerStats
     * const PlayerStats = await prisma.playerStats.create({
     *   data: {
     *     // ... data to create a PlayerStats
     *   }
     * })
     * 
     */
    create<T extends PlayerStatsCreateArgs>(args: SelectSubset<T, PlayerStatsCreateArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerStats.
     * @param {PlayerStatsCreateManyArgs} args - Arguments to create many PlayerStats.
     * @example
     * // Create many PlayerStats
     * const playerStats = await prisma.playerStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerStatsCreateManyArgs>(args?: SelectSubset<T, PlayerStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerStats and returns the data saved in the database.
     * @param {PlayerStatsCreateManyAndReturnArgs} args - Arguments to create many PlayerStats.
     * @example
     * // Create many PlayerStats
     * const playerStats = await prisma.playerStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerStats and only return the `id`
     * const playerStatsWithIdOnly = await prisma.playerStats.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerStats.
     * @param {PlayerStatsDeleteArgs} args - Arguments to delete one PlayerStats.
     * @example
     * // Delete one PlayerStats
     * const PlayerStats = await prisma.playerStats.delete({
     *   where: {
     *     // ... filter to delete one PlayerStats
     *   }
     * })
     * 
     */
    delete<T extends PlayerStatsDeleteArgs>(args: SelectSubset<T, PlayerStatsDeleteArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerStats.
     * @param {PlayerStatsUpdateArgs} args - Arguments to update one PlayerStats.
     * @example
     * // Update one PlayerStats
     * const playerStats = await prisma.playerStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerStatsUpdateArgs>(args: SelectSubset<T, PlayerStatsUpdateArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerStats.
     * @param {PlayerStatsDeleteManyArgs} args - Arguments to filter PlayerStats to delete.
     * @example
     * // Delete a few PlayerStats
     * const { count } = await prisma.playerStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerStatsDeleteManyArgs>(args?: SelectSubset<T, PlayerStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerStats
     * const playerStats = await prisma.playerStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerStatsUpdateManyArgs>(args: SelectSubset<T, PlayerStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerStats.
     * @param {PlayerStatsUpsertArgs} args - Arguments to update or create a PlayerStats.
     * @example
     * // Update or create a PlayerStats
     * const playerStats = await prisma.playerStats.upsert({
     *   create: {
     *     // ... data to create a PlayerStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerStats we want to update
     *   }
     * })
     */
    upsert<T extends PlayerStatsUpsertArgs>(args: SelectSubset<T, PlayerStatsUpsertArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsCountArgs} args - Arguments to filter PlayerStats to count.
     * @example
     * // Count the number of PlayerStats
     * const count = await prisma.playerStats.count({
     *   where: {
     *     // ... the filter for the PlayerStats we want to count
     *   }
     * })
    **/
    count<T extends PlayerStatsCountArgs>(
      args?: Subset<T, PlayerStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerStatsAggregateArgs>(args: Subset<T, PlayerStatsAggregateArgs>): Prisma.PrismaPromise<GetPlayerStatsAggregateType<T>>

    /**
     * Group by PlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerStatsGroupByArgs['orderBy'] }
        : { orderBy?: PlayerStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerStats model
   */
  readonly fields: PlayerStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerStats model
   */ 
  interface PlayerStatsFieldRefs {
    readonly id: FieldRef<"PlayerStats", 'String'>
    readonly playerId: FieldRef<"PlayerStats", 'String'>
    readonly hp: FieldRef<"PlayerStats", 'Int'>
    readonly mp: FieldRef<"PlayerStats", 'Int'>
    readonly attack: FieldRef<"PlayerStats", 'Int'>
    readonly defense: FieldRef<"PlayerStats", 'Int'>
    readonly speed: FieldRef<"PlayerStats", 'Int'>
    readonly luck: FieldRef<"PlayerStats", 'Int'>
    readonly wisdom: FieldRef<"PlayerStats", 'Int'>
    readonly strength: FieldRef<"PlayerStats", 'Int'>
    readonly agility: FieldRef<"PlayerStats", 'Int'>
    readonly vitality: FieldRef<"PlayerStats", 'Int'>
    readonly spirit: FieldRef<"PlayerStats", 'Int'>
    readonly createdAt: FieldRef<"PlayerStats", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerStats findUnique
   */
  export type PlayerStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStats to fetch.
     */
    where: PlayerStatsWhereUniqueInput
  }

  /**
   * PlayerStats findUniqueOrThrow
   */
  export type PlayerStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStats to fetch.
     */
    where: PlayerStatsWhereUniqueInput
  }

  /**
   * PlayerStats findFirst
   */
  export type PlayerStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStats to fetch.
     */
    where?: PlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStats to fetch.
     */
    orderBy?: PlayerStatsOrderByWithRelationInput | PlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerStats.
     */
    cursor?: PlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerStats.
     */
    distinct?: PlayerStatsScalarFieldEnum | PlayerStatsScalarFieldEnum[]
  }

  /**
   * PlayerStats findFirstOrThrow
   */
  export type PlayerStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStats to fetch.
     */
    where?: PlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStats to fetch.
     */
    orderBy?: PlayerStatsOrderByWithRelationInput | PlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerStats.
     */
    cursor?: PlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerStats.
     */
    distinct?: PlayerStatsScalarFieldEnum | PlayerStatsScalarFieldEnum[]
  }

  /**
   * PlayerStats findMany
   */
  export type PlayerStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStats to fetch.
     */
    where?: PlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStats to fetch.
     */
    orderBy?: PlayerStatsOrderByWithRelationInput | PlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerStats.
     */
    cursor?: PlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStats.
     */
    skip?: number
    distinct?: PlayerStatsScalarFieldEnum | PlayerStatsScalarFieldEnum[]
  }

  /**
   * PlayerStats create
   */
  export type PlayerStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerStats.
     */
    data: XOR<PlayerStatsCreateInput, PlayerStatsUncheckedCreateInput>
  }

  /**
   * PlayerStats createMany
   */
  export type PlayerStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerStats.
     */
    data: PlayerStatsCreateManyInput | PlayerStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerStats createManyAndReturn
   */
  export type PlayerStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerStats.
     */
    data: PlayerStatsCreateManyInput | PlayerStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerStats update
   */
  export type PlayerStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerStats.
     */
    data: XOR<PlayerStatsUpdateInput, PlayerStatsUncheckedUpdateInput>
    /**
     * Choose, which PlayerStats to update.
     */
    where: PlayerStatsWhereUniqueInput
  }

  /**
   * PlayerStats updateMany
   */
  export type PlayerStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerStats.
     */
    data: XOR<PlayerStatsUpdateManyMutationInput, PlayerStatsUncheckedUpdateManyInput>
    /**
     * Filter which PlayerStats to update
     */
    where?: PlayerStatsWhereInput
  }

  /**
   * PlayerStats upsert
   */
  export type PlayerStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerStats to update in case it exists.
     */
    where: PlayerStatsWhereUniqueInput
    /**
     * In case the PlayerStats found by the `where` argument doesn't exist, create a new PlayerStats with this data.
     */
    create: XOR<PlayerStatsCreateInput, PlayerStatsUncheckedCreateInput>
    /**
     * In case the PlayerStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerStatsUpdateInput, PlayerStatsUncheckedUpdateInput>
  }

  /**
   * PlayerStats delete
   */
  export type PlayerStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter which PlayerStats to delete.
     */
    where: PlayerStatsWhereUniqueInput
  }

  /**
   * PlayerStats deleteMany
   */
  export type PlayerStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerStats to delete
     */
    where?: PlayerStatsWhereInput
  }

  /**
   * PlayerStats without action
   */
  export type PlayerStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentType
   */

  export type AggregateEquipmentType = {
    _count: EquipmentTypeCountAggregateOutputType | null
    _min: EquipmentTypeMinAggregateOutputType | null
    _max: EquipmentTypeMaxAggregateOutputType | null
  }

  export type EquipmentTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    slot: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    slot: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentTypeCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    slot: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentTypeMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    slot?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentTypeMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    slot?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentTypeCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    slot?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentType to aggregate.
     */
    where?: EquipmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentTypes to fetch.
     */
    orderBy?: EquipmentTypeOrderByWithRelationInput | EquipmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentTypes
    **/
    _count?: true | EquipmentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentTypeMaxAggregateInputType
  }

  export type GetEquipmentTypeAggregateType<T extends EquipmentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentType[P]>
      : GetScalarType<T[P], AggregateEquipmentType[P]>
  }




  export type EquipmentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentTypeWhereInput
    orderBy?: EquipmentTypeOrderByWithAggregationInput | EquipmentTypeOrderByWithAggregationInput[]
    by: EquipmentTypeScalarFieldEnum[] | EquipmentTypeScalarFieldEnum
    having?: EquipmentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentTypeCountAggregateInputType | true
    _min?: EquipmentTypeMinAggregateInputType
    _max?: EquipmentTypeMaxAggregateInputType
  }

  export type EquipmentTypeGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    slot: string
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: EquipmentTypeCountAggregateOutputType | null
    _min: EquipmentTypeMinAggregateOutputType | null
    _max: EquipmentTypeMaxAggregateOutputType | null
  }

  type GetEquipmentTypeGroupByPayload<T extends EquipmentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentTypeGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    slot?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipments?: boolean | EquipmentType$equipmentsArgs<ExtArgs>
    _count?: boolean | EquipmentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentType"]>

  export type EquipmentTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    slot?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["equipmentType"]>

  export type EquipmentTypeSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    slot?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipments?: boolean | EquipmentType$equipmentsArgs<ExtArgs>
    _count?: boolean | EquipmentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EquipmentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentType"
    objects: {
      equipments: Prisma.$EquipmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      slot: string
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipmentType"]>
    composites: {}
  }

  type EquipmentTypeGetPayload<S extends boolean | null | undefined | EquipmentTypeDefaultArgs> = $Result.GetResult<Prisma.$EquipmentTypePayload, S>

  type EquipmentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EquipmentTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EquipmentTypeCountAggregateInputType | true
    }

  export interface EquipmentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentType'], meta: { name: 'EquipmentType' } }
    /**
     * Find zero or one EquipmentType that matches the filter.
     * @param {EquipmentTypeFindUniqueArgs} args - Arguments to find a EquipmentType
     * @example
     * // Get one EquipmentType
     * const equipmentType = await prisma.equipmentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentTypeFindUniqueArgs>(args: SelectSubset<T, EquipmentTypeFindUniqueArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EquipmentType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EquipmentTypeFindUniqueOrThrowArgs} args - Arguments to find a EquipmentType
     * @example
     * // Get one EquipmentType
     * const equipmentType = await prisma.equipmentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EquipmentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeFindFirstArgs} args - Arguments to find a EquipmentType
     * @example
     * // Get one EquipmentType
     * const equipmentType = await prisma.equipmentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentTypeFindFirstArgs>(args?: SelectSubset<T, EquipmentTypeFindFirstArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EquipmentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeFindFirstOrThrowArgs} args - Arguments to find a EquipmentType
     * @example
     * // Get one EquipmentType
     * const equipmentType = await prisma.equipmentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EquipmentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentTypes
     * const equipmentTypes = await prisma.equipmentType.findMany()
     * 
     * // Get first 10 EquipmentTypes
     * const equipmentTypes = await prisma.equipmentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentTypeWithIdOnly = await prisma.equipmentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentTypeFindManyArgs>(args?: SelectSubset<T, EquipmentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EquipmentType.
     * @param {EquipmentTypeCreateArgs} args - Arguments to create a EquipmentType.
     * @example
     * // Create one EquipmentType
     * const EquipmentType = await prisma.equipmentType.create({
     *   data: {
     *     // ... data to create a EquipmentType
     *   }
     * })
     * 
     */
    create<T extends EquipmentTypeCreateArgs>(args: SelectSubset<T, EquipmentTypeCreateArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EquipmentTypes.
     * @param {EquipmentTypeCreateManyArgs} args - Arguments to create many EquipmentTypes.
     * @example
     * // Create many EquipmentTypes
     * const equipmentType = await prisma.equipmentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentTypeCreateManyArgs>(args?: SelectSubset<T, EquipmentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentTypes and returns the data saved in the database.
     * @param {EquipmentTypeCreateManyAndReturnArgs} args - Arguments to create many EquipmentTypes.
     * @example
     * // Create many EquipmentTypes
     * const equipmentType = await prisma.equipmentType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentTypes and only return the `id`
     * const equipmentTypeWithIdOnly = await prisma.equipmentType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EquipmentType.
     * @param {EquipmentTypeDeleteArgs} args - Arguments to delete one EquipmentType.
     * @example
     * // Delete one EquipmentType
     * const EquipmentType = await prisma.equipmentType.delete({
     *   where: {
     *     // ... filter to delete one EquipmentType
     *   }
     * })
     * 
     */
    delete<T extends EquipmentTypeDeleteArgs>(args: SelectSubset<T, EquipmentTypeDeleteArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EquipmentType.
     * @param {EquipmentTypeUpdateArgs} args - Arguments to update one EquipmentType.
     * @example
     * // Update one EquipmentType
     * const equipmentType = await prisma.equipmentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentTypeUpdateArgs>(args: SelectSubset<T, EquipmentTypeUpdateArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EquipmentTypes.
     * @param {EquipmentTypeDeleteManyArgs} args - Arguments to filter EquipmentTypes to delete.
     * @example
     * // Delete a few EquipmentTypes
     * const { count } = await prisma.equipmentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentTypeDeleteManyArgs>(args?: SelectSubset<T, EquipmentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentTypes
     * const equipmentType = await prisma.equipmentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentTypeUpdateManyArgs>(args: SelectSubset<T, EquipmentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EquipmentType.
     * @param {EquipmentTypeUpsertArgs} args - Arguments to update or create a EquipmentType.
     * @example
     * // Update or create a EquipmentType
     * const equipmentType = await prisma.equipmentType.upsert({
     *   create: {
     *     // ... data to create a EquipmentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentType we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentTypeUpsertArgs>(args: SelectSubset<T, EquipmentTypeUpsertArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EquipmentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeCountArgs} args - Arguments to filter EquipmentTypes to count.
     * @example
     * // Count the number of EquipmentTypes
     * const count = await prisma.equipmentType.count({
     *   where: {
     *     // ... the filter for the EquipmentTypes we want to count
     *   }
     * })
    **/
    count<T extends EquipmentTypeCountArgs>(
      args?: Subset<T, EquipmentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentTypeAggregateArgs>(args: Subset<T, EquipmentTypeAggregateArgs>): Prisma.PrismaPromise<GetEquipmentTypeAggregateType<T>>

    /**
     * Group by EquipmentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentTypeGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentType model
   */
  readonly fields: EquipmentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipments<T extends EquipmentType$equipmentsArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentType$equipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentType model
   */ 
  interface EquipmentTypeFieldRefs {
    readonly id: FieldRef<"EquipmentType", 'String'>
    readonly name: FieldRef<"EquipmentType", 'String'>
    readonly displayName: FieldRef<"EquipmentType", 'String'>
    readonly description: FieldRef<"EquipmentType", 'String'>
    readonly slot: FieldRef<"EquipmentType", 'String'>
    readonly icon: FieldRef<"EquipmentType", 'String'>
    readonly createdAt: FieldRef<"EquipmentType", 'DateTime'>
    readonly updatedAt: FieldRef<"EquipmentType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentType findUnique
   */
  export type EquipmentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentType to fetch.
     */
    where: EquipmentTypeWhereUniqueInput
  }

  /**
   * EquipmentType findUniqueOrThrow
   */
  export type EquipmentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentType to fetch.
     */
    where: EquipmentTypeWhereUniqueInput
  }

  /**
   * EquipmentType findFirst
   */
  export type EquipmentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentType to fetch.
     */
    where?: EquipmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentTypes to fetch.
     */
    orderBy?: EquipmentTypeOrderByWithRelationInput | EquipmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentTypes.
     */
    cursor?: EquipmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentTypes.
     */
    distinct?: EquipmentTypeScalarFieldEnum | EquipmentTypeScalarFieldEnum[]
  }

  /**
   * EquipmentType findFirstOrThrow
   */
  export type EquipmentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentType to fetch.
     */
    where?: EquipmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentTypes to fetch.
     */
    orderBy?: EquipmentTypeOrderByWithRelationInput | EquipmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentTypes.
     */
    cursor?: EquipmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentTypes.
     */
    distinct?: EquipmentTypeScalarFieldEnum | EquipmentTypeScalarFieldEnum[]
  }

  /**
   * EquipmentType findMany
   */
  export type EquipmentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentTypes to fetch.
     */
    where?: EquipmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentTypes to fetch.
     */
    orderBy?: EquipmentTypeOrderByWithRelationInput | EquipmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentTypes.
     */
    cursor?: EquipmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentTypes.
     */
    skip?: number
    distinct?: EquipmentTypeScalarFieldEnum | EquipmentTypeScalarFieldEnum[]
  }

  /**
   * EquipmentType create
   */
  export type EquipmentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentType.
     */
    data: XOR<EquipmentTypeCreateInput, EquipmentTypeUncheckedCreateInput>
  }

  /**
   * EquipmentType createMany
   */
  export type EquipmentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentTypes.
     */
    data: EquipmentTypeCreateManyInput | EquipmentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentType createManyAndReturn
   */
  export type EquipmentTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EquipmentTypes.
     */
    data: EquipmentTypeCreateManyInput | EquipmentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentType update
   */
  export type EquipmentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentType.
     */
    data: XOR<EquipmentTypeUpdateInput, EquipmentTypeUncheckedUpdateInput>
    /**
     * Choose, which EquipmentType to update.
     */
    where: EquipmentTypeWhereUniqueInput
  }

  /**
   * EquipmentType updateMany
   */
  export type EquipmentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentTypes.
     */
    data: XOR<EquipmentTypeUpdateManyMutationInput, EquipmentTypeUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentTypes to update
     */
    where?: EquipmentTypeWhereInput
  }

  /**
   * EquipmentType upsert
   */
  export type EquipmentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentType to update in case it exists.
     */
    where: EquipmentTypeWhereUniqueInput
    /**
     * In case the EquipmentType found by the `where` argument doesn't exist, create a new EquipmentType with this data.
     */
    create: XOR<EquipmentTypeCreateInput, EquipmentTypeUncheckedCreateInput>
    /**
     * In case the EquipmentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentTypeUpdateInput, EquipmentTypeUncheckedUpdateInput>
  }

  /**
   * EquipmentType delete
   */
  export type EquipmentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter which EquipmentType to delete.
     */
    where: EquipmentTypeWhereUniqueInput
  }

  /**
   * EquipmentType deleteMany
   */
  export type EquipmentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentTypes to delete
     */
    where?: EquipmentTypeWhereInput
  }

  /**
   * EquipmentType.equipments
   */
  export type EquipmentType$equipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * EquipmentType without action
   */
  export type EquipmentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    level: number | null
    price: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    level: number | null
    price: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    typeId: string | null
    rarity: string | null
    level: number | null
    stats: string | null
    requirements: string | null
    price: number | null
    isTradeable: boolean | null
    isSellable: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    typeId: string | null
    rarity: string | null
    level: number | null
    stats: string | null
    requirements: string | null
    price: number | null
    isTradeable: boolean | null
    isSellable: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    typeId: number
    rarity: number
    level: number
    stats: number
    requirements: number
    price: number
    isTradeable: number
    isSellable: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    level?: true
    price?: true
  }

  export type EquipmentSumAggregateInputType = {
    level?: true
    price?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    typeId?: true
    rarity?: true
    level?: true
    stats?: true
    requirements?: true
    price?: true
    isTradeable?: true
    isSellable?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    typeId?: true
    rarity?: true
    level?: true
    stats?: true
    requirements?: true
    price?: true
    isTradeable?: true
    isSellable?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    typeId?: true
    rarity?: true
    level?: true
    stats?: true
    requirements?: true
    price?: true
    isTradeable?: true
    isSellable?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    typeId: string
    rarity: string
    level: number
    stats: string | null
    requirements: string | null
    price: number
    isTradeable: boolean
    isSellable: boolean
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    typeId?: boolean
    rarity?: boolean
    level?: boolean
    stats?: boolean
    requirements?: boolean
    price?: boolean
    isTradeable?: boolean
    isSellable?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean | EquipmentTypeDefaultArgs<ExtArgs>
    playerEquipments?: boolean | Equipment$playerEquipmentsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    typeId?: boolean
    rarity?: boolean
    level?: boolean
    stats?: boolean
    requirements?: boolean
    price?: boolean
    isTradeable?: boolean
    isSellable?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean | EquipmentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    typeId?: boolean
    rarity?: boolean
    level?: boolean
    stats?: boolean
    requirements?: boolean
    price?: boolean
    isTradeable?: boolean
    isSellable?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type?: boolean | EquipmentTypeDefaultArgs<ExtArgs>
    playerEquipments?: boolean | Equipment$playerEquipmentsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type?: boolean | EquipmentTypeDefaultArgs<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      type: Prisma.$EquipmentTypePayload<ExtArgs>
      playerEquipments: Prisma.$PlayerEquipmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      typeId: string
      rarity: string
      level: number
      stats: string | null
      requirements: string | null
      price: number
      isTradeable: boolean
      isSellable: boolean
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipment and returns the data saved in the database.
     * @param {EquipmentCreateManyAndReturnArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    type<T extends EquipmentTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentTypeDefaultArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    playerEquipments<T extends Equipment$playerEquipmentsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$playerEquipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */ 
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly name: FieldRef<"Equipment", 'String'>
    readonly displayName: FieldRef<"Equipment", 'String'>
    readonly description: FieldRef<"Equipment", 'String'>
    readonly typeId: FieldRef<"Equipment", 'String'>
    readonly rarity: FieldRef<"Equipment", 'String'>
    readonly level: FieldRef<"Equipment", 'Int'>
    readonly stats: FieldRef<"Equipment", 'String'>
    readonly requirements: FieldRef<"Equipment", 'String'>
    readonly price: FieldRef<"Equipment", 'Int'>
    readonly isTradeable: FieldRef<"Equipment", 'Boolean'>
    readonly isSellable: FieldRef<"Equipment", 'Boolean'>
    readonly icon: FieldRef<"Equipment", 'String'>
    readonly createdAt: FieldRef<"Equipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Equipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment createManyAndReturn
   */
  export type EquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
  }

  /**
   * Equipment.playerEquipments
   */
  export type Equipment$playerEquipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    where?: PlayerEquipmentWhereInput
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    cursor?: PlayerEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerEquipmentScalarFieldEnum | PlayerEquipmentScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model PlayerEquipment
   */

  export type AggregatePlayerEquipment = {
    _count: PlayerEquipmentCountAggregateOutputType | null
    _avg: PlayerEquipmentAvgAggregateOutputType | null
    _sum: PlayerEquipmentSumAggregateOutputType | null
    _min: PlayerEquipmentMinAggregateOutputType | null
    _max: PlayerEquipmentMaxAggregateOutputType | null
  }

  export type PlayerEquipmentAvgAggregateOutputType = {
    durability: number | null
    enhancement: number | null
  }

  export type PlayerEquipmentSumAggregateOutputType = {
    durability: number | null
    enhancement: number | null
  }

  export type PlayerEquipmentMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    equipmentId: string | null
    isEquipped: boolean | null
    durability: number | null
    enhancement: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerEquipmentMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    equipmentId: string | null
    isEquipped: boolean | null
    durability: number | null
    enhancement: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerEquipmentCountAggregateOutputType = {
    id: number
    playerId: number
    equipmentId: number
    isEquipped: number
    durability: number
    enhancement: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerEquipmentAvgAggregateInputType = {
    durability?: true
    enhancement?: true
  }

  export type PlayerEquipmentSumAggregateInputType = {
    durability?: true
    enhancement?: true
  }

  export type PlayerEquipmentMinAggregateInputType = {
    id?: true
    playerId?: true
    equipmentId?: true
    isEquipped?: true
    durability?: true
    enhancement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerEquipmentMaxAggregateInputType = {
    id?: true
    playerId?: true
    equipmentId?: true
    isEquipped?: true
    durability?: true
    enhancement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerEquipmentCountAggregateInputType = {
    id?: true
    playerId?: true
    equipmentId?: true
    isEquipped?: true
    durability?: true
    enhancement?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerEquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerEquipment to aggregate.
     */
    where?: PlayerEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEquipments to fetch.
     */
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerEquipments
    **/
    _count?: true | PlayerEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerEquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerEquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerEquipmentMaxAggregateInputType
  }

  export type GetPlayerEquipmentAggregateType<T extends PlayerEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerEquipment[P]>
      : GetScalarType<T[P], AggregatePlayerEquipment[P]>
  }




  export type PlayerEquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerEquipmentWhereInput
    orderBy?: PlayerEquipmentOrderByWithAggregationInput | PlayerEquipmentOrderByWithAggregationInput[]
    by: PlayerEquipmentScalarFieldEnum[] | PlayerEquipmentScalarFieldEnum
    having?: PlayerEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerEquipmentCountAggregateInputType | true
    _avg?: PlayerEquipmentAvgAggregateInputType
    _sum?: PlayerEquipmentSumAggregateInputType
    _min?: PlayerEquipmentMinAggregateInputType
    _max?: PlayerEquipmentMaxAggregateInputType
  }

  export type PlayerEquipmentGroupByOutputType = {
    id: string
    playerId: string
    equipmentId: string
    isEquipped: boolean
    durability: number
    enhancement: number
    createdAt: Date
    updatedAt: Date
    _count: PlayerEquipmentCountAggregateOutputType | null
    _avg: PlayerEquipmentAvgAggregateOutputType | null
    _sum: PlayerEquipmentSumAggregateOutputType | null
    _min: PlayerEquipmentMinAggregateOutputType | null
    _max: PlayerEquipmentMaxAggregateOutputType | null
  }

  type GetPlayerEquipmentGroupByPayload<T extends PlayerEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type PlayerEquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    equipmentId?: boolean
    isEquipped?: boolean
    durability?: boolean
    enhancement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerEquipment"]>

  export type PlayerEquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    equipmentId?: boolean
    isEquipped?: boolean
    durability?: boolean
    enhancement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerEquipment"]>

  export type PlayerEquipmentSelectScalar = {
    id?: boolean
    playerId?: boolean
    equipmentId?: boolean
    isEquipped?: boolean
    durability?: boolean
    enhancement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerEquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type PlayerEquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $PlayerEquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerEquipment"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      equipmentId: string
      isEquipped: boolean
      durability: number
      enhancement: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerEquipment"]>
    composites: {}
  }

  type PlayerEquipmentGetPayload<S extends boolean | null | undefined | PlayerEquipmentDefaultArgs> = $Result.GetResult<Prisma.$PlayerEquipmentPayload, S>

  type PlayerEquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerEquipmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerEquipmentCountAggregateInputType | true
    }

  export interface PlayerEquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerEquipment'], meta: { name: 'PlayerEquipment' } }
    /**
     * Find zero or one PlayerEquipment that matches the filter.
     * @param {PlayerEquipmentFindUniqueArgs} args - Arguments to find a PlayerEquipment
     * @example
     * // Get one PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerEquipmentFindUniqueArgs>(args: SelectSubset<T, PlayerEquipmentFindUniqueArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerEquipment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerEquipmentFindUniqueOrThrowArgs} args - Arguments to find a PlayerEquipment
     * @example
     * // Get one PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerEquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerEquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentFindFirstArgs} args - Arguments to find a PlayerEquipment
     * @example
     * // Get one PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerEquipmentFindFirstArgs>(args?: SelectSubset<T, PlayerEquipmentFindFirstArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerEquipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentFindFirstOrThrowArgs} args - Arguments to find a PlayerEquipment
     * @example
     * // Get one PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerEquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerEquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerEquipments
     * const playerEquipments = await prisma.playerEquipment.findMany()
     * 
     * // Get first 10 PlayerEquipments
     * const playerEquipments = await prisma.playerEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerEquipmentWithIdOnly = await prisma.playerEquipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerEquipmentFindManyArgs>(args?: SelectSubset<T, PlayerEquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerEquipment.
     * @param {PlayerEquipmentCreateArgs} args - Arguments to create a PlayerEquipment.
     * @example
     * // Create one PlayerEquipment
     * const PlayerEquipment = await prisma.playerEquipment.create({
     *   data: {
     *     // ... data to create a PlayerEquipment
     *   }
     * })
     * 
     */
    create<T extends PlayerEquipmentCreateArgs>(args: SelectSubset<T, PlayerEquipmentCreateArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerEquipments.
     * @param {PlayerEquipmentCreateManyArgs} args - Arguments to create many PlayerEquipments.
     * @example
     * // Create many PlayerEquipments
     * const playerEquipment = await prisma.playerEquipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerEquipmentCreateManyArgs>(args?: SelectSubset<T, PlayerEquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerEquipments and returns the data saved in the database.
     * @param {PlayerEquipmentCreateManyAndReturnArgs} args - Arguments to create many PlayerEquipments.
     * @example
     * // Create many PlayerEquipments
     * const playerEquipment = await prisma.playerEquipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerEquipments and only return the `id`
     * const playerEquipmentWithIdOnly = await prisma.playerEquipment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerEquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerEquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerEquipment.
     * @param {PlayerEquipmentDeleteArgs} args - Arguments to delete one PlayerEquipment.
     * @example
     * // Delete one PlayerEquipment
     * const PlayerEquipment = await prisma.playerEquipment.delete({
     *   where: {
     *     // ... filter to delete one PlayerEquipment
     *   }
     * })
     * 
     */
    delete<T extends PlayerEquipmentDeleteArgs>(args: SelectSubset<T, PlayerEquipmentDeleteArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerEquipment.
     * @param {PlayerEquipmentUpdateArgs} args - Arguments to update one PlayerEquipment.
     * @example
     * // Update one PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerEquipmentUpdateArgs>(args: SelectSubset<T, PlayerEquipmentUpdateArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerEquipments.
     * @param {PlayerEquipmentDeleteManyArgs} args - Arguments to filter PlayerEquipments to delete.
     * @example
     * // Delete a few PlayerEquipments
     * const { count } = await prisma.playerEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerEquipmentDeleteManyArgs>(args?: SelectSubset<T, PlayerEquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerEquipments
     * const playerEquipment = await prisma.playerEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerEquipmentUpdateManyArgs>(args: SelectSubset<T, PlayerEquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerEquipment.
     * @param {PlayerEquipmentUpsertArgs} args - Arguments to update or create a PlayerEquipment.
     * @example
     * // Update or create a PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.upsert({
     *   create: {
     *     // ... data to create a PlayerEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerEquipment we want to update
     *   }
     * })
     */
    upsert<T extends PlayerEquipmentUpsertArgs>(args: SelectSubset<T, PlayerEquipmentUpsertArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentCountArgs} args - Arguments to filter PlayerEquipments to count.
     * @example
     * // Count the number of PlayerEquipments
     * const count = await prisma.playerEquipment.count({
     *   where: {
     *     // ... the filter for the PlayerEquipments we want to count
     *   }
     * })
    **/
    count<T extends PlayerEquipmentCountArgs>(
      args?: Subset<T, PlayerEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerEquipmentAggregateArgs>(args: Subset<T, PlayerEquipmentAggregateArgs>): Prisma.PrismaPromise<GetPlayerEquipmentAggregateType<T>>

    /**
     * Group by PlayerEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: PlayerEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerEquipment model
   */
  readonly fields: PlayerEquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerEquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerEquipment model
   */ 
  interface PlayerEquipmentFieldRefs {
    readonly id: FieldRef<"PlayerEquipment", 'String'>
    readonly playerId: FieldRef<"PlayerEquipment", 'String'>
    readonly equipmentId: FieldRef<"PlayerEquipment", 'String'>
    readonly isEquipped: FieldRef<"PlayerEquipment", 'Boolean'>
    readonly durability: FieldRef<"PlayerEquipment", 'Int'>
    readonly enhancement: FieldRef<"PlayerEquipment", 'Int'>
    readonly createdAt: FieldRef<"PlayerEquipment", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerEquipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerEquipment findUnique
   */
  export type PlayerEquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEquipment to fetch.
     */
    where: PlayerEquipmentWhereUniqueInput
  }

  /**
   * PlayerEquipment findUniqueOrThrow
   */
  export type PlayerEquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEquipment to fetch.
     */
    where: PlayerEquipmentWhereUniqueInput
  }

  /**
   * PlayerEquipment findFirst
   */
  export type PlayerEquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEquipment to fetch.
     */
    where?: PlayerEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEquipments to fetch.
     */
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerEquipments.
     */
    cursor?: PlayerEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerEquipments.
     */
    distinct?: PlayerEquipmentScalarFieldEnum | PlayerEquipmentScalarFieldEnum[]
  }

  /**
   * PlayerEquipment findFirstOrThrow
   */
  export type PlayerEquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEquipment to fetch.
     */
    where?: PlayerEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEquipments to fetch.
     */
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerEquipments.
     */
    cursor?: PlayerEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerEquipments.
     */
    distinct?: PlayerEquipmentScalarFieldEnum | PlayerEquipmentScalarFieldEnum[]
  }

  /**
   * PlayerEquipment findMany
   */
  export type PlayerEquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEquipments to fetch.
     */
    where?: PlayerEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEquipments to fetch.
     */
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerEquipments.
     */
    cursor?: PlayerEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEquipments.
     */
    skip?: number
    distinct?: PlayerEquipmentScalarFieldEnum | PlayerEquipmentScalarFieldEnum[]
  }

  /**
   * PlayerEquipment create
   */
  export type PlayerEquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerEquipment.
     */
    data: XOR<PlayerEquipmentCreateInput, PlayerEquipmentUncheckedCreateInput>
  }

  /**
   * PlayerEquipment createMany
   */
  export type PlayerEquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerEquipments.
     */
    data: PlayerEquipmentCreateManyInput | PlayerEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerEquipment createManyAndReturn
   */
  export type PlayerEquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerEquipments.
     */
    data: PlayerEquipmentCreateManyInput | PlayerEquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerEquipment update
   */
  export type PlayerEquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerEquipment.
     */
    data: XOR<PlayerEquipmentUpdateInput, PlayerEquipmentUncheckedUpdateInput>
    /**
     * Choose, which PlayerEquipment to update.
     */
    where: PlayerEquipmentWhereUniqueInput
  }

  /**
   * PlayerEquipment updateMany
   */
  export type PlayerEquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerEquipments.
     */
    data: XOR<PlayerEquipmentUpdateManyMutationInput, PlayerEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which PlayerEquipments to update
     */
    where?: PlayerEquipmentWhereInput
  }

  /**
   * PlayerEquipment upsert
   */
  export type PlayerEquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerEquipment to update in case it exists.
     */
    where: PlayerEquipmentWhereUniqueInput
    /**
     * In case the PlayerEquipment found by the `where` argument doesn't exist, create a new PlayerEquipment with this data.
     */
    create: XOR<PlayerEquipmentCreateInput, PlayerEquipmentUncheckedCreateInput>
    /**
     * In case the PlayerEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerEquipmentUpdateInput, PlayerEquipmentUncheckedUpdateInput>
  }

  /**
   * PlayerEquipment delete
   */
  export type PlayerEquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter which PlayerEquipment to delete.
     */
    where: PlayerEquipmentWhereUniqueInput
  }

  /**
   * PlayerEquipment deleteMany
   */
  export type PlayerEquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerEquipments to delete
     */
    where?: PlayerEquipmentWhereInput
  }

  /**
   * PlayerEquipment without action
   */
  export type PlayerEquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    level: number | null
    maxLevel: number | null
    cooldown: number | null
    mpCost: number | null
    damage: number | null
  }

  export type SkillSumAggregateOutputType = {
    level: number | null
    maxLevel: number | null
    cooldown: number | null
    mpCost: number | null
    damage: number | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    type: string | null
    level: number | null
    maxLevel: number | null
    cooldown: number | null
    mpCost: number | null
    damage: number | null
    effects: string | null
    requirements: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    type: string | null
    level: number | null
    maxLevel: number | null
    cooldown: number | null
    mpCost: number | null
    damage: number | null
    effects: string | null
    requirements: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    category: number
    type: number
    level: number
    maxLevel: number
    cooldown: number
    mpCost: number
    damage: number
    effects: number
    requirements: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    level?: true
    maxLevel?: true
    cooldown?: true
    mpCost?: true
    damage?: true
  }

  export type SkillSumAggregateInputType = {
    level?: true
    maxLevel?: true
    cooldown?: true
    mpCost?: true
    damage?: true
  }

  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    type?: true
    level?: true
    maxLevel?: true
    cooldown?: true
    mpCost?: true
    damage?: true
    effects?: true
    requirements?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    type?: true
    level?: true
    maxLevel?: true
    cooldown?: true
    mpCost?: true
    damage?: true
    effects?: true
    requirements?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    type?: true
    level?: true
    maxLevel?: true
    cooldown?: true
    mpCost?: true
    damage?: true
    effects?: true
    requirements?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    category: string
    type: string
    level: number
    maxLevel: number
    cooldown: number
    mpCost: number
    damage: number
    effects: string | null
    requirements: string | null
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    level?: boolean
    maxLevel?: boolean
    cooldown?: boolean
    mpCost?: boolean
    damage?: boolean
    effects?: boolean
    requirements?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playerSkills?: boolean | Skill$playerSkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    level?: boolean
    maxLevel?: boolean
    cooldown?: boolean
    mpCost?: boolean
    damage?: boolean
    effects?: boolean
    requirements?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    level?: boolean
    maxLevel?: boolean
    cooldown?: boolean
    mpCost?: boolean
    damage?: boolean
    effects?: boolean
    requirements?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerSkills?: boolean | Skill$playerSkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      playerSkills: Prisma.$PlayerSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      category: string
      type: string
      level: number
      maxLevel: number
      cooldown: number
      mpCost: number
      damage: number
      effects: string | null
      requirements: string | null
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playerSkills<T extends Skill$playerSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$playerSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */ 
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly displayName: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly category: FieldRef<"Skill", 'String'>
    readonly type: FieldRef<"Skill", 'String'>
    readonly level: FieldRef<"Skill", 'Int'>
    readonly maxLevel: FieldRef<"Skill", 'Int'>
    readonly cooldown: FieldRef<"Skill", 'Int'>
    readonly mpCost: FieldRef<"Skill", 'Int'>
    readonly damage: FieldRef<"Skill", 'Int'>
    readonly effects: FieldRef<"Skill", 'String'>
    readonly requirements: FieldRef<"Skill", 'String'>
    readonly icon: FieldRef<"Skill", 'String'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
    readonly updatedAt: FieldRef<"Skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
  }

  /**
   * Skill.playerSkills
   */
  export type Skill$playerSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    where?: PlayerSkillWhereInput
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    cursor?: PlayerSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerSkillScalarFieldEnum | PlayerSkillScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model PlayerSkill
   */

  export type AggregatePlayerSkill = {
    _count: PlayerSkillCountAggregateOutputType | null
    _avg: PlayerSkillAvgAggregateOutputType | null
    _sum: PlayerSkillSumAggregateOutputType | null
    _min: PlayerSkillMinAggregateOutputType | null
    _max: PlayerSkillMaxAggregateOutputType | null
  }

  export type PlayerSkillAvgAggregateOutputType = {
    level: number | null
  }

  export type PlayerSkillSumAggregateOutputType = {
    level: number | null
  }

  export type PlayerSkillMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    skillId: string | null
    level: number | null
    isLearned: boolean | null
    learnedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerSkillMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    skillId: string | null
    level: number | null
    isLearned: boolean | null
    learnedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerSkillCountAggregateOutputType = {
    id: number
    playerId: number
    skillId: number
    level: number
    isLearned: number
    learnedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerSkillAvgAggregateInputType = {
    level?: true
  }

  export type PlayerSkillSumAggregateInputType = {
    level?: true
  }

  export type PlayerSkillMinAggregateInputType = {
    id?: true
    playerId?: true
    skillId?: true
    level?: true
    isLearned?: true
    learnedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerSkillMaxAggregateInputType = {
    id?: true
    playerId?: true
    skillId?: true
    level?: true
    isLearned?: true
    learnedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerSkillCountAggregateInputType = {
    id?: true
    playerId?: true
    skillId?: true
    level?: true
    isLearned?: true
    learnedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerSkill to aggregate.
     */
    where?: PlayerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkills to fetch.
     */
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerSkills
    **/
    _count?: true | PlayerSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerSkillMaxAggregateInputType
  }

  export type GetPlayerSkillAggregateType<T extends PlayerSkillAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerSkill[P]>
      : GetScalarType<T[P], AggregatePlayerSkill[P]>
  }




  export type PlayerSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerSkillWhereInput
    orderBy?: PlayerSkillOrderByWithAggregationInput | PlayerSkillOrderByWithAggregationInput[]
    by: PlayerSkillScalarFieldEnum[] | PlayerSkillScalarFieldEnum
    having?: PlayerSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerSkillCountAggregateInputType | true
    _avg?: PlayerSkillAvgAggregateInputType
    _sum?: PlayerSkillSumAggregateInputType
    _min?: PlayerSkillMinAggregateInputType
    _max?: PlayerSkillMaxAggregateInputType
  }

  export type PlayerSkillGroupByOutputType = {
    id: string
    playerId: string
    skillId: string
    level: number
    isLearned: boolean
    learnedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PlayerSkillCountAggregateOutputType | null
    _avg: PlayerSkillAvgAggregateOutputType | null
    _sum: PlayerSkillSumAggregateOutputType | null
    _min: PlayerSkillMinAggregateOutputType | null
    _max: PlayerSkillMaxAggregateOutputType | null
  }

  type GetPlayerSkillGroupByPayload<T extends PlayerSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerSkillGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerSkillGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    skillId?: boolean
    level?: boolean
    isLearned?: boolean
    learnedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerSkill"]>

  export type PlayerSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    skillId?: boolean
    level?: boolean
    isLearned?: boolean
    learnedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerSkill"]>

  export type PlayerSkillSelectScalar = {
    id?: boolean
    playerId?: boolean
    skillId?: boolean
    level?: boolean
    isLearned?: boolean
    learnedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type PlayerSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $PlayerSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerSkill"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      skillId: string
      level: number
      isLearned: boolean
      learnedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerSkill"]>
    composites: {}
  }

  type PlayerSkillGetPayload<S extends boolean | null | undefined | PlayerSkillDefaultArgs> = $Result.GetResult<Prisma.$PlayerSkillPayload, S>

  type PlayerSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerSkillCountAggregateInputType | true
    }

  export interface PlayerSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerSkill'], meta: { name: 'PlayerSkill' } }
    /**
     * Find zero or one PlayerSkill that matches the filter.
     * @param {PlayerSkillFindUniqueArgs} args - Arguments to find a PlayerSkill
     * @example
     * // Get one PlayerSkill
     * const playerSkill = await prisma.playerSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerSkillFindUniqueArgs>(args: SelectSubset<T, PlayerSkillFindUniqueArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerSkillFindUniqueOrThrowArgs} args - Arguments to find a PlayerSkill
     * @example
     * // Get one PlayerSkill
     * const playerSkill = await prisma.playerSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillFindFirstArgs} args - Arguments to find a PlayerSkill
     * @example
     * // Get one PlayerSkill
     * const playerSkill = await prisma.playerSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerSkillFindFirstArgs>(args?: SelectSubset<T, PlayerSkillFindFirstArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillFindFirstOrThrowArgs} args - Arguments to find a PlayerSkill
     * @example
     * // Get one PlayerSkill
     * const playerSkill = await prisma.playerSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerSkills
     * const playerSkills = await prisma.playerSkill.findMany()
     * 
     * // Get first 10 PlayerSkills
     * const playerSkills = await prisma.playerSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerSkillWithIdOnly = await prisma.playerSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerSkillFindManyArgs>(args?: SelectSubset<T, PlayerSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerSkill.
     * @param {PlayerSkillCreateArgs} args - Arguments to create a PlayerSkill.
     * @example
     * // Create one PlayerSkill
     * const PlayerSkill = await prisma.playerSkill.create({
     *   data: {
     *     // ... data to create a PlayerSkill
     *   }
     * })
     * 
     */
    create<T extends PlayerSkillCreateArgs>(args: SelectSubset<T, PlayerSkillCreateArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerSkills.
     * @param {PlayerSkillCreateManyArgs} args - Arguments to create many PlayerSkills.
     * @example
     * // Create many PlayerSkills
     * const playerSkill = await prisma.playerSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerSkillCreateManyArgs>(args?: SelectSubset<T, PlayerSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerSkills and returns the data saved in the database.
     * @param {PlayerSkillCreateManyAndReturnArgs} args - Arguments to create many PlayerSkills.
     * @example
     * // Create many PlayerSkills
     * const playerSkill = await prisma.playerSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerSkills and only return the `id`
     * const playerSkillWithIdOnly = await prisma.playerSkill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerSkill.
     * @param {PlayerSkillDeleteArgs} args - Arguments to delete one PlayerSkill.
     * @example
     * // Delete one PlayerSkill
     * const PlayerSkill = await prisma.playerSkill.delete({
     *   where: {
     *     // ... filter to delete one PlayerSkill
     *   }
     * })
     * 
     */
    delete<T extends PlayerSkillDeleteArgs>(args: SelectSubset<T, PlayerSkillDeleteArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerSkill.
     * @param {PlayerSkillUpdateArgs} args - Arguments to update one PlayerSkill.
     * @example
     * // Update one PlayerSkill
     * const playerSkill = await prisma.playerSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerSkillUpdateArgs>(args: SelectSubset<T, PlayerSkillUpdateArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerSkills.
     * @param {PlayerSkillDeleteManyArgs} args - Arguments to filter PlayerSkills to delete.
     * @example
     * // Delete a few PlayerSkills
     * const { count } = await prisma.playerSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerSkillDeleteManyArgs>(args?: SelectSubset<T, PlayerSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerSkills
     * const playerSkill = await prisma.playerSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerSkillUpdateManyArgs>(args: SelectSubset<T, PlayerSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerSkill.
     * @param {PlayerSkillUpsertArgs} args - Arguments to update or create a PlayerSkill.
     * @example
     * // Update or create a PlayerSkill
     * const playerSkill = await prisma.playerSkill.upsert({
     *   create: {
     *     // ... data to create a PlayerSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerSkill we want to update
     *   }
     * })
     */
    upsert<T extends PlayerSkillUpsertArgs>(args: SelectSubset<T, PlayerSkillUpsertArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillCountArgs} args - Arguments to filter PlayerSkills to count.
     * @example
     * // Count the number of PlayerSkills
     * const count = await prisma.playerSkill.count({
     *   where: {
     *     // ... the filter for the PlayerSkills we want to count
     *   }
     * })
    **/
    count<T extends PlayerSkillCountArgs>(
      args?: Subset<T, PlayerSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerSkillAggregateArgs>(args: Subset<T, PlayerSkillAggregateArgs>): Prisma.PrismaPromise<GetPlayerSkillAggregateType<T>>

    /**
     * Group by PlayerSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerSkillGroupByArgs['orderBy'] }
        : { orderBy?: PlayerSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerSkill model
   */
  readonly fields: PlayerSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerSkill model
   */ 
  interface PlayerSkillFieldRefs {
    readonly id: FieldRef<"PlayerSkill", 'String'>
    readonly playerId: FieldRef<"PlayerSkill", 'String'>
    readonly skillId: FieldRef<"PlayerSkill", 'String'>
    readonly level: FieldRef<"PlayerSkill", 'Int'>
    readonly isLearned: FieldRef<"PlayerSkill", 'Boolean'>
    readonly learnedAt: FieldRef<"PlayerSkill", 'DateTime'>
    readonly createdAt: FieldRef<"PlayerSkill", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerSkill findUnique
   */
  export type PlayerSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkill to fetch.
     */
    where: PlayerSkillWhereUniqueInput
  }

  /**
   * PlayerSkill findUniqueOrThrow
   */
  export type PlayerSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkill to fetch.
     */
    where: PlayerSkillWhereUniqueInput
  }

  /**
   * PlayerSkill findFirst
   */
  export type PlayerSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkill to fetch.
     */
    where?: PlayerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkills to fetch.
     */
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerSkills.
     */
    cursor?: PlayerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerSkills.
     */
    distinct?: PlayerSkillScalarFieldEnum | PlayerSkillScalarFieldEnum[]
  }

  /**
   * PlayerSkill findFirstOrThrow
   */
  export type PlayerSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkill to fetch.
     */
    where?: PlayerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkills to fetch.
     */
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerSkills.
     */
    cursor?: PlayerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerSkills.
     */
    distinct?: PlayerSkillScalarFieldEnum | PlayerSkillScalarFieldEnum[]
  }

  /**
   * PlayerSkill findMany
   */
  export type PlayerSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkills to fetch.
     */
    where?: PlayerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkills to fetch.
     */
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerSkills.
     */
    cursor?: PlayerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkills.
     */
    skip?: number
    distinct?: PlayerSkillScalarFieldEnum | PlayerSkillScalarFieldEnum[]
  }

  /**
   * PlayerSkill create
   */
  export type PlayerSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerSkill.
     */
    data: XOR<PlayerSkillCreateInput, PlayerSkillUncheckedCreateInput>
  }

  /**
   * PlayerSkill createMany
   */
  export type PlayerSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerSkills.
     */
    data: PlayerSkillCreateManyInput | PlayerSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerSkill createManyAndReturn
   */
  export type PlayerSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerSkills.
     */
    data: PlayerSkillCreateManyInput | PlayerSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerSkill update
   */
  export type PlayerSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerSkill.
     */
    data: XOR<PlayerSkillUpdateInput, PlayerSkillUncheckedUpdateInput>
    /**
     * Choose, which PlayerSkill to update.
     */
    where: PlayerSkillWhereUniqueInput
  }

  /**
   * PlayerSkill updateMany
   */
  export type PlayerSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerSkills.
     */
    data: XOR<PlayerSkillUpdateManyMutationInput, PlayerSkillUncheckedUpdateManyInput>
    /**
     * Filter which PlayerSkills to update
     */
    where?: PlayerSkillWhereInput
  }

  /**
   * PlayerSkill upsert
   */
  export type PlayerSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerSkill to update in case it exists.
     */
    where: PlayerSkillWhereUniqueInput
    /**
     * In case the PlayerSkill found by the `where` argument doesn't exist, create a new PlayerSkill with this data.
     */
    create: XOR<PlayerSkillCreateInput, PlayerSkillUncheckedCreateInput>
    /**
     * In case the PlayerSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerSkillUpdateInput, PlayerSkillUncheckedUpdateInput>
  }

  /**
   * PlayerSkill delete
   */
  export type PlayerSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter which PlayerSkill to delete.
     */
    where: PlayerSkillWhereUniqueInput
  }

  /**
   * PlayerSkill deleteMany
   */
  export type PlayerSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerSkills to delete
     */
    where?: PlayerSkillWhereInput
  }

  /**
   * PlayerSkill without action
   */
  export type PlayerSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
  }


  /**
   * Model TalentType
   */

  export type AggregateTalentType = {
    _count: TalentTypeCountAggregateOutputType | null
    _min: TalentTypeMinAggregateOutputType | null
    _max: TalentTypeMaxAggregateOutputType | null
  }

  export type TalentTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    icon: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TalentTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    icon: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TalentTypeCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    icon: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TalentTypeMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TalentTypeMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TalentTypeCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TalentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TalentType to aggregate.
     */
    where?: TalentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TalentTypes to fetch.
     */
    orderBy?: TalentTypeOrderByWithRelationInput | TalentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TalentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TalentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TalentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TalentTypes
    **/
    _count?: true | TalentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TalentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TalentTypeMaxAggregateInputType
  }

  export type GetTalentTypeAggregateType<T extends TalentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateTalentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTalentType[P]>
      : GetScalarType<T[P], AggregateTalentType[P]>
  }




  export type TalentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TalentTypeWhereInput
    orderBy?: TalentTypeOrderByWithAggregationInput | TalentTypeOrderByWithAggregationInput[]
    by: TalentTypeScalarFieldEnum[] | TalentTypeScalarFieldEnum
    having?: TalentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TalentTypeCountAggregateInputType | true
    _min?: TalentTypeMinAggregateInputType
    _max?: TalentTypeMaxAggregateInputType
  }

  export type TalentTypeGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    icon: string | null
    color: string | null
    createdAt: Date
    updatedAt: Date
    _count: TalentTypeCountAggregateOutputType | null
    _min: TalentTypeMinAggregateOutputType | null
    _max: TalentTypeMaxAggregateOutputType | null
  }

  type GetTalentTypeGroupByPayload<T extends TalentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TalentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TalentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TalentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], TalentTypeGroupByOutputType[P]>
        }
      >
    >


  export type TalentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    talents?: boolean | TalentType$talentsArgs<ExtArgs>
    _count?: boolean | TalentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["talentType"]>

  export type TalentTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["talentType"]>

  export type TalentTypeSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TalentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    talents?: boolean | TalentType$talentsArgs<ExtArgs>
    _count?: boolean | TalentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TalentTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TalentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TalentType"
    objects: {
      talents: Prisma.$TalentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      icon: string | null
      color: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["talentType"]>
    composites: {}
  }

  type TalentTypeGetPayload<S extends boolean | null | undefined | TalentTypeDefaultArgs> = $Result.GetResult<Prisma.$TalentTypePayload, S>

  type TalentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TalentTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TalentTypeCountAggregateInputType | true
    }

  export interface TalentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TalentType'], meta: { name: 'TalentType' } }
    /**
     * Find zero or one TalentType that matches the filter.
     * @param {TalentTypeFindUniqueArgs} args - Arguments to find a TalentType
     * @example
     * // Get one TalentType
     * const talentType = await prisma.talentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TalentTypeFindUniqueArgs>(args: SelectSubset<T, TalentTypeFindUniqueArgs<ExtArgs>>): Prisma__TalentTypeClient<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TalentType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TalentTypeFindUniqueOrThrowArgs} args - Arguments to find a TalentType
     * @example
     * // Get one TalentType
     * const talentType = await prisma.talentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TalentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, TalentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TalentTypeClient<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TalentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentTypeFindFirstArgs} args - Arguments to find a TalentType
     * @example
     * // Get one TalentType
     * const talentType = await prisma.talentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TalentTypeFindFirstArgs>(args?: SelectSubset<T, TalentTypeFindFirstArgs<ExtArgs>>): Prisma__TalentTypeClient<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TalentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentTypeFindFirstOrThrowArgs} args - Arguments to find a TalentType
     * @example
     * // Get one TalentType
     * const talentType = await prisma.talentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TalentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, TalentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TalentTypeClient<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TalentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TalentTypes
     * const talentTypes = await prisma.talentType.findMany()
     * 
     * // Get first 10 TalentTypes
     * const talentTypes = await prisma.talentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const talentTypeWithIdOnly = await prisma.talentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TalentTypeFindManyArgs>(args?: SelectSubset<T, TalentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TalentType.
     * @param {TalentTypeCreateArgs} args - Arguments to create a TalentType.
     * @example
     * // Create one TalentType
     * const TalentType = await prisma.talentType.create({
     *   data: {
     *     // ... data to create a TalentType
     *   }
     * })
     * 
     */
    create<T extends TalentTypeCreateArgs>(args: SelectSubset<T, TalentTypeCreateArgs<ExtArgs>>): Prisma__TalentTypeClient<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TalentTypes.
     * @param {TalentTypeCreateManyArgs} args - Arguments to create many TalentTypes.
     * @example
     * // Create many TalentTypes
     * const talentType = await prisma.talentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TalentTypeCreateManyArgs>(args?: SelectSubset<T, TalentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TalentTypes and returns the data saved in the database.
     * @param {TalentTypeCreateManyAndReturnArgs} args - Arguments to create many TalentTypes.
     * @example
     * // Create many TalentTypes
     * const talentType = await prisma.talentType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TalentTypes and only return the `id`
     * const talentTypeWithIdOnly = await prisma.talentType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TalentTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, TalentTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TalentType.
     * @param {TalentTypeDeleteArgs} args - Arguments to delete one TalentType.
     * @example
     * // Delete one TalentType
     * const TalentType = await prisma.talentType.delete({
     *   where: {
     *     // ... filter to delete one TalentType
     *   }
     * })
     * 
     */
    delete<T extends TalentTypeDeleteArgs>(args: SelectSubset<T, TalentTypeDeleteArgs<ExtArgs>>): Prisma__TalentTypeClient<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TalentType.
     * @param {TalentTypeUpdateArgs} args - Arguments to update one TalentType.
     * @example
     * // Update one TalentType
     * const talentType = await prisma.talentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TalentTypeUpdateArgs>(args: SelectSubset<T, TalentTypeUpdateArgs<ExtArgs>>): Prisma__TalentTypeClient<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TalentTypes.
     * @param {TalentTypeDeleteManyArgs} args - Arguments to filter TalentTypes to delete.
     * @example
     * // Delete a few TalentTypes
     * const { count } = await prisma.talentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TalentTypeDeleteManyArgs>(args?: SelectSubset<T, TalentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TalentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TalentTypes
     * const talentType = await prisma.talentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TalentTypeUpdateManyArgs>(args: SelectSubset<T, TalentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TalentType.
     * @param {TalentTypeUpsertArgs} args - Arguments to update or create a TalentType.
     * @example
     * // Update or create a TalentType
     * const talentType = await prisma.talentType.upsert({
     *   create: {
     *     // ... data to create a TalentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TalentType we want to update
     *   }
     * })
     */
    upsert<T extends TalentTypeUpsertArgs>(args: SelectSubset<T, TalentTypeUpsertArgs<ExtArgs>>): Prisma__TalentTypeClient<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TalentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentTypeCountArgs} args - Arguments to filter TalentTypes to count.
     * @example
     * // Count the number of TalentTypes
     * const count = await prisma.talentType.count({
     *   where: {
     *     // ... the filter for the TalentTypes we want to count
     *   }
     * })
    **/
    count<T extends TalentTypeCountArgs>(
      args?: Subset<T, TalentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TalentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TalentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TalentTypeAggregateArgs>(args: Subset<T, TalentTypeAggregateArgs>): Prisma.PrismaPromise<GetTalentTypeAggregateType<T>>

    /**
     * Group by TalentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TalentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TalentTypeGroupByArgs['orderBy'] }
        : { orderBy?: TalentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TalentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTalentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TalentType model
   */
  readonly fields: TalentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TalentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TalentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    talents<T extends TalentType$talentsArgs<ExtArgs> = {}>(args?: Subset<T, TalentType$talentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TalentType model
   */ 
  interface TalentTypeFieldRefs {
    readonly id: FieldRef<"TalentType", 'String'>
    readonly name: FieldRef<"TalentType", 'String'>
    readonly displayName: FieldRef<"TalentType", 'String'>
    readonly description: FieldRef<"TalentType", 'String'>
    readonly icon: FieldRef<"TalentType", 'String'>
    readonly color: FieldRef<"TalentType", 'String'>
    readonly createdAt: FieldRef<"TalentType", 'DateTime'>
    readonly updatedAt: FieldRef<"TalentType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TalentType findUnique
   */
  export type TalentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentTypeInclude<ExtArgs> | null
    /**
     * Filter, which TalentType to fetch.
     */
    where: TalentTypeWhereUniqueInput
  }

  /**
   * TalentType findUniqueOrThrow
   */
  export type TalentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentTypeInclude<ExtArgs> | null
    /**
     * Filter, which TalentType to fetch.
     */
    where: TalentTypeWhereUniqueInput
  }

  /**
   * TalentType findFirst
   */
  export type TalentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentTypeInclude<ExtArgs> | null
    /**
     * Filter, which TalentType to fetch.
     */
    where?: TalentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TalentTypes to fetch.
     */
    orderBy?: TalentTypeOrderByWithRelationInput | TalentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TalentTypes.
     */
    cursor?: TalentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TalentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TalentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TalentTypes.
     */
    distinct?: TalentTypeScalarFieldEnum | TalentTypeScalarFieldEnum[]
  }

  /**
   * TalentType findFirstOrThrow
   */
  export type TalentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentTypeInclude<ExtArgs> | null
    /**
     * Filter, which TalentType to fetch.
     */
    where?: TalentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TalentTypes to fetch.
     */
    orderBy?: TalentTypeOrderByWithRelationInput | TalentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TalentTypes.
     */
    cursor?: TalentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TalentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TalentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TalentTypes.
     */
    distinct?: TalentTypeScalarFieldEnum | TalentTypeScalarFieldEnum[]
  }

  /**
   * TalentType findMany
   */
  export type TalentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentTypeInclude<ExtArgs> | null
    /**
     * Filter, which TalentTypes to fetch.
     */
    where?: TalentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TalentTypes to fetch.
     */
    orderBy?: TalentTypeOrderByWithRelationInput | TalentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TalentTypes.
     */
    cursor?: TalentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TalentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TalentTypes.
     */
    skip?: number
    distinct?: TalentTypeScalarFieldEnum | TalentTypeScalarFieldEnum[]
  }

  /**
   * TalentType create
   */
  export type TalentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a TalentType.
     */
    data: XOR<TalentTypeCreateInput, TalentTypeUncheckedCreateInput>
  }

  /**
   * TalentType createMany
   */
  export type TalentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TalentTypes.
     */
    data: TalentTypeCreateManyInput | TalentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TalentType createManyAndReturn
   */
  export type TalentTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TalentTypes.
     */
    data: TalentTypeCreateManyInput | TalentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TalentType update
   */
  export type TalentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a TalentType.
     */
    data: XOR<TalentTypeUpdateInput, TalentTypeUncheckedUpdateInput>
    /**
     * Choose, which TalentType to update.
     */
    where: TalentTypeWhereUniqueInput
  }

  /**
   * TalentType updateMany
   */
  export type TalentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TalentTypes.
     */
    data: XOR<TalentTypeUpdateManyMutationInput, TalentTypeUncheckedUpdateManyInput>
    /**
     * Filter which TalentTypes to update
     */
    where?: TalentTypeWhereInput
  }

  /**
   * TalentType upsert
   */
  export type TalentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the TalentType to update in case it exists.
     */
    where: TalentTypeWhereUniqueInput
    /**
     * In case the TalentType found by the `where` argument doesn't exist, create a new TalentType with this data.
     */
    create: XOR<TalentTypeCreateInput, TalentTypeUncheckedCreateInput>
    /**
     * In case the TalentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TalentTypeUpdateInput, TalentTypeUncheckedUpdateInput>
  }

  /**
   * TalentType delete
   */
  export type TalentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentTypeInclude<ExtArgs> | null
    /**
     * Filter which TalentType to delete.
     */
    where: TalentTypeWhereUniqueInput
  }

  /**
   * TalentType deleteMany
   */
  export type TalentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TalentTypes to delete
     */
    where?: TalentTypeWhereInput
  }

  /**
   * TalentType.talents
   */
  export type TalentType$talentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    where?: TalentWhereInput
    orderBy?: TalentOrderByWithRelationInput | TalentOrderByWithRelationInput[]
    cursor?: TalentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TalentScalarFieldEnum | TalentScalarFieldEnum[]
  }

  /**
   * TalentType without action
   */
  export type TalentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentType
     */
    select?: TalentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentTypeInclude<ExtArgs> | null
  }


  /**
   * Model Talent
   */

  export type AggregateTalent = {
    _count: TalentCountAggregateOutputType | null
    _avg: TalentAvgAggregateOutputType | null
    _sum: TalentSumAggregateOutputType | null
    _min: TalentMinAggregateOutputType | null
    _max: TalentMaxAggregateOutputType | null
  }

  export type TalentAvgAggregateOutputType = {
    level: number | null
    maxLevel: number | null
    cost: number | null
  }

  export type TalentSumAggregateOutputType = {
    level: number | null
    maxLevel: number | null
    cost: number | null
  }

  export type TalentMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    typeId: string | null
    rarity: string | null
    level: number | null
    maxLevel: number | null
    effects: string | null
    requirements: string | null
    cost: number | null
    isActive: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TalentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    typeId: string | null
    rarity: string | null
    level: number | null
    maxLevel: number | null
    effects: string | null
    requirements: string | null
    cost: number | null
    isActive: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TalentCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    typeId: number
    rarity: number
    level: number
    maxLevel: number
    effects: number
    requirements: number
    cost: number
    isActive: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TalentAvgAggregateInputType = {
    level?: true
    maxLevel?: true
    cost?: true
  }

  export type TalentSumAggregateInputType = {
    level?: true
    maxLevel?: true
    cost?: true
  }

  export type TalentMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    typeId?: true
    rarity?: true
    level?: true
    maxLevel?: true
    effects?: true
    requirements?: true
    cost?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TalentMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    typeId?: true
    rarity?: true
    level?: true
    maxLevel?: true
    effects?: true
    requirements?: true
    cost?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TalentCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    typeId?: true
    rarity?: true
    level?: true
    maxLevel?: true
    effects?: true
    requirements?: true
    cost?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TalentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Talent to aggregate.
     */
    where?: TalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Talents to fetch.
     */
    orderBy?: TalentOrderByWithRelationInput | TalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Talents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Talents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Talents
    **/
    _count?: true | TalentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TalentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TalentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TalentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TalentMaxAggregateInputType
  }

  export type GetTalentAggregateType<T extends TalentAggregateArgs> = {
        [P in keyof T & keyof AggregateTalent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTalent[P]>
      : GetScalarType<T[P], AggregateTalent[P]>
  }




  export type TalentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TalentWhereInput
    orderBy?: TalentOrderByWithAggregationInput | TalentOrderByWithAggregationInput[]
    by: TalentScalarFieldEnum[] | TalentScalarFieldEnum
    having?: TalentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TalentCountAggregateInputType | true
    _avg?: TalentAvgAggregateInputType
    _sum?: TalentSumAggregateInputType
    _min?: TalentMinAggregateInputType
    _max?: TalentMaxAggregateInputType
  }

  export type TalentGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    typeId: string
    rarity: string
    level: number
    maxLevel: number
    effects: string | null
    requirements: string | null
    cost: number
    isActive: boolean
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: TalentCountAggregateOutputType | null
    _avg: TalentAvgAggregateOutputType | null
    _sum: TalentSumAggregateOutputType | null
    _min: TalentMinAggregateOutputType | null
    _max: TalentMaxAggregateOutputType | null
  }

  type GetTalentGroupByPayload<T extends TalentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TalentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TalentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TalentGroupByOutputType[P]>
            : GetScalarType<T[P], TalentGroupByOutputType[P]>
        }
      >
    >


  export type TalentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    typeId?: boolean
    rarity?: boolean
    level?: boolean
    maxLevel?: boolean
    effects?: boolean
    requirements?: boolean
    cost?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean | TalentTypeDefaultArgs<ExtArgs>
    playerTalents?: boolean | Talent$playerTalentsArgs<ExtArgs>
    _count?: boolean | TalentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["talent"]>

  export type TalentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    typeId?: boolean
    rarity?: boolean
    level?: boolean
    maxLevel?: boolean
    effects?: boolean
    requirements?: boolean
    cost?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean | TalentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["talent"]>

  export type TalentSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    typeId?: boolean
    rarity?: boolean
    level?: boolean
    maxLevel?: boolean
    effects?: boolean
    requirements?: boolean
    cost?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TalentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type?: boolean | TalentTypeDefaultArgs<ExtArgs>
    playerTalents?: boolean | Talent$playerTalentsArgs<ExtArgs>
    _count?: boolean | TalentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TalentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type?: boolean | TalentTypeDefaultArgs<ExtArgs>
  }

  export type $TalentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Talent"
    objects: {
      type: Prisma.$TalentTypePayload<ExtArgs>
      playerTalents: Prisma.$PlayerTalentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      typeId: string
      rarity: string
      level: number
      maxLevel: number
      effects: string | null
      requirements: string | null
      cost: number
      isActive: boolean
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["talent"]>
    composites: {}
  }

  type TalentGetPayload<S extends boolean | null | undefined | TalentDefaultArgs> = $Result.GetResult<Prisma.$TalentPayload, S>

  type TalentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TalentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TalentCountAggregateInputType | true
    }

  export interface TalentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Talent'], meta: { name: 'Talent' } }
    /**
     * Find zero or one Talent that matches the filter.
     * @param {TalentFindUniqueArgs} args - Arguments to find a Talent
     * @example
     * // Get one Talent
     * const talent = await prisma.talent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TalentFindUniqueArgs>(args: SelectSubset<T, TalentFindUniqueArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Talent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TalentFindUniqueOrThrowArgs} args - Arguments to find a Talent
     * @example
     * // Get one Talent
     * const talent = await prisma.talent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TalentFindUniqueOrThrowArgs>(args: SelectSubset<T, TalentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Talent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentFindFirstArgs} args - Arguments to find a Talent
     * @example
     * // Get one Talent
     * const talent = await prisma.talent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TalentFindFirstArgs>(args?: SelectSubset<T, TalentFindFirstArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Talent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentFindFirstOrThrowArgs} args - Arguments to find a Talent
     * @example
     * // Get one Talent
     * const talent = await prisma.talent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TalentFindFirstOrThrowArgs>(args?: SelectSubset<T, TalentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Talents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Talents
     * const talents = await prisma.talent.findMany()
     * 
     * // Get first 10 Talents
     * const talents = await prisma.talent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const talentWithIdOnly = await prisma.talent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TalentFindManyArgs>(args?: SelectSubset<T, TalentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Talent.
     * @param {TalentCreateArgs} args - Arguments to create a Talent.
     * @example
     * // Create one Talent
     * const Talent = await prisma.talent.create({
     *   data: {
     *     // ... data to create a Talent
     *   }
     * })
     * 
     */
    create<T extends TalentCreateArgs>(args: SelectSubset<T, TalentCreateArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Talents.
     * @param {TalentCreateManyArgs} args - Arguments to create many Talents.
     * @example
     * // Create many Talents
     * const talent = await prisma.talent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TalentCreateManyArgs>(args?: SelectSubset<T, TalentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Talents and returns the data saved in the database.
     * @param {TalentCreateManyAndReturnArgs} args - Arguments to create many Talents.
     * @example
     * // Create many Talents
     * const talent = await prisma.talent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Talents and only return the `id`
     * const talentWithIdOnly = await prisma.talent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TalentCreateManyAndReturnArgs>(args?: SelectSubset<T, TalentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Talent.
     * @param {TalentDeleteArgs} args - Arguments to delete one Talent.
     * @example
     * // Delete one Talent
     * const Talent = await prisma.talent.delete({
     *   where: {
     *     // ... filter to delete one Talent
     *   }
     * })
     * 
     */
    delete<T extends TalentDeleteArgs>(args: SelectSubset<T, TalentDeleteArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Talent.
     * @param {TalentUpdateArgs} args - Arguments to update one Talent.
     * @example
     * // Update one Talent
     * const talent = await prisma.talent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TalentUpdateArgs>(args: SelectSubset<T, TalentUpdateArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Talents.
     * @param {TalentDeleteManyArgs} args - Arguments to filter Talents to delete.
     * @example
     * // Delete a few Talents
     * const { count } = await prisma.talent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TalentDeleteManyArgs>(args?: SelectSubset<T, TalentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Talents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Talents
     * const talent = await prisma.talent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TalentUpdateManyArgs>(args: SelectSubset<T, TalentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Talent.
     * @param {TalentUpsertArgs} args - Arguments to update or create a Talent.
     * @example
     * // Update or create a Talent
     * const talent = await prisma.talent.upsert({
     *   create: {
     *     // ... data to create a Talent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Talent we want to update
     *   }
     * })
     */
    upsert<T extends TalentUpsertArgs>(args: SelectSubset<T, TalentUpsertArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Talents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentCountArgs} args - Arguments to filter Talents to count.
     * @example
     * // Count the number of Talents
     * const count = await prisma.talent.count({
     *   where: {
     *     // ... the filter for the Talents we want to count
     *   }
     * })
    **/
    count<T extends TalentCountArgs>(
      args?: Subset<T, TalentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TalentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Talent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TalentAggregateArgs>(args: Subset<T, TalentAggregateArgs>): Prisma.PrismaPromise<GetTalentAggregateType<T>>

    /**
     * Group by Talent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TalentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TalentGroupByArgs['orderBy'] }
        : { orderBy?: TalentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TalentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTalentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Talent model
   */
  readonly fields: TalentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Talent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TalentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    type<T extends TalentTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TalentTypeDefaultArgs<ExtArgs>>): Prisma__TalentTypeClient<$Result.GetResult<Prisma.$TalentTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    playerTalents<T extends Talent$playerTalentsArgs<ExtArgs> = {}>(args?: Subset<T, Talent$playerTalentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Talent model
   */ 
  interface TalentFieldRefs {
    readonly id: FieldRef<"Talent", 'String'>
    readonly name: FieldRef<"Talent", 'String'>
    readonly displayName: FieldRef<"Talent", 'String'>
    readonly description: FieldRef<"Talent", 'String'>
    readonly typeId: FieldRef<"Talent", 'String'>
    readonly rarity: FieldRef<"Talent", 'String'>
    readonly level: FieldRef<"Talent", 'Int'>
    readonly maxLevel: FieldRef<"Talent", 'Int'>
    readonly effects: FieldRef<"Talent", 'String'>
    readonly requirements: FieldRef<"Talent", 'String'>
    readonly cost: FieldRef<"Talent", 'Int'>
    readonly isActive: FieldRef<"Talent", 'Boolean'>
    readonly icon: FieldRef<"Talent", 'String'>
    readonly createdAt: FieldRef<"Talent", 'DateTime'>
    readonly updatedAt: FieldRef<"Talent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Talent findUnique
   */
  export type TalentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter, which Talent to fetch.
     */
    where: TalentWhereUniqueInput
  }

  /**
   * Talent findUniqueOrThrow
   */
  export type TalentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter, which Talent to fetch.
     */
    where: TalentWhereUniqueInput
  }

  /**
   * Talent findFirst
   */
  export type TalentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter, which Talent to fetch.
     */
    where?: TalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Talents to fetch.
     */
    orderBy?: TalentOrderByWithRelationInput | TalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Talents.
     */
    cursor?: TalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Talents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Talents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Talents.
     */
    distinct?: TalentScalarFieldEnum | TalentScalarFieldEnum[]
  }

  /**
   * Talent findFirstOrThrow
   */
  export type TalentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter, which Talent to fetch.
     */
    where?: TalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Talents to fetch.
     */
    orderBy?: TalentOrderByWithRelationInput | TalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Talents.
     */
    cursor?: TalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Talents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Talents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Talents.
     */
    distinct?: TalentScalarFieldEnum | TalentScalarFieldEnum[]
  }

  /**
   * Talent findMany
   */
  export type TalentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter, which Talents to fetch.
     */
    where?: TalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Talents to fetch.
     */
    orderBy?: TalentOrderByWithRelationInput | TalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Talents.
     */
    cursor?: TalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Talents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Talents.
     */
    skip?: number
    distinct?: TalentScalarFieldEnum | TalentScalarFieldEnum[]
  }

  /**
   * Talent create
   */
  export type TalentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * The data needed to create a Talent.
     */
    data: XOR<TalentCreateInput, TalentUncheckedCreateInput>
  }

  /**
   * Talent createMany
   */
  export type TalentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Talents.
     */
    data: TalentCreateManyInput | TalentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Talent createManyAndReturn
   */
  export type TalentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Talents.
     */
    data: TalentCreateManyInput | TalentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Talent update
   */
  export type TalentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * The data needed to update a Talent.
     */
    data: XOR<TalentUpdateInput, TalentUncheckedUpdateInput>
    /**
     * Choose, which Talent to update.
     */
    where: TalentWhereUniqueInput
  }

  /**
   * Talent updateMany
   */
  export type TalentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Talents.
     */
    data: XOR<TalentUpdateManyMutationInput, TalentUncheckedUpdateManyInput>
    /**
     * Filter which Talents to update
     */
    where?: TalentWhereInput
  }

  /**
   * Talent upsert
   */
  export type TalentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * The filter to search for the Talent to update in case it exists.
     */
    where: TalentWhereUniqueInput
    /**
     * In case the Talent found by the `where` argument doesn't exist, create a new Talent with this data.
     */
    create: XOR<TalentCreateInput, TalentUncheckedCreateInput>
    /**
     * In case the Talent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TalentUpdateInput, TalentUncheckedUpdateInput>
  }

  /**
   * Talent delete
   */
  export type TalentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter which Talent to delete.
     */
    where: TalentWhereUniqueInput
  }

  /**
   * Talent deleteMany
   */
  export type TalentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Talents to delete
     */
    where?: TalentWhereInput
  }

  /**
   * Talent.playerTalents
   */
  export type Talent$playerTalentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    where?: PlayerTalentWhereInput
    orderBy?: PlayerTalentOrderByWithRelationInput | PlayerTalentOrderByWithRelationInput[]
    cursor?: PlayerTalentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerTalentScalarFieldEnum | PlayerTalentScalarFieldEnum[]
  }

  /**
   * Talent without action
   */
  export type TalentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
  }


  /**
   * Model PlayerTalent
   */

  export type AggregatePlayerTalent = {
    _count: PlayerTalentCountAggregateOutputType | null
    _avg: PlayerTalentAvgAggregateOutputType | null
    _sum: PlayerTalentSumAggregateOutputType | null
    _min: PlayerTalentMinAggregateOutputType | null
    _max: PlayerTalentMaxAggregateOutputType | null
  }

  export type PlayerTalentAvgAggregateOutputType = {
    level: number | null
  }

  export type PlayerTalentSumAggregateOutputType = {
    level: number | null
  }

  export type PlayerTalentMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    talentId: string | null
    level: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerTalentMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    talentId: string | null
    level: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerTalentCountAggregateOutputType = {
    id: number
    playerId: number
    talentId: number
    level: number
    isUnlocked: number
    unlockedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerTalentAvgAggregateInputType = {
    level?: true
  }

  export type PlayerTalentSumAggregateInputType = {
    level?: true
  }

  export type PlayerTalentMinAggregateInputType = {
    id?: true
    playerId?: true
    talentId?: true
    level?: true
    isUnlocked?: true
    unlockedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerTalentMaxAggregateInputType = {
    id?: true
    playerId?: true
    talentId?: true
    level?: true
    isUnlocked?: true
    unlockedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerTalentCountAggregateInputType = {
    id?: true
    playerId?: true
    talentId?: true
    level?: true
    isUnlocked?: true
    unlockedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerTalentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerTalent to aggregate.
     */
    where?: PlayerTalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerTalents to fetch.
     */
    orderBy?: PlayerTalentOrderByWithRelationInput | PlayerTalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerTalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerTalents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerTalents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerTalents
    **/
    _count?: true | PlayerTalentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerTalentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerTalentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerTalentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerTalentMaxAggregateInputType
  }

  export type GetPlayerTalentAggregateType<T extends PlayerTalentAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerTalent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerTalent[P]>
      : GetScalarType<T[P], AggregatePlayerTalent[P]>
  }




  export type PlayerTalentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerTalentWhereInput
    orderBy?: PlayerTalentOrderByWithAggregationInput | PlayerTalentOrderByWithAggregationInput[]
    by: PlayerTalentScalarFieldEnum[] | PlayerTalentScalarFieldEnum
    having?: PlayerTalentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerTalentCountAggregateInputType | true
    _avg?: PlayerTalentAvgAggregateInputType
    _sum?: PlayerTalentSumAggregateInputType
    _min?: PlayerTalentMinAggregateInputType
    _max?: PlayerTalentMaxAggregateInputType
  }

  export type PlayerTalentGroupByOutputType = {
    id: string
    playerId: string
    talentId: string
    level: number
    isUnlocked: boolean
    unlockedAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlayerTalentCountAggregateOutputType | null
    _avg: PlayerTalentAvgAggregateOutputType | null
    _sum: PlayerTalentSumAggregateOutputType | null
    _min: PlayerTalentMinAggregateOutputType | null
    _max: PlayerTalentMaxAggregateOutputType | null
  }

  type GetPlayerTalentGroupByPayload<T extends PlayerTalentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerTalentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerTalentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerTalentGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerTalentGroupByOutputType[P]>
        }
      >
    >


  export type PlayerTalentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    talentId?: boolean
    level?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    talent?: boolean | TalentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerTalent"]>

  export type PlayerTalentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    talentId?: boolean
    level?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    talent?: boolean | TalentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerTalent"]>

  export type PlayerTalentSelectScalar = {
    id?: boolean
    playerId?: boolean
    talentId?: boolean
    level?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerTalentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    talent?: boolean | TalentDefaultArgs<ExtArgs>
  }
  export type PlayerTalentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    talent?: boolean | TalentDefaultArgs<ExtArgs>
  }

  export type $PlayerTalentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerTalent"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      talent: Prisma.$TalentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      talentId: string
      level: number
      isUnlocked: boolean
      unlockedAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerTalent"]>
    composites: {}
  }

  type PlayerTalentGetPayload<S extends boolean | null | undefined | PlayerTalentDefaultArgs> = $Result.GetResult<Prisma.$PlayerTalentPayload, S>

  type PlayerTalentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerTalentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerTalentCountAggregateInputType | true
    }

  export interface PlayerTalentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerTalent'], meta: { name: 'PlayerTalent' } }
    /**
     * Find zero or one PlayerTalent that matches the filter.
     * @param {PlayerTalentFindUniqueArgs} args - Arguments to find a PlayerTalent
     * @example
     * // Get one PlayerTalent
     * const playerTalent = await prisma.playerTalent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerTalentFindUniqueArgs>(args: SelectSubset<T, PlayerTalentFindUniqueArgs<ExtArgs>>): Prisma__PlayerTalentClient<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerTalent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerTalentFindUniqueOrThrowArgs} args - Arguments to find a PlayerTalent
     * @example
     * // Get one PlayerTalent
     * const playerTalent = await prisma.playerTalent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerTalentFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerTalentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerTalentClient<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerTalent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTalentFindFirstArgs} args - Arguments to find a PlayerTalent
     * @example
     * // Get one PlayerTalent
     * const playerTalent = await prisma.playerTalent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerTalentFindFirstArgs>(args?: SelectSubset<T, PlayerTalentFindFirstArgs<ExtArgs>>): Prisma__PlayerTalentClient<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerTalent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTalentFindFirstOrThrowArgs} args - Arguments to find a PlayerTalent
     * @example
     * // Get one PlayerTalent
     * const playerTalent = await prisma.playerTalent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerTalentFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerTalentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerTalentClient<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerTalents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTalentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerTalents
     * const playerTalents = await prisma.playerTalent.findMany()
     * 
     * // Get first 10 PlayerTalents
     * const playerTalents = await prisma.playerTalent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerTalentWithIdOnly = await prisma.playerTalent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerTalentFindManyArgs>(args?: SelectSubset<T, PlayerTalentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerTalent.
     * @param {PlayerTalentCreateArgs} args - Arguments to create a PlayerTalent.
     * @example
     * // Create one PlayerTalent
     * const PlayerTalent = await prisma.playerTalent.create({
     *   data: {
     *     // ... data to create a PlayerTalent
     *   }
     * })
     * 
     */
    create<T extends PlayerTalentCreateArgs>(args: SelectSubset<T, PlayerTalentCreateArgs<ExtArgs>>): Prisma__PlayerTalentClient<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerTalents.
     * @param {PlayerTalentCreateManyArgs} args - Arguments to create many PlayerTalents.
     * @example
     * // Create many PlayerTalents
     * const playerTalent = await prisma.playerTalent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerTalentCreateManyArgs>(args?: SelectSubset<T, PlayerTalentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerTalents and returns the data saved in the database.
     * @param {PlayerTalentCreateManyAndReturnArgs} args - Arguments to create many PlayerTalents.
     * @example
     * // Create many PlayerTalents
     * const playerTalent = await prisma.playerTalent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerTalents and only return the `id`
     * const playerTalentWithIdOnly = await prisma.playerTalent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerTalentCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerTalentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerTalent.
     * @param {PlayerTalentDeleteArgs} args - Arguments to delete one PlayerTalent.
     * @example
     * // Delete one PlayerTalent
     * const PlayerTalent = await prisma.playerTalent.delete({
     *   where: {
     *     // ... filter to delete one PlayerTalent
     *   }
     * })
     * 
     */
    delete<T extends PlayerTalentDeleteArgs>(args: SelectSubset<T, PlayerTalentDeleteArgs<ExtArgs>>): Prisma__PlayerTalentClient<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerTalent.
     * @param {PlayerTalentUpdateArgs} args - Arguments to update one PlayerTalent.
     * @example
     * // Update one PlayerTalent
     * const playerTalent = await prisma.playerTalent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerTalentUpdateArgs>(args: SelectSubset<T, PlayerTalentUpdateArgs<ExtArgs>>): Prisma__PlayerTalentClient<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerTalents.
     * @param {PlayerTalentDeleteManyArgs} args - Arguments to filter PlayerTalents to delete.
     * @example
     * // Delete a few PlayerTalents
     * const { count } = await prisma.playerTalent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerTalentDeleteManyArgs>(args?: SelectSubset<T, PlayerTalentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerTalents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTalentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerTalents
     * const playerTalent = await prisma.playerTalent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerTalentUpdateManyArgs>(args: SelectSubset<T, PlayerTalentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerTalent.
     * @param {PlayerTalentUpsertArgs} args - Arguments to update or create a PlayerTalent.
     * @example
     * // Update or create a PlayerTalent
     * const playerTalent = await prisma.playerTalent.upsert({
     *   create: {
     *     // ... data to create a PlayerTalent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerTalent we want to update
     *   }
     * })
     */
    upsert<T extends PlayerTalentUpsertArgs>(args: SelectSubset<T, PlayerTalentUpsertArgs<ExtArgs>>): Prisma__PlayerTalentClient<$Result.GetResult<Prisma.$PlayerTalentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerTalents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTalentCountArgs} args - Arguments to filter PlayerTalents to count.
     * @example
     * // Count the number of PlayerTalents
     * const count = await prisma.playerTalent.count({
     *   where: {
     *     // ... the filter for the PlayerTalents we want to count
     *   }
     * })
    **/
    count<T extends PlayerTalentCountArgs>(
      args?: Subset<T, PlayerTalentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerTalentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerTalent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTalentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerTalentAggregateArgs>(args: Subset<T, PlayerTalentAggregateArgs>): Prisma.PrismaPromise<GetPlayerTalentAggregateType<T>>

    /**
     * Group by PlayerTalent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTalentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerTalentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerTalentGroupByArgs['orderBy'] }
        : { orderBy?: PlayerTalentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerTalentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerTalentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerTalent model
   */
  readonly fields: PlayerTalentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerTalent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerTalentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    talent<T extends TalentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TalentDefaultArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerTalent model
   */ 
  interface PlayerTalentFieldRefs {
    readonly id: FieldRef<"PlayerTalent", 'String'>
    readonly playerId: FieldRef<"PlayerTalent", 'String'>
    readonly talentId: FieldRef<"PlayerTalent", 'String'>
    readonly level: FieldRef<"PlayerTalent", 'Int'>
    readonly isUnlocked: FieldRef<"PlayerTalent", 'Boolean'>
    readonly unlockedAt: FieldRef<"PlayerTalent", 'DateTime'>
    readonly isActive: FieldRef<"PlayerTalent", 'Boolean'>
    readonly createdAt: FieldRef<"PlayerTalent", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerTalent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerTalent findUnique
   */
  export type PlayerTalentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerTalent to fetch.
     */
    where: PlayerTalentWhereUniqueInput
  }

  /**
   * PlayerTalent findUniqueOrThrow
   */
  export type PlayerTalentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerTalent to fetch.
     */
    where: PlayerTalentWhereUniqueInput
  }

  /**
   * PlayerTalent findFirst
   */
  export type PlayerTalentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerTalent to fetch.
     */
    where?: PlayerTalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerTalents to fetch.
     */
    orderBy?: PlayerTalentOrderByWithRelationInput | PlayerTalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerTalents.
     */
    cursor?: PlayerTalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerTalents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerTalents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerTalents.
     */
    distinct?: PlayerTalentScalarFieldEnum | PlayerTalentScalarFieldEnum[]
  }

  /**
   * PlayerTalent findFirstOrThrow
   */
  export type PlayerTalentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerTalent to fetch.
     */
    where?: PlayerTalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerTalents to fetch.
     */
    orderBy?: PlayerTalentOrderByWithRelationInput | PlayerTalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerTalents.
     */
    cursor?: PlayerTalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerTalents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerTalents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerTalents.
     */
    distinct?: PlayerTalentScalarFieldEnum | PlayerTalentScalarFieldEnum[]
  }

  /**
   * PlayerTalent findMany
   */
  export type PlayerTalentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerTalents to fetch.
     */
    where?: PlayerTalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerTalents to fetch.
     */
    orderBy?: PlayerTalentOrderByWithRelationInput | PlayerTalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerTalents.
     */
    cursor?: PlayerTalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerTalents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerTalents.
     */
    skip?: number
    distinct?: PlayerTalentScalarFieldEnum | PlayerTalentScalarFieldEnum[]
  }

  /**
   * PlayerTalent create
   */
  export type PlayerTalentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerTalent.
     */
    data: XOR<PlayerTalentCreateInput, PlayerTalentUncheckedCreateInput>
  }

  /**
   * PlayerTalent createMany
   */
  export type PlayerTalentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerTalents.
     */
    data: PlayerTalentCreateManyInput | PlayerTalentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerTalent createManyAndReturn
   */
  export type PlayerTalentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerTalents.
     */
    data: PlayerTalentCreateManyInput | PlayerTalentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerTalent update
   */
  export type PlayerTalentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerTalent.
     */
    data: XOR<PlayerTalentUpdateInput, PlayerTalentUncheckedUpdateInput>
    /**
     * Choose, which PlayerTalent to update.
     */
    where: PlayerTalentWhereUniqueInput
  }

  /**
   * PlayerTalent updateMany
   */
  export type PlayerTalentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerTalents.
     */
    data: XOR<PlayerTalentUpdateManyMutationInput, PlayerTalentUncheckedUpdateManyInput>
    /**
     * Filter which PlayerTalents to update
     */
    where?: PlayerTalentWhereInput
  }

  /**
   * PlayerTalent upsert
   */
  export type PlayerTalentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerTalent to update in case it exists.
     */
    where: PlayerTalentWhereUniqueInput
    /**
     * In case the PlayerTalent found by the `where` argument doesn't exist, create a new PlayerTalent with this data.
     */
    create: XOR<PlayerTalentCreateInput, PlayerTalentUncheckedCreateInput>
    /**
     * In case the PlayerTalent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerTalentUpdateInput, PlayerTalentUncheckedUpdateInput>
  }

  /**
   * PlayerTalent delete
   */
  export type PlayerTalentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
    /**
     * Filter which PlayerTalent to delete.
     */
    where: PlayerTalentWhereUniqueInput
  }

  /**
   * PlayerTalent deleteMany
   */
  export type PlayerTalentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerTalents to delete
     */
    where?: PlayerTalentWhereInput
  }

  /**
   * PlayerTalent without action
   */
  export type PlayerTalentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTalent
     */
    select?: PlayerTalentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTalentInclude<ExtArgs> | null
  }


  /**
   * Model Buff
   */

  export type AggregateBuff = {
    _count: BuffCountAggregateOutputType | null
    _avg: BuffAvgAggregateOutputType | null
    _sum: BuffSumAggregateOutputType | null
    _min: BuffMinAggregateOutputType | null
    _max: BuffMaxAggregateOutputType | null
  }

  export type BuffAvgAggregateOutputType = {
    duration: number | null
  }

  export type BuffSumAggregateOutputType = {
    duration: number | null
  }

  export type BuffMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    type: string | null
    category: string | null
    effects: string | null
    duration: number | null
    stackable: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuffMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    type: string | null
    category: string | null
    effects: string | null
    duration: number | null
    stackable: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuffCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    type: number
    category: number
    effects: number
    duration: number
    stackable: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuffAvgAggregateInputType = {
    duration?: true
  }

  export type BuffSumAggregateInputType = {
    duration?: true
  }

  export type BuffMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    type?: true
    category?: true
    effects?: true
    duration?: true
    stackable?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuffMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    type?: true
    category?: true
    effects?: true
    duration?: true
    stackable?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuffCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    type?: true
    category?: true
    effects?: true
    duration?: true
    stackable?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buff to aggregate.
     */
    where?: BuffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buffs to fetch.
     */
    orderBy?: BuffOrderByWithRelationInput | BuffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Buffs
    **/
    _count?: true | BuffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuffMaxAggregateInputType
  }

  export type GetBuffAggregateType<T extends BuffAggregateArgs> = {
        [P in keyof T & keyof AggregateBuff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuff[P]>
      : GetScalarType<T[P], AggregateBuff[P]>
  }




  export type BuffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffWhereInput
    orderBy?: BuffOrderByWithAggregationInput | BuffOrderByWithAggregationInput[]
    by: BuffScalarFieldEnum[] | BuffScalarFieldEnum
    having?: BuffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuffCountAggregateInputType | true
    _avg?: BuffAvgAggregateInputType
    _sum?: BuffSumAggregateInputType
    _min?: BuffMinAggregateInputType
    _max?: BuffMaxAggregateInputType
  }

  export type BuffGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    type: string
    category: string
    effects: string | null
    duration: number
    stackable: boolean
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: BuffCountAggregateOutputType | null
    _avg: BuffAvgAggregateOutputType | null
    _sum: BuffSumAggregateOutputType | null
    _min: BuffMinAggregateOutputType | null
    _max: BuffMaxAggregateOutputType | null
  }

  type GetBuffGroupByPayload<T extends BuffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuffGroupByOutputType[P]>
            : GetScalarType<T[P], BuffGroupByOutputType[P]>
        }
      >
    >


  export type BuffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    effects?: boolean
    duration?: boolean
    stackable?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playerBuffs?: boolean | Buff$playerBuffsArgs<ExtArgs>
    _count?: boolean | BuffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buff"]>

  export type BuffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    effects?: boolean
    duration?: boolean
    stackable?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["buff"]>

  export type BuffSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    effects?: boolean
    duration?: boolean
    stackable?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerBuffs?: boolean | Buff$playerBuffsArgs<ExtArgs>
    _count?: boolean | BuffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BuffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BuffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Buff"
    objects: {
      playerBuffs: Prisma.$PlayerBuffPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      type: string
      category: string
      effects: string | null
      duration: number
      stackable: boolean
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["buff"]>
    composites: {}
  }

  type BuffGetPayload<S extends boolean | null | undefined | BuffDefaultArgs> = $Result.GetResult<Prisma.$BuffPayload, S>

  type BuffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuffCountAggregateInputType | true
    }

  export interface BuffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Buff'], meta: { name: 'Buff' } }
    /**
     * Find zero or one Buff that matches the filter.
     * @param {BuffFindUniqueArgs} args - Arguments to find a Buff
     * @example
     * // Get one Buff
     * const buff = await prisma.buff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuffFindUniqueArgs>(args: SelectSubset<T, BuffFindUniqueArgs<ExtArgs>>): Prisma__BuffClient<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Buff that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuffFindUniqueOrThrowArgs} args - Arguments to find a Buff
     * @example
     * // Get one Buff
     * const buff = await prisma.buff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuffFindUniqueOrThrowArgs>(args: SelectSubset<T, BuffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuffClient<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Buff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffFindFirstArgs} args - Arguments to find a Buff
     * @example
     * // Get one Buff
     * const buff = await prisma.buff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuffFindFirstArgs>(args?: SelectSubset<T, BuffFindFirstArgs<ExtArgs>>): Prisma__BuffClient<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Buff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffFindFirstOrThrowArgs} args - Arguments to find a Buff
     * @example
     * // Get one Buff
     * const buff = await prisma.buff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuffFindFirstOrThrowArgs>(args?: SelectSubset<T, BuffFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuffClient<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Buffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buffs
     * const buffs = await prisma.buff.findMany()
     * 
     * // Get first 10 Buffs
     * const buffs = await prisma.buff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buffWithIdOnly = await prisma.buff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuffFindManyArgs>(args?: SelectSubset<T, BuffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Buff.
     * @param {BuffCreateArgs} args - Arguments to create a Buff.
     * @example
     * // Create one Buff
     * const Buff = await prisma.buff.create({
     *   data: {
     *     // ... data to create a Buff
     *   }
     * })
     * 
     */
    create<T extends BuffCreateArgs>(args: SelectSubset<T, BuffCreateArgs<ExtArgs>>): Prisma__BuffClient<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Buffs.
     * @param {BuffCreateManyArgs} args - Arguments to create many Buffs.
     * @example
     * // Create many Buffs
     * const buff = await prisma.buff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuffCreateManyArgs>(args?: SelectSubset<T, BuffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Buffs and returns the data saved in the database.
     * @param {BuffCreateManyAndReturnArgs} args - Arguments to create many Buffs.
     * @example
     * // Create many Buffs
     * const buff = await prisma.buff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Buffs and only return the `id`
     * const buffWithIdOnly = await prisma.buff.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuffCreateManyAndReturnArgs>(args?: SelectSubset<T, BuffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Buff.
     * @param {BuffDeleteArgs} args - Arguments to delete one Buff.
     * @example
     * // Delete one Buff
     * const Buff = await prisma.buff.delete({
     *   where: {
     *     // ... filter to delete one Buff
     *   }
     * })
     * 
     */
    delete<T extends BuffDeleteArgs>(args: SelectSubset<T, BuffDeleteArgs<ExtArgs>>): Prisma__BuffClient<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Buff.
     * @param {BuffUpdateArgs} args - Arguments to update one Buff.
     * @example
     * // Update one Buff
     * const buff = await prisma.buff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuffUpdateArgs>(args: SelectSubset<T, BuffUpdateArgs<ExtArgs>>): Prisma__BuffClient<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Buffs.
     * @param {BuffDeleteManyArgs} args - Arguments to filter Buffs to delete.
     * @example
     * // Delete a few Buffs
     * const { count } = await prisma.buff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuffDeleteManyArgs>(args?: SelectSubset<T, BuffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buffs
     * const buff = await prisma.buff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuffUpdateManyArgs>(args: SelectSubset<T, BuffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Buff.
     * @param {BuffUpsertArgs} args - Arguments to update or create a Buff.
     * @example
     * // Update or create a Buff
     * const buff = await prisma.buff.upsert({
     *   create: {
     *     // ... data to create a Buff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Buff we want to update
     *   }
     * })
     */
    upsert<T extends BuffUpsertArgs>(args: SelectSubset<T, BuffUpsertArgs<ExtArgs>>): Prisma__BuffClient<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Buffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffCountArgs} args - Arguments to filter Buffs to count.
     * @example
     * // Count the number of Buffs
     * const count = await prisma.buff.count({
     *   where: {
     *     // ... the filter for the Buffs we want to count
     *   }
     * })
    **/
    count<T extends BuffCountArgs>(
      args?: Subset<T, BuffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Buff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuffAggregateArgs>(args: Subset<T, BuffAggregateArgs>): Prisma.PrismaPromise<GetBuffAggregateType<T>>

    /**
     * Group by Buff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuffGroupByArgs['orderBy'] }
        : { orderBy?: BuffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Buff model
   */
  readonly fields: BuffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Buff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playerBuffs<T extends Buff$playerBuffsArgs<ExtArgs> = {}>(args?: Subset<T, Buff$playerBuffsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Buff model
   */ 
  interface BuffFieldRefs {
    readonly id: FieldRef<"Buff", 'String'>
    readonly name: FieldRef<"Buff", 'String'>
    readonly displayName: FieldRef<"Buff", 'String'>
    readonly description: FieldRef<"Buff", 'String'>
    readonly type: FieldRef<"Buff", 'String'>
    readonly category: FieldRef<"Buff", 'String'>
    readonly effects: FieldRef<"Buff", 'String'>
    readonly duration: FieldRef<"Buff", 'Int'>
    readonly stackable: FieldRef<"Buff", 'Boolean'>
    readonly icon: FieldRef<"Buff", 'String'>
    readonly createdAt: FieldRef<"Buff", 'DateTime'>
    readonly updatedAt: FieldRef<"Buff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Buff findUnique
   */
  export type BuffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffInclude<ExtArgs> | null
    /**
     * Filter, which Buff to fetch.
     */
    where: BuffWhereUniqueInput
  }

  /**
   * Buff findUniqueOrThrow
   */
  export type BuffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffInclude<ExtArgs> | null
    /**
     * Filter, which Buff to fetch.
     */
    where: BuffWhereUniqueInput
  }

  /**
   * Buff findFirst
   */
  export type BuffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffInclude<ExtArgs> | null
    /**
     * Filter, which Buff to fetch.
     */
    where?: BuffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buffs to fetch.
     */
    orderBy?: BuffOrderByWithRelationInput | BuffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buffs.
     */
    cursor?: BuffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buffs.
     */
    distinct?: BuffScalarFieldEnum | BuffScalarFieldEnum[]
  }

  /**
   * Buff findFirstOrThrow
   */
  export type BuffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffInclude<ExtArgs> | null
    /**
     * Filter, which Buff to fetch.
     */
    where?: BuffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buffs to fetch.
     */
    orderBy?: BuffOrderByWithRelationInput | BuffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buffs.
     */
    cursor?: BuffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buffs.
     */
    distinct?: BuffScalarFieldEnum | BuffScalarFieldEnum[]
  }

  /**
   * Buff findMany
   */
  export type BuffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffInclude<ExtArgs> | null
    /**
     * Filter, which Buffs to fetch.
     */
    where?: BuffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buffs to fetch.
     */
    orderBy?: BuffOrderByWithRelationInput | BuffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Buffs.
     */
    cursor?: BuffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buffs.
     */
    skip?: number
    distinct?: BuffScalarFieldEnum | BuffScalarFieldEnum[]
  }

  /**
   * Buff create
   */
  export type BuffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffInclude<ExtArgs> | null
    /**
     * The data needed to create a Buff.
     */
    data: XOR<BuffCreateInput, BuffUncheckedCreateInput>
  }

  /**
   * Buff createMany
   */
  export type BuffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Buffs.
     */
    data: BuffCreateManyInput | BuffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Buff createManyAndReturn
   */
  export type BuffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Buffs.
     */
    data: BuffCreateManyInput | BuffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Buff update
   */
  export type BuffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffInclude<ExtArgs> | null
    /**
     * The data needed to update a Buff.
     */
    data: XOR<BuffUpdateInput, BuffUncheckedUpdateInput>
    /**
     * Choose, which Buff to update.
     */
    where: BuffWhereUniqueInput
  }

  /**
   * Buff updateMany
   */
  export type BuffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Buffs.
     */
    data: XOR<BuffUpdateManyMutationInput, BuffUncheckedUpdateManyInput>
    /**
     * Filter which Buffs to update
     */
    where?: BuffWhereInput
  }

  /**
   * Buff upsert
   */
  export type BuffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffInclude<ExtArgs> | null
    /**
     * The filter to search for the Buff to update in case it exists.
     */
    where: BuffWhereUniqueInput
    /**
     * In case the Buff found by the `where` argument doesn't exist, create a new Buff with this data.
     */
    create: XOR<BuffCreateInput, BuffUncheckedCreateInput>
    /**
     * In case the Buff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuffUpdateInput, BuffUncheckedUpdateInput>
  }

  /**
   * Buff delete
   */
  export type BuffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffInclude<ExtArgs> | null
    /**
     * Filter which Buff to delete.
     */
    where: BuffWhereUniqueInput
  }

  /**
   * Buff deleteMany
   */
  export type BuffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buffs to delete
     */
    where?: BuffWhereInput
  }

  /**
   * Buff.playerBuffs
   */
  export type Buff$playerBuffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    where?: PlayerBuffWhereInput
    orderBy?: PlayerBuffOrderByWithRelationInput | PlayerBuffOrderByWithRelationInput[]
    cursor?: PlayerBuffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerBuffScalarFieldEnum | PlayerBuffScalarFieldEnum[]
  }

  /**
   * Buff without action
   */
  export type BuffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buff
     */
    select?: BuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffInclude<ExtArgs> | null
  }


  /**
   * Model PlayerBuff
   */

  export type AggregatePlayerBuff = {
    _count: PlayerBuffCountAggregateOutputType | null
    _avg: PlayerBuffAvgAggregateOutputType | null
    _sum: PlayerBuffSumAggregateOutputType | null
    _min: PlayerBuffMinAggregateOutputType | null
    _max: PlayerBuffMaxAggregateOutputType | null
  }

  export type PlayerBuffAvgAggregateOutputType = {
    level: number | null
    stacks: number | null
  }

  export type PlayerBuffSumAggregateOutputType = {
    level: number | null
    stacks: number | null
  }

  export type PlayerBuffMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    buffId: string | null
    level: number | null
    stacks: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerBuffMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    buffId: string | null
    level: number | null
    stacks: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerBuffCountAggregateOutputType = {
    id: number
    playerId: number
    buffId: number
    level: number
    stacks: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerBuffAvgAggregateInputType = {
    level?: true
    stacks?: true
  }

  export type PlayerBuffSumAggregateInputType = {
    level?: true
    stacks?: true
  }

  export type PlayerBuffMinAggregateInputType = {
    id?: true
    playerId?: true
    buffId?: true
    level?: true
    stacks?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerBuffMaxAggregateInputType = {
    id?: true
    playerId?: true
    buffId?: true
    level?: true
    stacks?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerBuffCountAggregateInputType = {
    id?: true
    playerId?: true
    buffId?: true
    level?: true
    stacks?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerBuffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerBuff to aggregate.
     */
    where?: PlayerBuffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerBuffs to fetch.
     */
    orderBy?: PlayerBuffOrderByWithRelationInput | PlayerBuffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerBuffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerBuffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerBuffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerBuffs
    **/
    _count?: true | PlayerBuffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerBuffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerBuffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerBuffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerBuffMaxAggregateInputType
  }

  export type GetPlayerBuffAggregateType<T extends PlayerBuffAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerBuff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerBuff[P]>
      : GetScalarType<T[P], AggregatePlayerBuff[P]>
  }




  export type PlayerBuffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerBuffWhereInput
    orderBy?: PlayerBuffOrderByWithAggregationInput | PlayerBuffOrderByWithAggregationInput[]
    by: PlayerBuffScalarFieldEnum[] | PlayerBuffScalarFieldEnum
    having?: PlayerBuffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerBuffCountAggregateInputType | true
    _avg?: PlayerBuffAvgAggregateInputType
    _sum?: PlayerBuffSumAggregateInputType
    _min?: PlayerBuffMinAggregateInputType
    _max?: PlayerBuffMaxAggregateInputType
  }

  export type PlayerBuffGroupByOutputType = {
    id: string
    playerId: string
    buffId: string
    level: number
    stacks: number
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PlayerBuffCountAggregateOutputType | null
    _avg: PlayerBuffAvgAggregateOutputType | null
    _sum: PlayerBuffSumAggregateOutputType | null
    _min: PlayerBuffMinAggregateOutputType | null
    _max: PlayerBuffMaxAggregateOutputType | null
  }

  type GetPlayerBuffGroupByPayload<T extends PlayerBuffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerBuffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerBuffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerBuffGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerBuffGroupByOutputType[P]>
        }
      >
    >


  export type PlayerBuffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    buffId?: boolean
    level?: boolean
    stacks?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    buff?: boolean | BuffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerBuff"]>

  export type PlayerBuffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    buffId?: boolean
    level?: boolean
    stacks?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    buff?: boolean | BuffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerBuff"]>

  export type PlayerBuffSelectScalar = {
    id?: boolean
    playerId?: boolean
    buffId?: boolean
    level?: boolean
    stacks?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerBuffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    buff?: boolean | BuffDefaultArgs<ExtArgs>
  }
  export type PlayerBuffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    buff?: boolean | BuffDefaultArgs<ExtArgs>
  }

  export type $PlayerBuffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerBuff"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      buff: Prisma.$BuffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      buffId: string
      level: number
      stacks: number
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerBuff"]>
    composites: {}
  }

  type PlayerBuffGetPayload<S extends boolean | null | undefined | PlayerBuffDefaultArgs> = $Result.GetResult<Prisma.$PlayerBuffPayload, S>

  type PlayerBuffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerBuffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerBuffCountAggregateInputType | true
    }

  export interface PlayerBuffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerBuff'], meta: { name: 'PlayerBuff' } }
    /**
     * Find zero or one PlayerBuff that matches the filter.
     * @param {PlayerBuffFindUniqueArgs} args - Arguments to find a PlayerBuff
     * @example
     * // Get one PlayerBuff
     * const playerBuff = await prisma.playerBuff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerBuffFindUniqueArgs>(args: SelectSubset<T, PlayerBuffFindUniqueArgs<ExtArgs>>): Prisma__PlayerBuffClient<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerBuff that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerBuffFindUniqueOrThrowArgs} args - Arguments to find a PlayerBuff
     * @example
     * // Get one PlayerBuff
     * const playerBuff = await prisma.playerBuff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerBuffFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerBuffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerBuffClient<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerBuff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBuffFindFirstArgs} args - Arguments to find a PlayerBuff
     * @example
     * // Get one PlayerBuff
     * const playerBuff = await prisma.playerBuff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerBuffFindFirstArgs>(args?: SelectSubset<T, PlayerBuffFindFirstArgs<ExtArgs>>): Prisma__PlayerBuffClient<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerBuff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBuffFindFirstOrThrowArgs} args - Arguments to find a PlayerBuff
     * @example
     * // Get one PlayerBuff
     * const playerBuff = await prisma.playerBuff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerBuffFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerBuffFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerBuffClient<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerBuffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBuffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerBuffs
     * const playerBuffs = await prisma.playerBuff.findMany()
     * 
     * // Get first 10 PlayerBuffs
     * const playerBuffs = await prisma.playerBuff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerBuffWithIdOnly = await prisma.playerBuff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerBuffFindManyArgs>(args?: SelectSubset<T, PlayerBuffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerBuff.
     * @param {PlayerBuffCreateArgs} args - Arguments to create a PlayerBuff.
     * @example
     * // Create one PlayerBuff
     * const PlayerBuff = await prisma.playerBuff.create({
     *   data: {
     *     // ... data to create a PlayerBuff
     *   }
     * })
     * 
     */
    create<T extends PlayerBuffCreateArgs>(args: SelectSubset<T, PlayerBuffCreateArgs<ExtArgs>>): Prisma__PlayerBuffClient<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerBuffs.
     * @param {PlayerBuffCreateManyArgs} args - Arguments to create many PlayerBuffs.
     * @example
     * // Create many PlayerBuffs
     * const playerBuff = await prisma.playerBuff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerBuffCreateManyArgs>(args?: SelectSubset<T, PlayerBuffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerBuffs and returns the data saved in the database.
     * @param {PlayerBuffCreateManyAndReturnArgs} args - Arguments to create many PlayerBuffs.
     * @example
     * // Create many PlayerBuffs
     * const playerBuff = await prisma.playerBuff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerBuffs and only return the `id`
     * const playerBuffWithIdOnly = await prisma.playerBuff.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerBuffCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerBuffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerBuff.
     * @param {PlayerBuffDeleteArgs} args - Arguments to delete one PlayerBuff.
     * @example
     * // Delete one PlayerBuff
     * const PlayerBuff = await prisma.playerBuff.delete({
     *   where: {
     *     // ... filter to delete one PlayerBuff
     *   }
     * })
     * 
     */
    delete<T extends PlayerBuffDeleteArgs>(args: SelectSubset<T, PlayerBuffDeleteArgs<ExtArgs>>): Prisma__PlayerBuffClient<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerBuff.
     * @param {PlayerBuffUpdateArgs} args - Arguments to update one PlayerBuff.
     * @example
     * // Update one PlayerBuff
     * const playerBuff = await prisma.playerBuff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerBuffUpdateArgs>(args: SelectSubset<T, PlayerBuffUpdateArgs<ExtArgs>>): Prisma__PlayerBuffClient<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerBuffs.
     * @param {PlayerBuffDeleteManyArgs} args - Arguments to filter PlayerBuffs to delete.
     * @example
     * // Delete a few PlayerBuffs
     * const { count } = await prisma.playerBuff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerBuffDeleteManyArgs>(args?: SelectSubset<T, PlayerBuffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerBuffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBuffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerBuffs
     * const playerBuff = await prisma.playerBuff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerBuffUpdateManyArgs>(args: SelectSubset<T, PlayerBuffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerBuff.
     * @param {PlayerBuffUpsertArgs} args - Arguments to update or create a PlayerBuff.
     * @example
     * // Update or create a PlayerBuff
     * const playerBuff = await prisma.playerBuff.upsert({
     *   create: {
     *     // ... data to create a PlayerBuff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerBuff we want to update
     *   }
     * })
     */
    upsert<T extends PlayerBuffUpsertArgs>(args: SelectSubset<T, PlayerBuffUpsertArgs<ExtArgs>>): Prisma__PlayerBuffClient<$Result.GetResult<Prisma.$PlayerBuffPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerBuffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBuffCountArgs} args - Arguments to filter PlayerBuffs to count.
     * @example
     * // Count the number of PlayerBuffs
     * const count = await prisma.playerBuff.count({
     *   where: {
     *     // ... the filter for the PlayerBuffs we want to count
     *   }
     * })
    **/
    count<T extends PlayerBuffCountArgs>(
      args?: Subset<T, PlayerBuffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerBuffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerBuff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBuffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerBuffAggregateArgs>(args: Subset<T, PlayerBuffAggregateArgs>): Prisma.PrismaPromise<GetPlayerBuffAggregateType<T>>

    /**
     * Group by PlayerBuff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBuffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerBuffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerBuffGroupByArgs['orderBy'] }
        : { orderBy?: PlayerBuffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerBuffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerBuffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerBuff model
   */
  readonly fields: PlayerBuffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerBuff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerBuffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    buff<T extends BuffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuffDefaultArgs<ExtArgs>>): Prisma__BuffClient<$Result.GetResult<Prisma.$BuffPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerBuff model
   */ 
  interface PlayerBuffFieldRefs {
    readonly id: FieldRef<"PlayerBuff", 'String'>
    readonly playerId: FieldRef<"PlayerBuff", 'String'>
    readonly buffId: FieldRef<"PlayerBuff", 'String'>
    readonly level: FieldRef<"PlayerBuff", 'Int'>
    readonly stacks: FieldRef<"PlayerBuff", 'Int'>
    readonly expiresAt: FieldRef<"PlayerBuff", 'DateTime'>
    readonly createdAt: FieldRef<"PlayerBuff", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerBuff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerBuff findUnique
   */
  export type PlayerBuffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    /**
     * Filter, which PlayerBuff to fetch.
     */
    where: PlayerBuffWhereUniqueInput
  }

  /**
   * PlayerBuff findUniqueOrThrow
   */
  export type PlayerBuffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    /**
     * Filter, which PlayerBuff to fetch.
     */
    where: PlayerBuffWhereUniqueInput
  }

  /**
   * PlayerBuff findFirst
   */
  export type PlayerBuffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    /**
     * Filter, which PlayerBuff to fetch.
     */
    where?: PlayerBuffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerBuffs to fetch.
     */
    orderBy?: PlayerBuffOrderByWithRelationInput | PlayerBuffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerBuffs.
     */
    cursor?: PlayerBuffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerBuffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerBuffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerBuffs.
     */
    distinct?: PlayerBuffScalarFieldEnum | PlayerBuffScalarFieldEnum[]
  }

  /**
   * PlayerBuff findFirstOrThrow
   */
  export type PlayerBuffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    /**
     * Filter, which PlayerBuff to fetch.
     */
    where?: PlayerBuffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerBuffs to fetch.
     */
    orderBy?: PlayerBuffOrderByWithRelationInput | PlayerBuffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerBuffs.
     */
    cursor?: PlayerBuffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerBuffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerBuffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerBuffs.
     */
    distinct?: PlayerBuffScalarFieldEnum | PlayerBuffScalarFieldEnum[]
  }

  /**
   * PlayerBuff findMany
   */
  export type PlayerBuffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    /**
     * Filter, which PlayerBuffs to fetch.
     */
    where?: PlayerBuffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerBuffs to fetch.
     */
    orderBy?: PlayerBuffOrderByWithRelationInput | PlayerBuffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerBuffs.
     */
    cursor?: PlayerBuffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerBuffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerBuffs.
     */
    skip?: number
    distinct?: PlayerBuffScalarFieldEnum | PlayerBuffScalarFieldEnum[]
  }

  /**
   * PlayerBuff create
   */
  export type PlayerBuffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerBuff.
     */
    data: XOR<PlayerBuffCreateInput, PlayerBuffUncheckedCreateInput>
  }

  /**
   * PlayerBuff createMany
   */
  export type PlayerBuffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerBuffs.
     */
    data: PlayerBuffCreateManyInput | PlayerBuffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerBuff createManyAndReturn
   */
  export type PlayerBuffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerBuffs.
     */
    data: PlayerBuffCreateManyInput | PlayerBuffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerBuff update
   */
  export type PlayerBuffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerBuff.
     */
    data: XOR<PlayerBuffUpdateInput, PlayerBuffUncheckedUpdateInput>
    /**
     * Choose, which PlayerBuff to update.
     */
    where: PlayerBuffWhereUniqueInput
  }

  /**
   * PlayerBuff updateMany
   */
  export type PlayerBuffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerBuffs.
     */
    data: XOR<PlayerBuffUpdateManyMutationInput, PlayerBuffUncheckedUpdateManyInput>
    /**
     * Filter which PlayerBuffs to update
     */
    where?: PlayerBuffWhereInput
  }

  /**
   * PlayerBuff upsert
   */
  export type PlayerBuffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerBuff to update in case it exists.
     */
    where: PlayerBuffWhereUniqueInput
    /**
     * In case the PlayerBuff found by the `where` argument doesn't exist, create a new PlayerBuff with this data.
     */
    create: XOR<PlayerBuffCreateInput, PlayerBuffUncheckedCreateInput>
    /**
     * In case the PlayerBuff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerBuffUpdateInput, PlayerBuffUncheckedUpdateInput>
  }

  /**
   * PlayerBuff delete
   */
  export type PlayerBuffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
    /**
     * Filter which PlayerBuff to delete.
     */
    where: PlayerBuffWhereUniqueInput
  }

  /**
   * PlayerBuff deleteMany
   */
  export type PlayerBuffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerBuffs to delete
     */
    where?: PlayerBuffWhereInput
  }

  /**
   * PlayerBuff without action
   */
  export type PlayerBuffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBuff
     */
    select?: PlayerBuffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBuffInclude<ExtArgs> | null
  }


  /**
   * Model GameConfig
   */

  export type AggregateGameConfig = {
    _count: GameConfigCountAggregateOutputType | null
    _min: GameConfigMinAggregateOutputType | null
    _max: GameConfigMaxAggregateOutputType | null
  }

  export type GameConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    type: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameConfig to aggregate.
     */
    where?: GameConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameConfigs to fetch.
     */
    orderBy?: GameConfigOrderByWithRelationInput | GameConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameConfigs
    **/
    _count?: true | GameConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameConfigMaxAggregateInputType
  }

  export type GetGameConfigAggregateType<T extends GameConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateGameConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameConfig[P]>
      : GetScalarType<T[P], AggregateGameConfig[P]>
  }




  export type GameConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameConfigWhereInput
    orderBy?: GameConfigOrderByWithAggregationInput | GameConfigOrderByWithAggregationInput[]
    by: GameConfigScalarFieldEnum[] | GameConfigScalarFieldEnum
    having?: GameConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameConfigCountAggregateInputType | true
    _min?: GameConfigMinAggregateInputType
    _max?: GameConfigMaxAggregateInputType
  }

  export type GameConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    type: string
    category: string
    createdAt: Date
    updatedAt: Date
    _count: GameConfigCountAggregateOutputType | null
    _min: GameConfigMinAggregateOutputType | null
    _max: GameConfigMaxAggregateOutputType | null
  }

  type GetGameConfigGroupByPayload<T extends GameConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameConfigGroupByOutputType[P]>
            : GetScalarType<T[P], GameConfigGroupByOutputType[P]>
        }
      >
    >


  export type GameConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gameConfig"]>

  export type GameConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gameConfig"]>

  export type GameConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $GameConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      type: string
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameConfig"]>
    composites: {}
  }

  type GameConfigGetPayload<S extends boolean | null | undefined | GameConfigDefaultArgs> = $Result.GetResult<Prisma.$GameConfigPayload, S>

  type GameConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameConfigCountAggregateInputType | true
    }

  export interface GameConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameConfig'], meta: { name: 'GameConfig' } }
    /**
     * Find zero or one GameConfig that matches the filter.
     * @param {GameConfigFindUniqueArgs} args - Arguments to find a GameConfig
     * @example
     * // Get one GameConfig
     * const gameConfig = await prisma.gameConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameConfigFindUniqueArgs>(args: SelectSubset<T, GameConfigFindUniqueArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GameConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameConfigFindUniqueOrThrowArgs} args - Arguments to find a GameConfig
     * @example
     * // Get one GameConfig
     * const gameConfig = await prisma.gameConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, GameConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GameConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigFindFirstArgs} args - Arguments to find a GameConfig
     * @example
     * // Get one GameConfig
     * const gameConfig = await prisma.gameConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameConfigFindFirstArgs>(args?: SelectSubset<T, GameConfigFindFirstArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GameConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigFindFirstOrThrowArgs} args - Arguments to find a GameConfig
     * @example
     * // Get one GameConfig
     * const gameConfig = await prisma.gameConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, GameConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GameConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameConfigs
     * const gameConfigs = await prisma.gameConfig.findMany()
     * 
     * // Get first 10 GameConfigs
     * const gameConfigs = await prisma.gameConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameConfigWithIdOnly = await prisma.gameConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameConfigFindManyArgs>(args?: SelectSubset<T, GameConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GameConfig.
     * @param {GameConfigCreateArgs} args - Arguments to create a GameConfig.
     * @example
     * // Create one GameConfig
     * const GameConfig = await prisma.gameConfig.create({
     *   data: {
     *     // ... data to create a GameConfig
     *   }
     * })
     * 
     */
    create<T extends GameConfigCreateArgs>(args: SelectSubset<T, GameConfigCreateArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GameConfigs.
     * @param {GameConfigCreateManyArgs} args - Arguments to create many GameConfigs.
     * @example
     * // Create many GameConfigs
     * const gameConfig = await prisma.gameConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameConfigCreateManyArgs>(args?: SelectSubset<T, GameConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameConfigs and returns the data saved in the database.
     * @param {GameConfigCreateManyAndReturnArgs} args - Arguments to create many GameConfigs.
     * @example
     * // Create many GameConfigs
     * const gameConfig = await prisma.gameConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameConfigs and only return the `id`
     * const gameConfigWithIdOnly = await prisma.gameConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, GameConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GameConfig.
     * @param {GameConfigDeleteArgs} args - Arguments to delete one GameConfig.
     * @example
     * // Delete one GameConfig
     * const GameConfig = await prisma.gameConfig.delete({
     *   where: {
     *     // ... filter to delete one GameConfig
     *   }
     * })
     * 
     */
    delete<T extends GameConfigDeleteArgs>(args: SelectSubset<T, GameConfigDeleteArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GameConfig.
     * @param {GameConfigUpdateArgs} args - Arguments to update one GameConfig.
     * @example
     * // Update one GameConfig
     * const gameConfig = await prisma.gameConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameConfigUpdateArgs>(args: SelectSubset<T, GameConfigUpdateArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GameConfigs.
     * @param {GameConfigDeleteManyArgs} args - Arguments to filter GameConfigs to delete.
     * @example
     * // Delete a few GameConfigs
     * const { count } = await prisma.gameConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameConfigDeleteManyArgs>(args?: SelectSubset<T, GameConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameConfigs
     * const gameConfig = await prisma.gameConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameConfigUpdateManyArgs>(args: SelectSubset<T, GameConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameConfig.
     * @param {GameConfigUpsertArgs} args - Arguments to update or create a GameConfig.
     * @example
     * // Update or create a GameConfig
     * const gameConfig = await prisma.gameConfig.upsert({
     *   create: {
     *     // ... data to create a GameConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameConfig we want to update
     *   }
     * })
     */
    upsert<T extends GameConfigUpsertArgs>(args: SelectSubset<T, GameConfigUpsertArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GameConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigCountArgs} args - Arguments to filter GameConfigs to count.
     * @example
     * // Count the number of GameConfigs
     * const count = await prisma.gameConfig.count({
     *   where: {
     *     // ... the filter for the GameConfigs we want to count
     *   }
     * })
    **/
    count<T extends GameConfigCountArgs>(
      args?: Subset<T, GameConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameConfigAggregateArgs>(args: Subset<T, GameConfigAggregateArgs>): Prisma.PrismaPromise<GetGameConfigAggregateType<T>>

    /**
     * Group by GameConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameConfigGroupByArgs['orderBy'] }
        : { orderBy?: GameConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameConfig model
   */
  readonly fields: GameConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameConfig model
   */ 
  interface GameConfigFieldRefs {
    readonly id: FieldRef<"GameConfig", 'String'>
    readonly key: FieldRef<"GameConfig", 'String'>
    readonly value: FieldRef<"GameConfig", 'String'>
    readonly type: FieldRef<"GameConfig", 'String'>
    readonly category: FieldRef<"GameConfig", 'String'>
    readonly createdAt: FieldRef<"GameConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"GameConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameConfig findUnique
   */
  export type GameConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Filter, which GameConfig to fetch.
     */
    where: GameConfigWhereUniqueInput
  }

  /**
   * GameConfig findUniqueOrThrow
   */
  export type GameConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Filter, which GameConfig to fetch.
     */
    where: GameConfigWhereUniqueInput
  }

  /**
   * GameConfig findFirst
   */
  export type GameConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Filter, which GameConfig to fetch.
     */
    where?: GameConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameConfigs to fetch.
     */
    orderBy?: GameConfigOrderByWithRelationInput | GameConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameConfigs.
     */
    cursor?: GameConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameConfigs.
     */
    distinct?: GameConfigScalarFieldEnum | GameConfigScalarFieldEnum[]
  }

  /**
   * GameConfig findFirstOrThrow
   */
  export type GameConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Filter, which GameConfig to fetch.
     */
    where?: GameConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameConfigs to fetch.
     */
    orderBy?: GameConfigOrderByWithRelationInput | GameConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameConfigs.
     */
    cursor?: GameConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameConfigs.
     */
    distinct?: GameConfigScalarFieldEnum | GameConfigScalarFieldEnum[]
  }

  /**
   * GameConfig findMany
   */
  export type GameConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Filter, which GameConfigs to fetch.
     */
    where?: GameConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameConfigs to fetch.
     */
    orderBy?: GameConfigOrderByWithRelationInput | GameConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameConfigs.
     */
    cursor?: GameConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameConfigs.
     */
    skip?: number
    distinct?: GameConfigScalarFieldEnum | GameConfigScalarFieldEnum[]
  }

  /**
   * GameConfig create
   */
  export type GameConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a GameConfig.
     */
    data: XOR<GameConfigCreateInput, GameConfigUncheckedCreateInput>
  }

  /**
   * GameConfig createMany
   */
  export type GameConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameConfigs.
     */
    data: GameConfigCreateManyInput | GameConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameConfig createManyAndReturn
   */
  export type GameConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GameConfigs.
     */
    data: GameConfigCreateManyInput | GameConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameConfig update
   */
  export type GameConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a GameConfig.
     */
    data: XOR<GameConfigUpdateInput, GameConfigUncheckedUpdateInput>
    /**
     * Choose, which GameConfig to update.
     */
    where: GameConfigWhereUniqueInput
  }

  /**
   * GameConfig updateMany
   */
  export type GameConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameConfigs.
     */
    data: XOR<GameConfigUpdateManyMutationInput, GameConfigUncheckedUpdateManyInput>
    /**
     * Filter which GameConfigs to update
     */
    where?: GameConfigWhereInput
  }

  /**
   * GameConfig upsert
   */
  export type GameConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the GameConfig to update in case it exists.
     */
    where: GameConfigWhereUniqueInput
    /**
     * In case the GameConfig found by the `where` argument doesn't exist, create a new GameConfig with this data.
     */
    create: XOR<GameConfigCreateInput, GameConfigUncheckedCreateInput>
    /**
     * In case the GameConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameConfigUpdateInput, GameConfigUncheckedUpdateInput>
  }

  /**
   * GameConfig delete
   */
  export type GameConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Filter which GameConfig to delete.
     */
    where: GameConfigWhereUniqueInput
  }

  /**
   * GameConfig deleteMany
   */
  export type GameConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameConfigs to delete
     */
    where?: GameConfigWhereInput
  }

  /**
   * GameConfig without action
   */
  export type GameConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
  }


  /**
   * Model Shop
   */

  export type AggregateShop = {
    _count: ShopCountAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  export type ShopMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    isActive: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    isActive: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    category: number
    isActive: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shop to aggregate.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shops
    **/
    _count?: true | ShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopMaxAggregateInputType
  }

  export type GetShopAggregateType<T extends ShopAggregateArgs> = {
        [P in keyof T & keyof AggregateShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShop[P]>
      : GetScalarType<T[P], AggregateShop[P]>
  }




  export type ShopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithAggregationInput | ShopOrderByWithAggregationInput[]
    by: ShopScalarFieldEnum[] | ShopScalarFieldEnum
    having?: ShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopCountAggregateInputType | true
    _min?: ShopMinAggregateInputType
    _max?: ShopMaxAggregateInputType
  }

  export type ShopGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    category: string
    isActive: boolean
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShopCountAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  type GetShopGroupByPayload<T extends ShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopGroupByOutputType[P]>
            : GetScalarType<T[P], ShopGroupByOutputType[P]>
        }
      >
    >


  export type ShopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | Shop$itemsArgs<ExtArgs>
    purchases?: boolean | Shop$purchasesArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Shop$itemsArgs<ExtArgs>
    purchases?: boolean | Shop$purchasesArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ShopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shop"
    objects: {
      items: Prisma.$ShopItemPayload<ExtArgs>[]
      purchases: Prisma.$PurchaseHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      category: string
      isActive: boolean
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shop"]>
    composites: {}
  }

  type ShopGetPayload<S extends boolean | null | undefined | ShopDefaultArgs> = $Result.GetResult<Prisma.$ShopPayload, S>

  type ShopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShopCountAggregateInputType | true
    }

  export interface ShopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shop'], meta: { name: 'Shop' } }
    /**
     * Find zero or one Shop that matches the filter.
     * @param {ShopFindUniqueArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopFindUniqueArgs>(args: SelectSubset<T, ShopFindUniqueArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shop that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShopFindUniqueOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopFindFirstArgs>(args?: SelectSubset<T, ShopFindFirstArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shops
     * const shops = await prisma.shop.findMany()
     * 
     * // Get first 10 Shops
     * const shops = await prisma.shop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopWithIdOnly = await prisma.shop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopFindManyArgs>(args?: SelectSubset<T, ShopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shop.
     * @param {ShopCreateArgs} args - Arguments to create a Shop.
     * @example
     * // Create one Shop
     * const Shop = await prisma.shop.create({
     *   data: {
     *     // ... data to create a Shop
     *   }
     * })
     * 
     */
    create<T extends ShopCreateArgs>(args: SelectSubset<T, ShopCreateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shops.
     * @param {ShopCreateManyArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopCreateManyArgs>(args?: SelectSubset<T, ShopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shops and returns the data saved in the database.
     * @param {ShopCreateManyAndReturnArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shops and only return the `id`
     * const shopWithIdOnly = await prisma.shop.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Shop.
     * @param {ShopDeleteArgs} args - Arguments to delete one Shop.
     * @example
     * // Delete one Shop
     * const Shop = await prisma.shop.delete({
     *   where: {
     *     // ... filter to delete one Shop
     *   }
     * })
     * 
     */
    delete<T extends ShopDeleteArgs>(args: SelectSubset<T, ShopDeleteArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shop.
     * @param {ShopUpdateArgs} args - Arguments to update one Shop.
     * @example
     * // Update one Shop
     * const shop = await prisma.shop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopUpdateArgs>(args: SelectSubset<T, ShopUpdateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shops.
     * @param {ShopDeleteManyArgs} args - Arguments to filter Shops to delete.
     * @example
     * // Delete a few Shops
     * const { count } = await prisma.shop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopDeleteManyArgs>(args?: SelectSubset<T, ShopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopUpdateManyArgs>(args: SelectSubset<T, ShopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shop.
     * @param {ShopUpsertArgs} args - Arguments to update or create a Shop.
     * @example
     * // Update or create a Shop
     * const shop = await prisma.shop.upsert({
     *   create: {
     *     // ... data to create a Shop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shop we want to update
     *   }
     * })
     */
    upsert<T extends ShopUpsertArgs>(args: SelectSubset<T, ShopUpsertArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCountArgs} args - Arguments to filter Shops to count.
     * @example
     * // Count the number of Shops
     * const count = await prisma.shop.count({
     *   where: {
     *     // ... the filter for the Shops we want to count
     *   }
     * })
    **/
    count<T extends ShopCountArgs>(
      args?: Subset<T, ShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopAggregateArgs>(args: Subset<T, ShopAggregateArgs>): Prisma.PrismaPromise<GetShopAggregateType<T>>

    /**
     * Group by Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopGroupByArgs['orderBy'] }
        : { orderBy?: ShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shop model
   */
  readonly fields: ShopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Shop$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findMany"> | Null>
    purchases<T extends Shop$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Shop$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shop model
   */ 
  interface ShopFieldRefs {
    readonly id: FieldRef<"Shop", 'String'>
    readonly name: FieldRef<"Shop", 'String'>
    readonly displayName: FieldRef<"Shop", 'String'>
    readonly description: FieldRef<"Shop", 'String'>
    readonly category: FieldRef<"Shop", 'String'>
    readonly isActive: FieldRef<"Shop", 'Boolean'>
    readonly icon: FieldRef<"Shop", 'String'>
    readonly createdAt: FieldRef<"Shop", 'DateTime'>
    readonly updatedAt: FieldRef<"Shop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shop findUnique
   */
  export type ShopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findUniqueOrThrow
   */
  export type ShopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findFirst
   */
  export type ShopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findFirstOrThrow
   */
  export type ShopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findMany
   */
  export type ShopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop create
   */
  export type ShopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to create a Shop.
     */
    data: XOR<ShopCreateInput, ShopUncheckedCreateInput>
  }

  /**
   * Shop createMany
   */
  export type ShopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shop createManyAndReturn
   */
  export type ShopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shop update
   */
  export type ShopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to update a Shop.
     */
    data: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
    /**
     * Choose, which Shop to update.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop updateMany
   */
  export type ShopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
  }

  /**
   * Shop upsert
   */
  export type ShopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The filter to search for the Shop to update in case it exists.
     */
    where: ShopWhereUniqueInput
    /**
     * In case the Shop found by the `where` argument doesn't exist, create a new Shop with this data.
     */
    create: XOR<ShopCreateInput, ShopUncheckedCreateInput>
    /**
     * In case the Shop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
  }

  /**
   * Shop delete
   */
  export type ShopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter which Shop to delete.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop deleteMany
   */
  export type ShopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shops to delete
     */
    where?: ShopWhereInput
  }

  /**
   * Shop.items
   */
  export type Shop$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    where?: ShopItemWhereInput
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    cursor?: ShopItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * Shop.purchases
   */
  export type Shop$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    where?: PurchaseHistoryWhereInput
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    cursor?: PurchaseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * Shop without action
   */
  export type ShopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
  }


  /**
   * Model ShopItem
   */

  export type AggregateShopItem = {
    _count: ShopItemCountAggregateOutputType | null
    _avg: ShopItemAvgAggregateOutputType | null
    _sum: ShopItemSumAggregateOutputType | null
    _min: ShopItemMinAggregateOutputType | null
    _max: ShopItemMaxAggregateOutputType | null
  }

  export type ShopItemAvgAggregateOutputType = {
    price: number | null
    stock: number | null
    level: number | null
  }

  export type ShopItemSumAggregateOutputType = {
    price: number | null
    stock: number | null
    level: number | null
  }

  export type ShopItemMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    itemType: string | null
    itemId: string | null
    name: string | null
    displayName: string | null
    description: string | null
    price: number | null
    currency: string | null
    stock: number | null
    isActive: boolean | null
    level: number | null
    rarity: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopItemMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    itemType: string | null
    itemId: string | null
    name: string | null
    displayName: string | null
    description: string | null
    price: number | null
    currency: string | null
    stock: number | null
    isActive: boolean | null
    level: number | null
    rarity: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopItemCountAggregateOutputType = {
    id: number
    shopId: number
    itemType: number
    itemId: number
    name: number
    displayName: number
    description: number
    price: number
    currency: number
    stock: number
    isActive: number
    level: number
    rarity: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopItemAvgAggregateInputType = {
    price?: true
    stock?: true
    level?: true
  }

  export type ShopItemSumAggregateInputType = {
    price?: true
    stock?: true
    level?: true
  }

  export type ShopItemMinAggregateInputType = {
    id?: true
    shopId?: true
    itemType?: true
    itemId?: true
    name?: true
    displayName?: true
    description?: true
    price?: true
    currency?: true
    stock?: true
    isActive?: true
    level?: true
    rarity?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopItemMaxAggregateInputType = {
    id?: true
    shopId?: true
    itemType?: true
    itemId?: true
    name?: true
    displayName?: true
    description?: true
    price?: true
    currency?: true
    stock?: true
    isActive?: true
    level?: true
    rarity?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopItemCountAggregateInputType = {
    id?: true
    shopId?: true
    itemType?: true
    itemId?: true
    name?: true
    displayName?: true
    description?: true
    price?: true
    currency?: true
    stock?: true
    isActive?: true
    level?: true
    rarity?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItem to aggregate.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopItems
    **/
    _count?: true | ShopItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopItemMaxAggregateInputType
  }

  export type GetShopItemAggregateType<T extends ShopItemAggregateArgs> = {
        [P in keyof T & keyof AggregateShopItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopItem[P]>
      : GetScalarType<T[P], AggregateShopItem[P]>
  }




  export type ShopItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemWhereInput
    orderBy?: ShopItemOrderByWithAggregationInput | ShopItemOrderByWithAggregationInput[]
    by: ShopItemScalarFieldEnum[] | ShopItemScalarFieldEnum
    having?: ShopItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopItemCountAggregateInputType | true
    _avg?: ShopItemAvgAggregateInputType
    _sum?: ShopItemSumAggregateInputType
    _min?: ShopItemMinAggregateInputType
    _max?: ShopItemMaxAggregateInputType
  }

  export type ShopItemGroupByOutputType = {
    id: string
    shopId: string
    itemType: string
    itemId: string
    name: string
    displayName: string
    description: string | null
    price: number
    currency: string
    stock: number
    isActive: boolean
    level: number
    rarity: string
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShopItemCountAggregateOutputType | null
    _avg: ShopItemAvgAggregateOutputType | null
    _sum: ShopItemSumAggregateOutputType | null
    _min: ShopItemMinAggregateOutputType | null
    _max: ShopItemMaxAggregateOutputType | null
  }

  type GetShopItemGroupByPayload<T extends ShopItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopItemGroupByOutputType[P]>
            : GetScalarType<T[P], ShopItemGroupByOutputType[P]>
        }
      >
    >


  export type ShopItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    itemType?: boolean
    itemId?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    stock?: boolean
    isActive?: boolean
    level?: boolean
    rarity?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopItem"]>

  export type ShopItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    itemType?: boolean
    itemId?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    stock?: boolean
    isActive?: boolean
    level?: boolean
    rarity?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopItem"]>

  export type ShopItemSelectScalar = {
    id?: boolean
    shopId?: boolean
    itemType?: boolean
    itemId?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    stock?: boolean
    isActive?: boolean
    level?: boolean
    rarity?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type ShopItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $ShopItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopItem"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      itemType: string
      itemId: string
      name: string
      displayName: string
      description: string | null
      price: number
      currency: string
      stock: number
      isActive: boolean
      level: number
      rarity: string
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopItem"]>
    composites: {}
  }

  type ShopItemGetPayload<S extends boolean | null | undefined | ShopItemDefaultArgs> = $Result.GetResult<Prisma.$ShopItemPayload, S>

  type ShopItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShopItemCountAggregateInputType | true
    }

  export interface ShopItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopItem'], meta: { name: 'ShopItem' } }
    /**
     * Find zero or one ShopItem that matches the filter.
     * @param {ShopItemFindUniqueArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopItemFindUniqueArgs>(args: SelectSubset<T, ShopItemFindUniqueArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShopItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShopItemFindUniqueOrThrowArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShopItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindFirstArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopItemFindFirstArgs>(args?: SelectSubset<T, ShopItemFindFirstArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShopItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindFirstOrThrowArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShopItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopItems
     * const shopItems = await prisma.shopItem.findMany()
     * 
     * // Get first 10 ShopItems
     * const shopItems = await prisma.shopItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopItemWithIdOnly = await prisma.shopItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopItemFindManyArgs>(args?: SelectSubset<T, ShopItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShopItem.
     * @param {ShopItemCreateArgs} args - Arguments to create a ShopItem.
     * @example
     * // Create one ShopItem
     * const ShopItem = await prisma.shopItem.create({
     *   data: {
     *     // ... data to create a ShopItem
     *   }
     * })
     * 
     */
    create<T extends ShopItemCreateArgs>(args: SelectSubset<T, ShopItemCreateArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShopItems.
     * @param {ShopItemCreateManyArgs} args - Arguments to create many ShopItems.
     * @example
     * // Create many ShopItems
     * const shopItem = await prisma.shopItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopItemCreateManyArgs>(args?: SelectSubset<T, ShopItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopItems and returns the data saved in the database.
     * @param {ShopItemCreateManyAndReturnArgs} args - Arguments to create many ShopItems.
     * @example
     * // Create many ShopItems
     * const shopItem = await prisma.shopItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopItems and only return the `id`
     * const shopItemWithIdOnly = await prisma.shopItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ShopItem.
     * @param {ShopItemDeleteArgs} args - Arguments to delete one ShopItem.
     * @example
     * // Delete one ShopItem
     * const ShopItem = await prisma.shopItem.delete({
     *   where: {
     *     // ... filter to delete one ShopItem
     *   }
     * })
     * 
     */
    delete<T extends ShopItemDeleteArgs>(args: SelectSubset<T, ShopItemDeleteArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShopItem.
     * @param {ShopItemUpdateArgs} args - Arguments to update one ShopItem.
     * @example
     * // Update one ShopItem
     * const shopItem = await prisma.shopItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopItemUpdateArgs>(args: SelectSubset<T, ShopItemUpdateArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShopItems.
     * @param {ShopItemDeleteManyArgs} args - Arguments to filter ShopItems to delete.
     * @example
     * // Delete a few ShopItems
     * const { count } = await prisma.shopItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopItemDeleteManyArgs>(args?: SelectSubset<T, ShopItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopItems
     * const shopItem = await prisma.shopItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopItemUpdateManyArgs>(args: SelectSubset<T, ShopItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopItem.
     * @param {ShopItemUpsertArgs} args - Arguments to update or create a ShopItem.
     * @example
     * // Update or create a ShopItem
     * const shopItem = await prisma.shopItem.upsert({
     *   create: {
     *     // ... data to create a ShopItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopItem we want to update
     *   }
     * })
     */
    upsert<T extends ShopItemUpsertArgs>(args: SelectSubset<T, ShopItemUpsertArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShopItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemCountArgs} args - Arguments to filter ShopItems to count.
     * @example
     * // Count the number of ShopItems
     * const count = await prisma.shopItem.count({
     *   where: {
     *     // ... the filter for the ShopItems we want to count
     *   }
     * })
    **/
    count<T extends ShopItemCountArgs>(
      args?: Subset<T, ShopItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopItemAggregateArgs>(args: Subset<T, ShopItemAggregateArgs>): Prisma.PrismaPromise<GetShopItemAggregateType<T>>

    /**
     * Group by ShopItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopItemGroupByArgs['orderBy'] }
        : { orderBy?: ShopItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopItem model
   */
  readonly fields: ShopItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopItem model
   */ 
  interface ShopItemFieldRefs {
    readonly id: FieldRef<"ShopItem", 'String'>
    readonly shopId: FieldRef<"ShopItem", 'String'>
    readonly itemType: FieldRef<"ShopItem", 'String'>
    readonly itemId: FieldRef<"ShopItem", 'String'>
    readonly name: FieldRef<"ShopItem", 'String'>
    readonly displayName: FieldRef<"ShopItem", 'String'>
    readonly description: FieldRef<"ShopItem", 'String'>
    readonly price: FieldRef<"ShopItem", 'Int'>
    readonly currency: FieldRef<"ShopItem", 'String'>
    readonly stock: FieldRef<"ShopItem", 'Int'>
    readonly isActive: FieldRef<"ShopItem", 'Boolean'>
    readonly level: FieldRef<"ShopItem", 'Int'>
    readonly rarity: FieldRef<"ShopItem", 'String'>
    readonly icon: FieldRef<"ShopItem", 'String'>
    readonly createdAt: FieldRef<"ShopItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopItem findUnique
   */
  export type ShopItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem findUniqueOrThrow
   */
  export type ShopItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem findFirst
   */
  export type ShopItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItems.
     */
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * ShopItem findFirstOrThrow
   */
  export type ShopItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItems.
     */
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * ShopItem findMany
   */
  export type ShopItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItems to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * ShopItem create
   */
  export type ShopItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopItem.
     */
    data: XOR<ShopItemCreateInput, ShopItemUncheckedCreateInput>
  }

  /**
   * ShopItem createMany
   */
  export type ShopItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopItems.
     */
    data: ShopItemCreateManyInput | ShopItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopItem createManyAndReturn
   */
  export type ShopItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShopItems.
     */
    data: ShopItemCreateManyInput | ShopItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopItem update
   */
  export type ShopItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopItem.
     */
    data: XOR<ShopItemUpdateInput, ShopItemUncheckedUpdateInput>
    /**
     * Choose, which ShopItem to update.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem updateMany
   */
  export type ShopItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopItems.
     */
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyInput>
    /**
     * Filter which ShopItems to update
     */
    where?: ShopItemWhereInput
  }

  /**
   * ShopItem upsert
   */
  export type ShopItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopItem to update in case it exists.
     */
    where: ShopItemWhereUniqueInput
    /**
     * In case the ShopItem found by the `where` argument doesn't exist, create a new ShopItem with this data.
     */
    create: XOR<ShopItemCreateInput, ShopItemUncheckedCreateInput>
    /**
     * In case the ShopItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopItemUpdateInput, ShopItemUncheckedUpdateInput>
  }

  /**
   * ShopItem delete
   */
  export type ShopItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter which ShopItem to delete.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem deleteMany
   */
  export type ShopItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItems to delete
     */
    where?: ShopItemWhereInput
  }

  /**
   * ShopItem without action
   */
  export type ShopItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseHistory
   */

  export type AggregatePurchaseHistory = {
    _count: PurchaseHistoryCountAggregateOutputType | null
    _avg: PurchaseHistoryAvgAggregateOutputType | null
    _sum: PurchaseHistorySumAggregateOutputType | null
    _min: PurchaseHistoryMinAggregateOutputType | null
    _max: PurchaseHistoryMaxAggregateOutputType | null
  }

  export type PurchaseHistoryAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
    totalCost: number | null
  }

  export type PurchaseHistorySumAggregateOutputType = {
    quantity: number | null
    price: number | null
    totalCost: number | null
  }

  export type PurchaseHistoryMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    shopId: string | null
    itemId: string | null
    itemName: string | null
    quantity: number | null
    price: number | null
    currency: string | null
    totalCost: number | null
    createdAt: Date | null
  }

  export type PurchaseHistoryMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    shopId: string | null
    itemId: string | null
    itemName: string | null
    quantity: number | null
    price: number | null
    currency: string | null
    totalCost: number | null
    createdAt: Date | null
  }

  export type PurchaseHistoryCountAggregateOutputType = {
    id: number
    playerId: number
    shopId: number
    itemId: number
    itemName: number
    quantity: number
    price: number
    currency: number
    totalCost: number
    createdAt: number
    _all: number
  }


  export type PurchaseHistoryAvgAggregateInputType = {
    quantity?: true
    price?: true
    totalCost?: true
  }

  export type PurchaseHistorySumAggregateInputType = {
    quantity?: true
    price?: true
    totalCost?: true
  }

  export type PurchaseHistoryMinAggregateInputType = {
    id?: true
    playerId?: true
    shopId?: true
    itemId?: true
    itemName?: true
    quantity?: true
    price?: true
    currency?: true
    totalCost?: true
    createdAt?: true
  }

  export type PurchaseHistoryMaxAggregateInputType = {
    id?: true
    playerId?: true
    shopId?: true
    itemId?: true
    itemName?: true
    quantity?: true
    price?: true
    currency?: true
    totalCost?: true
    createdAt?: true
  }

  export type PurchaseHistoryCountAggregateInputType = {
    id?: true
    playerId?: true
    shopId?: true
    itemId?: true
    itemName?: true
    quantity?: true
    price?: true
    currency?: true
    totalCost?: true
    createdAt?: true
    _all?: true
  }

  export type PurchaseHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseHistory to aggregate.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseHistories
    **/
    _count?: true | PurchaseHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseHistoryMaxAggregateInputType
  }

  export type GetPurchaseHistoryAggregateType<T extends PurchaseHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseHistory[P]>
      : GetScalarType<T[P], AggregatePurchaseHistory[P]>
  }




  export type PurchaseHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseHistoryWhereInput
    orderBy?: PurchaseHistoryOrderByWithAggregationInput | PurchaseHistoryOrderByWithAggregationInput[]
    by: PurchaseHistoryScalarFieldEnum[] | PurchaseHistoryScalarFieldEnum
    having?: PurchaseHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseHistoryCountAggregateInputType | true
    _avg?: PurchaseHistoryAvgAggregateInputType
    _sum?: PurchaseHistorySumAggregateInputType
    _min?: PurchaseHistoryMinAggregateInputType
    _max?: PurchaseHistoryMaxAggregateInputType
  }

  export type PurchaseHistoryGroupByOutputType = {
    id: string
    playerId: string
    shopId: string
    itemId: string
    itemName: string
    quantity: number
    price: number
    currency: string
    totalCost: number
    createdAt: Date
    _count: PurchaseHistoryCountAggregateOutputType | null
    _avg: PurchaseHistoryAvgAggregateOutputType | null
    _sum: PurchaseHistorySumAggregateOutputType | null
    _min: PurchaseHistoryMinAggregateOutputType | null
    _max: PurchaseHistoryMaxAggregateOutputType | null
  }

  type GetPurchaseHistoryGroupByPayload<T extends PurchaseHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    shopId?: boolean
    itemId?: boolean
    itemName?: boolean
    quantity?: boolean
    price?: boolean
    currency?: boolean
    totalCost?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseHistory"]>

  export type PurchaseHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    shopId?: boolean
    itemId?: boolean
    itemName?: boolean
    quantity?: boolean
    price?: boolean
    currency?: boolean
    totalCost?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseHistory"]>

  export type PurchaseHistorySelectScalar = {
    id?: boolean
    playerId?: boolean
    shopId?: boolean
    itemId?: boolean
    itemName?: boolean
    quantity?: boolean
    price?: boolean
    currency?: boolean
    totalCost?: boolean
    createdAt?: boolean
  }

  export type PurchaseHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type PurchaseHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $PurchaseHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseHistory"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      shopId: string
      itemId: string
      itemName: string
      quantity: number
      price: number
      currency: string
      totalCost: number
      createdAt: Date
    }, ExtArgs["result"]["purchaseHistory"]>
    composites: {}
  }

  type PurchaseHistoryGetPayload<S extends boolean | null | undefined | PurchaseHistoryDefaultArgs> = $Result.GetResult<Prisma.$PurchaseHistoryPayload, S>

  type PurchaseHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseHistoryCountAggregateInputType | true
    }

  export interface PurchaseHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseHistory'], meta: { name: 'PurchaseHistory' } }
    /**
     * Find zero or one PurchaseHistory that matches the filter.
     * @param {PurchaseHistoryFindUniqueArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseHistoryFindUniqueArgs>(args: SelectSubset<T, PurchaseHistoryFindUniqueArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseHistoryFindUniqueOrThrowArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryFindFirstArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseHistoryFindFirstArgs>(args?: SelectSubset<T, PurchaseHistoryFindFirstArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryFindFirstOrThrowArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseHistories
     * const purchaseHistories = await prisma.purchaseHistory.findMany()
     * 
     * // Get first 10 PurchaseHistories
     * const purchaseHistories = await prisma.purchaseHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseHistoryWithIdOnly = await prisma.purchaseHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseHistoryFindManyArgs>(args?: SelectSubset<T, PurchaseHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseHistory.
     * @param {PurchaseHistoryCreateArgs} args - Arguments to create a PurchaseHistory.
     * @example
     * // Create one PurchaseHistory
     * const PurchaseHistory = await prisma.purchaseHistory.create({
     *   data: {
     *     // ... data to create a PurchaseHistory
     *   }
     * })
     * 
     */
    create<T extends PurchaseHistoryCreateArgs>(args: SelectSubset<T, PurchaseHistoryCreateArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseHistories.
     * @param {PurchaseHistoryCreateManyArgs} args - Arguments to create many PurchaseHistories.
     * @example
     * // Create many PurchaseHistories
     * const purchaseHistory = await prisma.purchaseHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseHistoryCreateManyArgs>(args?: SelectSubset<T, PurchaseHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseHistories and returns the data saved in the database.
     * @param {PurchaseHistoryCreateManyAndReturnArgs} args - Arguments to create many PurchaseHistories.
     * @example
     * // Create many PurchaseHistories
     * const purchaseHistory = await prisma.purchaseHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseHistories and only return the `id`
     * const purchaseHistoryWithIdOnly = await prisma.purchaseHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseHistory.
     * @param {PurchaseHistoryDeleteArgs} args - Arguments to delete one PurchaseHistory.
     * @example
     * // Delete one PurchaseHistory
     * const PurchaseHistory = await prisma.purchaseHistory.delete({
     *   where: {
     *     // ... filter to delete one PurchaseHistory
     *   }
     * })
     * 
     */
    delete<T extends PurchaseHistoryDeleteArgs>(args: SelectSubset<T, PurchaseHistoryDeleteArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseHistory.
     * @param {PurchaseHistoryUpdateArgs} args - Arguments to update one PurchaseHistory.
     * @example
     * // Update one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseHistoryUpdateArgs>(args: SelectSubset<T, PurchaseHistoryUpdateArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseHistories.
     * @param {PurchaseHistoryDeleteManyArgs} args - Arguments to filter PurchaseHistories to delete.
     * @example
     * // Delete a few PurchaseHistories
     * const { count } = await prisma.purchaseHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseHistoryDeleteManyArgs>(args?: SelectSubset<T, PurchaseHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseHistories
     * const purchaseHistory = await prisma.purchaseHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseHistoryUpdateManyArgs>(args: SelectSubset<T, PurchaseHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseHistory.
     * @param {PurchaseHistoryUpsertArgs} args - Arguments to update or create a PurchaseHistory.
     * @example
     * // Update or create a PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.upsert({
     *   create: {
     *     // ... data to create a PurchaseHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseHistory we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseHistoryUpsertArgs>(args: SelectSubset<T, PurchaseHistoryUpsertArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryCountArgs} args - Arguments to filter PurchaseHistories to count.
     * @example
     * // Count the number of PurchaseHistories
     * const count = await prisma.purchaseHistory.count({
     *   where: {
     *     // ... the filter for the PurchaseHistories we want to count
     *   }
     * })
    **/
    count<T extends PurchaseHistoryCountArgs>(
      args?: Subset<T, PurchaseHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseHistoryAggregateArgs>(args: Subset<T, PurchaseHistoryAggregateArgs>): Prisma.PrismaPromise<GetPurchaseHistoryAggregateType<T>>

    /**
     * Group by PurchaseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseHistory model
   */
  readonly fields: PurchaseHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseHistory model
   */ 
  interface PurchaseHistoryFieldRefs {
    readonly id: FieldRef<"PurchaseHistory", 'String'>
    readonly playerId: FieldRef<"PurchaseHistory", 'String'>
    readonly shopId: FieldRef<"PurchaseHistory", 'String'>
    readonly itemId: FieldRef<"PurchaseHistory", 'String'>
    readonly itemName: FieldRef<"PurchaseHistory", 'String'>
    readonly quantity: FieldRef<"PurchaseHistory", 'Int'>
    readonly price: FieldRef<"PurchaseHistory", 'Int'>
    readonly currency: FieldRef<"PurchaseHistory", 'String'>
    readonly totalCost: FieldRef<"PurchaseHistory", 'Int'>
    readonly createdAt: FieldRef<"PurchaseHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseHistory findUnique
   */
  export type PurchaseHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory findUniqueOrThrow
   */
  export type PurchaseHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory findFirst
   */
  export type PurchaseHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseHistories.
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseHistories.
     */
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * PurchaseHistory findFirstOrThrow
   */
  export type PurchaseHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseHistories.
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseHistories.
     */
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * PurchaseHistory findMany
   */
  export type PurchaseHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistories to fetch.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseHistories.
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * PurchaseHistory create
   */
  export type PurchaseHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseHistory.
     */
    data: XOR<PurchaseHistoryCreateInput, PurchaseHistoryUncheckedCreateInput>
  }

  /**
   * PurchaseHistory createMany
   */
  export type PurchaseHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseHistories.
     */
    data: PurchaseHistoryCreateManyInput | PurchaseHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseHistory createManyAndReturn
   */
  export type PurchaseHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseHistories.
     */
    data: PurchaseHistoryCreateManyInput | PurchaseHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseHistory update
   */
  export type PurchaseHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseHistory.
     */
    data: XOR<PurchaseHistoryUpdateInput, PurchaseHistoryUncheckedUpdateInput>
    /**
     * Choose, which PurchaseHistory to update.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory updateMany
   */
  export type PurchaseHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseHistories.
     */
    data: XOR<PurchaseHistoryUpdateManyMutationInput, PurchaseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseHistories to update
     */
    where?: PurchaseHistoryWhereInput
  }

  /**
   * PurchaseHistory upsert
   */
  export type PurchaseHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseHistory to update in case it exists.
     */
    where: PurchaseHistoryWhereUniqueInput
    /**
     * In case the PurchaseHistory found by the `where` argument doesn't exist, create a new PurchaseHistory with this data.
     */
    create: XOR<PurchaseHistoryCreateInput, PurchaseHistoryUncheckedCreateInput>
    /**
     * In case the PurchaseHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseHistoryUpdateInput, PurchaseHistoryUncheckedUpdateInput>
  }

  /**
   * PurchaseHistory delete
   */
  export type PurchaseHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter which PurchaseHistory to delete.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory deleteMany
   */
  export type PurchaseHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseHistories to delete
     */
    where?: PurchaseHistoryWhereInput
  }

  /**
   * PurchaseHistory without action
   */
  export type PurchaseHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventorySumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    itemType: string | null
    itemId: string | null
    name: string | null
    quantity: number | null
    stackable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    itemType: string | null
    itemId: string | null
    name: string | null
    quantity: number | null
    stackable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    playerId: number
    itemType: number
    itemId: number
    name: number
    quantity: number
    stackable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    quantity?: true
  }

  export type InventorySumAggregateInputType = {
    quantity?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    playerId?: true
    itemType?: true
    itemId?: true
    name?: true
    quantity?: true
    stackable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    playerId?: true
    itemType?: true
    itemId?: true
    name?: true
    quantity?: true
    stackable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    playerId?: true
    itemType?: true
    itemId?: true
    name?: true
    quantity?: true
    stackable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    playerId: string
    itemType: string
    itemId: string
    name: string
    quantity: number
    stackable: boolean
    createdAt: Date
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemType?: boolean
    itemId?: boolean
    name?: boolean
    quantity?: boolean
    stackable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemType?: boolean
    itemId?: boolean
    name?: boolean
    quantity?: boolean
    stackable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    playerId?: boolean
    itemType?: boolean
    itemId?: boolean
    name?: boolean
    quantity?: boolean
    stackable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      itemType: string
      itemId: string
      name: string
      quantity: number
      stackable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */ 
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly playerId: FieldRef<"Inventory", 'String'>
    readonly itemType: FieldRef<"Inventory", 'String'>
    readonly itemId: FieldRef<"Inventory", 'String'>
    readonly name: FieldRef<"Inventory", 'String'>
    readonly quantity: FieldRef<"Inventory", 'Int'>
    readonly stackable: FieldRef<"Inventory", 'Boolean'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    level: number | null
    successRate: number | null
    experience: number | null
  }

  export type RecipeSumAggregateOutputType = {
    level: number | null
    successRate: number | null
    experience: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    level: number | null
    successRate: number | null
    materials: string | null
    result: string | null
    experience: number | null
    isActive: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    level: number | null
    successRate: number | null
    materials: string | null
    result: string | null
    experience: number | null
    isActive: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    category: number
    level: number
    successRate: number
    materials: number
    result: number
    experience: number
    isActive: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    level?: true
    successRate?: true
    experience?: true
  }

  export type RecipeSumAggregateInputType = {
    level?: true
    successRate?: true
    experience?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    level?: true
    successRate?: true
    materials?: true
    result?: true
    experience?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    level?: true
    successRate?: true
    materials?: true
    result?: true
    experience?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    level?: true
    successRate?: true
    materials?: true
    result?: true
    experience?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    category: string
    level: number
    successRate: number
    materials: string
    result: string
    experience: number
    isActive: boolean
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    level?: boolean
    successRate?: boolean
    materials?: boolean
    result?: boolean
    experience?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    craftingHistory?: boolean | Recipe$craftingHistoryArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    level?: boolean
    successRate?: boolean
    materials?: boolean
    result?: boolean
    experience?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    level?: boolean
    successRate?: boolean
    materials?: boolean
    result?: boolean
    experience?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    craftingHistory?: boolean | Recipe$craftingHistoryArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      craftingHistory: Prisma.$CraftingHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      category: string
      level: number
      successRate: number
      materials: string
      result: string
      experience: number
      isActive: boolean
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }

  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeFindUniqueArgs>(args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recipe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeFindFirstArgs>(args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeFindManyArgs>(args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
     */
    create<T extends RecipeCreateArgs>(args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recipes.
     * @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeCreateManyArgs>(args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recipes and returns the data saved in the database.
     * @param {RecipeCreateManyAndReturnArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
     */
    delete<T extends RecipeDeleteArgs>(args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeUpdateArgs>(args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDeleteManyArgs>(args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeUpdateManyArgs>(args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
     */
    upsert<T extends RecipeUpsertArgs>(args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    craftingHistory<T extends Recipe$craftingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$craftingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipe model
   */ 
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'String'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly displayName: FieldRef<"Recipe", 'String'>
    readonly description: FieldRef<"Recipe", 'String'>
    readonly category: FieldRef<"Recipe", 'String'>
    readonly level: FieldRef<"Recipe", 'Int'>
    readonly successRate: FieldRef<"Recipe", 'Float'>
    readonly materials: FieldRef<"Recipe", 'String'>
    readonly result: FieldRef<"Recipe", 'String'>
    readonly experience: FieldRef<"Recipe", 'Int'>
    readonly isActive: FieldRef<"Recipe", 'Boolean'>
    readonly icon: FieldRef<"Recipe", 'String'>
    readonly createdAt: FieldRef<"Recipe", 'DateTime'>
    readonly updatedAt: FieldRef<"Recipe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }

  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipe createManyAndReturn
   */
  export type RecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }

  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe.craftingHistory
   */
  export type Recipe$craftingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    where?: CraftingHistoryWhereInput
    orderBy?: CraftingHistoryOrderByWithRelationInput | CraftingHistoryOrderByWithRelationInput[]
    cursor?: CraftingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CraftingHistoryScalarFieldEnum | CraftingHistoryScalarFieldEnum[]
  }

  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
  }


  /**
   * Model CraftingHistory
   */

  export type AggregateCraftingHistory = {
    _count: CraftingHistoryCountAggregateOutputType | null
    _avg: CraftingHistoryAvgAggregateOutputType | null
    _sum: CraftingHistorySumAggregateOutputType | null
    _min: CraftingHistoryMinAggregateOutputType | null
    _max: CraftingHistoryMaxAggregateOutputType | null
  }

  export type CraftingHistoryAvgAggregateOutputType = {
    quantity: number | null
  }

  export type CraftingHistorySumAggregateOutputType = {
    quantity: number | null
  }

  export type CraftingHistoryMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    recipeId: string | null
    success: boolean | null
    quantity: number | null
    materials: string | null
    result: string | null
    createdAt: Date | null
  }

  export type CraftingHistoryMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    recipeId: string | null
    success: boolean | null
    quantity: number | null
    materials: string | null
    result: string | null
    createdAt: Date | null
  }

  export type CraftingHistoryCountAggregateOutputType = {
    id: number
    playerId: number
    recipeId: number
    success: number
    quantity: number
    materials: number
    result: number
    createdAt: number
    _all: number
  }


  export type CraftingHistoryAvgAggregateInputType = {
    quantity?: true
  }

  export type CraftingHistorySumAggregateInputType = {
    quantity?: true
  }

  export type CraftingHistoryMinAggregateInputType = {
    id?: true
    playerId?: true
    recipeId?: true
    success?: true
    quantity?: true
    materials?: true
    result?: true
    createdAt?: true
  }

  export type CraftingHistoryMaxAggregateInputType = {
    id?: true
    playerId?: true
    recipeId?: true
    success?: true
    quantity?: true
    materials?: true
    result?: true
    createdAt?: true
  }

  export type CraftingHistoryCountAggregateInputType = {
    id?: true
    playerId?: true
    recipeId?: true
    success?: true
    quantity?: true
    materials?: true
    result?: true
    createdAt?: true
    _all?: true
  }

  export type CraftingHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CraftingHistory to aggregate.
     */
    where?: CraftingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftingHistories to fetch.
     */
    orderBy?: CraftingHistoryOrderByWithRelationInput | CraftingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CraftingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CraftingHistories
    **/
    _count?: true | CraftingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CraftingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CraftingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CraftingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CraftingHistoryMaxAggregateInputType
  }

  export type GetCraftingHistoryAggregateType<T extends CraftingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCraftingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCraftingHistory[P]>
      : GetScalarType<T[P], AggregateCraftingHistory[P]>
  }




  export type CraftingHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CraftingHistoryWhereInput
    orderBy?: CraftingHistoryOrderByWithAggregationInput | CraftingHistoryOrderByWithAggregationInput[]
    by: CraftingHistoryScalarFieldEnum[] | CraftingHistoryScalarFieldEnum
    having?: CraftingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CraftingHistoryCountAggregateInputType | true
    _avg?: CraftingHistoryAvgAggregateInputType
    _sum?: CraftingHistorySumAggregateInputType
    _min?: CraftingHistoryMinAggregateInputType
    _max?: CraftingHistoryMaxAggregateInputType
  }

  export type CraftingHistoryGroupByOutputType = {
    id: string
    playerId: string
    recipeId: string
    success: boolean
    quantity: number
    materials: string
    result: string
    createdAt: Date
    _count: CraftingHistoryCountAggregateOutputType | null
    _avg: CraftingHistoryAvgAggregateOutputType | null
    _sum: CraftingHistorySumAggregateOutputType | null
    _min: CraftingHistoryMinAggregateOutputType | null
    _max: CraftingHistoryMaxAggregateOutputType | null
  }

  type GetCraftingHistoryGroupByPayload<T extends CraftingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CraftingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CraftingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CraftingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CraftingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CraftingHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    recipeId?: boolean
    success?: boolean
    quantity?: boolean
    materials?: boolean
    result?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["craftingHistory"]>

  export type CraftingHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    recipeId?: boolean
    success?: boolean
    quantity?: boolean
    materials?: boolean
    result?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["craftingHistory"]>

  export type CraftingHistorySelectScalar = {
    id?: boolean
    playerId?: boolean
    recipeId?: boolean
    success?: boolean
    quantity?: boolean
    materials?: boolean
    result?: boolean
    createdAt?: boolean
  }

  export type CraftingHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type CraftingHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $CraftingHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CraftingHistory"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      recipeId: string
      success: boolean
      quantity: number
      materials: string
      result: string
      createdAt: Date
    }, ExtArgs["result"]["craftingHistory"]>
    composites: {}
  }

  type CraftingHistoryGetPayload<S extends boolean | null | undefined | CraftingHistoryDefaultArgs> = $Result.GetResult<Prisma.$CraftingHistoryPayload, S>

  type CraftingHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CraftingHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CraftingHistoryCountAggregateInputType | true
    }

  export interface CraftingHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CraftingHistory'], meta: { name: 'CraftingHistory' } }
    /**
     * Find zero or one CraftingHistory that matches the filter.
     * @param {CraftingHistoryFindUniqueArgs} args - Arguments to find a CraftingHistory
     * @example
     * // Get one CraftingHistory
     * const craftingHistory = await prisma.craftingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CraftingHistoryFindUniqueArgs>(args: SelectSubset<T, CraftingHistoryFindUniqueArgs<ExtArgs>>): Prisma__CraftingHistoryClient<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CraftingHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CraftingHistoryFindUniqueOrThrowArgs} args - Arguments to find a CraftingHistory
     * @example
     * // Get one CraftingHistory
     * const craftingHistory = await prisma.craftingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CraftingHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CraftingHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CraftingHistoryClient<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CraftingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftingHistoryFindFirstArgs} args - Arguments to find a CraftingHistory
     * @example
     * // Get one CraftingHistory
     * const craftingHistory = await prisma.craftingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CraftingHistoryFindFirstArgs>(args?: SelectSubset<T, CraftingHistoryFindFirstArgs<ExtArgs>>): Prisma__CraftingHistoryClient<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CraftingHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftingHistoryFindFirstOrThrowArgs} args - Arguments to find a CraftingHistory
     * @example
     * // Get one CraftingHistory
     * const craftingHistory = await prisma.craftingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CraftingHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CraftingHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CraftingHistoryClient<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CraftingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftingHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CraftingHistories
     * const craftingHistories = await prisma.craftingHistory.findMany()
     * 
     * // Get first 10 CraftingHistories
     * const craftingHistories = await prisma.craftingHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const craftingHistoryWithIdOnly = await prisma.craftingHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CraftingHistoryFindManyArgs>(args?: SelectSubset<T, CraftingHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CraftingHistory.
     * @param {CraftingHistoryCreateArgs} args - Arguments to create a CraftingHistory.
     * @example
     * // Create one CraftingHistory
     * const CraftingHistory = await prisma.craftingHistory.create({
     *   data: {
     *     // ... data to create a CraftingHistory
     *   }
     * })
     * 
     */
    create<T extends CraftingHistoryCreateArgs>(args: SelectSubset<T, CraftingHistoryCreateArgs<ExtArgs>>): Prisma__CraftingHistoryClient<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CraftingHistories.
     * @param {CraftingHistoryCreateManyArgs} args - Arguments to create many CraftingHistories.
     * @example
     * // Create many CraftingHistories
     * const craftingHistory = await prisma.craftingHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CraftingHistoryCreateManyArgs>(args?: SelectSubset<T, CraftingHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CraftingHistories and returns the data saved in the database.
     * @param {CraftingHistoryCreateManyAndReturnArgs} args - Arguments to create many CraftingHistories.
     * @example
     * // Create many CraftingHistories
     * const craftingHistory = await prisma.craftingHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CraftingHistories and only return the `id`
     * const craftingHistoryWithIdOnly = await prisma.craftingHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CraftingHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CraftingHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CraftingHistory.
     * @param {CraftingHistoryDeleteArgs} args - Arguments to delete one CraftingHistory.
     * @example
     * // Delete one CraftingHistory
     * const CraftingHistory = await prisma.craftingHistory.delete({
     *   where: {
     *     // ... filter to delete one CraftingHistory
     *   }
     * })
     * 
     */
    delete<T extends CraftingHistoryDeleteArgs>(args: SelectSubset<T, CraftingHistoryDeleteArgs<ExtArgs>>): Prisma__CraftingHistoryClient<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CraftingHistory.
     * @param {CraftingHistoryUpdateArgs} args - Arguments to update one CraftingHistory.
     * @example
     * // Update one CraftingHistory
     * const craftingHistory = await prisma.craftingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CraftingHistoryUpdateArgs>(args: SelectSubset<T, CraftingHistoryUpdateArgs<ExtArgs>>): Prisma__CraftingHistoryClient<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CraftingHistories.
     * @param {CraftingHistoryDeleteManyArgs} args - Arguments to filter CraftingHistories to delete.
     * @example
     * // Delete a few CraftingHistories
     * const { count } = await prisma.craftingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CraftingHistoryDeleteManyArgs>(args?: SelectSubset<T, CraftingHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CraftingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CraftingHistories
     * const craftingHistory = await prisma.craftingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CraftingHistoryUpdateManyArgs>(args: SelectSubset<T, CraftingHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CraftingHistory.
     * @param {CraftingHistoryUpsertArgs} args - Arguments to update or create a CraftingHistory.
     * @example
     * // Update or create a CraftingHistory
     * const craftingHistory = await prisma.craftingHistory.upsert({
     *   create: {
     *     // ... data to create a CraftingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CraftingHistory we want to update
     *   }
     * })
     */
    upsert<T extends CraftingHistoryUpsertArgs>(args: SelectSubset<T, CraftingHistoryUpsertArgs<ExtArgs>>): Prisma__CraftingHistoryClient<$Result.GetResult<Prisma.$CraftingHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CraftingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftingHistoryCountArgs} args - Arguments to filter CraftingHistories to count.
     * @example
     * // Count the number of CraftingHistories
     * const count = await prisma.craftingHistory.count({
     *   where: {
     *     // ... the filter for the CraftingHistories we want to count
     *   }
     * })
    **/
    count<T extends CraftingHistoryCountArgs>(
      args?: Subset<T, CraftingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CraftingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CraftingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CraftingHistoryAggregateArgs>(args: Subset<T, CraftingHistoryAggregateArgs>): Prisma.PrismaPromise<GetCraftingHistoryAggregateType<T>>

    /**
     * Group by CraftingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CraftingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CraftingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CraftingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CraftingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCraftingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CraftingHistory model
   */
  readonly fields: CraftingHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CraftingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CraftingHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CraftingHistory model
   */ 
  interface CraftingHistoryFieldRefs {
    readonly id: FieldRef<"CraftingHistory", 'String'>
    readonly playerId: FieldRef<"CraftingHistory", 'String'>
    readonly recipeId: FieldRef<"CraftingHistory", 'String'>
    readonly success: FieldRef<"CraftingHistory", 'Boolean'>
    readonly quantity: FieldRef<"CraftingHistory", 'Int'>
    readonly materials: FieldRef<"CraftingHistory", 'String'>
    readonly result: FieldRef<"CraftingHistory", 'String'>
    readonly createdAt: FieldRef<"CraftingHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CraftingHistory findUnique
   */
  export type CraftingHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CraftingHistory to fetch.
     */
    where: CraftingHistoryWhereUniqueInput
  }

  /**
   * CraftingHistory findUniqueOrThrow
   */
  export type CraftingHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CraftingHistory to fetch.
     */
    where: CraftingHistoryWhereUniqueInput
  }

  /**
   * CraftingHistory findFirst
   */
  export type CraftingHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CraftingHistory to fetch.
     */
    where?: CraftingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftingHistories to fetch.
     */
    orderBy?: CraftingHistoryOrderByWithRelationInput | CraftingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CraftingHistories.
     */
    cursor?: CraftingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CraftingHistories.
     */
    distinct?: CraftingHistoryScalarFieldEnum | CraftingHistoryScalarFieldEnum[]
  }

  /**
   * CraftingHistory findFirstOrThrow
   */
  export type CraftingHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CraftingHistory to fetch.
     */
    where?: CraftingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftingHistories to fetch.
     */
    orderBy?: CraftingHistoryOrderByWithRelationInput | CraftingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CraftingHistories.
     */
    cursor?: CraftingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CraftingHistories.
     */
    distinct?: CraftingHistoryScalarFieldEnum | CraftingHistoryScalarFieldEnum[]
  }

  /**
   * CraftingHistory findMany
   */
  export type CraftingHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CraftingHistories to fetch.
     */
    where?: CraftingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftingHistories to fetch.
     */
    orderBy?: CraftingHistoryOrderByWithRelationInput | CraftingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CraftingHistories.
     */
    cursor?: CraftingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftingHistories.
     */
    skip?: number
    distinct?: CraftingHistoryScalarFieldEnum | CraftingHistoryScalarFieldEnum[]
  }

  /**
   * CraftingHistory create
   */
  export type CraftingHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CraftingHistory.
     */
    data: XOR<CraftingHistoryCreateInput, CraftingHistoryUncheckedCreateInput>
  }

  /**
   * CraftingHistory createMany
   */
  export type CraftingHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CraftingHistories.
     */
    data: CraftingHistoryCreateManyInput | CraftingHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CraftingHistory createManyAndReturn
   */
  export type CraftingHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CraftingHistories.
     */
    data: CraftingHistoryCreateManyInput | CraftingHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CraftingHistory update
   */
  export type CraftingHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CraftingHistory.
     */
    data: XOR<CraftingHistoryUpdateInput, CraftingHistoryUncheckedUpdateInput>
    /**
     * Choose, which CraftingHistory to update.
     */
    where: CraftingHistoryWhereUniqueInput
  }

  /**
   * CraftingHistory updateMany
   */
  export type CraftingHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CraftingHistories.
     */
    data: XOR<CraftingHistoryUpdateManyMutationInput, CraftingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CraftingHistories to update
     */
    where?: CraftingHistoryWhereInput
  }

  /**
   * CraftingHistory upsert
   */
  export type CraftingHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CraftingHistory to update in case it exists.
     */
    where: CraftingHistoryWhereUniqueInput
    /**
     * In case the CraftingHistory found by the `where` argument doesn't exist, create a new CraftingHistory with this data.
     */
    create: XOR<CraftingHistoryCreateInput, CraftingHistoryUncheckedCreateInput>
    /**
     * In case the CraftingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CraftingHistoryUpdateInput, CraftingHistoryUncheckedUpdateInput>
  }

  /**
   * CraftingHistory delete
   */
  export type CraftingHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
    /**
     * Filter which CraftingHistory to delete.
     */
    where: CraftingHistoryWhereUniqueInput
  }

  /**
   * CraftingHistory deleteMany
   */
  export type CraftingHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CraftingHistories to delete
     */
    where?: CraftingHistoryWhereInput
  }

  /**
   * CraftingHistory without action
   */
  export type CraftingHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftingHistory
     */
    select?: CraftingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftingHistoryInclude<ExtArgs> | null
  }


  /**
   * Model DaoFurnace
   */

  export type AggregateDaoFurnace = {
    _count: DaoFurnaceCountAggregateOutputType | null
    _avg: DaoFurnaceAvgAggregateOutputType | null
    _sum: DaoFurnaceSumAggregateOutputType | null
    _min: DaoFurnaceMinAggregateOutputType | null
    _max: DaoFurnaceMaxAggregateOutputType | null
  }

  export type DaoFurnaceAvgAggregateOutputType = {
    level: number | null
    maxLevel: number | null
    efficiency: number | null
  }

  export type DaoFurnaceSumAggregateOutputType = {
    level: number | null
    maxLevel: number | null
    efficiency: number | null
  }

  export type DaoFurnaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    level: number | null
    maxLevel: number | null
    efficiency: number | null
    isActive: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DaoFurnaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    level: number | null
    maxLevel: number | null
    efficiency: number | null
    isActive: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DaoFurnaceCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    level: number
    maxLevel: number
    efficiency: number
    isActive: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DaoFurnaceAvgAggregateInputType = {
    level?: true
    maxLevel?: true
    efficiency?: true
  }

  export type DaoFurnaceSumAggregateInputType = {
    level?: true
    maxLevel?: true
    efficiency?: true
  }

  export type DaoFurnaceMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    level?: true
    maxLevel?: true
    efficiency?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DaoFurnaceMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    level?: true
    maxLevel?: true
    efficiency?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DaoFurnaceCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    level?: true
    maxLevel?: true
    efficiency?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DaoFurnaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DaoFurnace to aggregate.
     */
    where?: DaoFurnaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaoFurnaces to fetch.
     */
    orderBy?: DaoFurnaceOrderByWithRelationInput | DaoFurnaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DaoFurnaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaoFurnaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaoFurnaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DaoFurnaces
    **/
    _count?: true | DaoFurnaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DaoFurnaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DaoFurnaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DaoFurnaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DaoFurnaceMaxAggregateInputType
  }

  export type GetDaoFurnaceAggregateType<T extends DaoFurnaceAggregateArgs> = {
        [P in keyof T & keyof AggregateDaoFurnace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDaoFurnace[P]>
      : GetScalarType<T[P], AggregateDaoFurnace[P]>
  }




  export type DaoFurnaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DaoFurnaceWhereInput
    orderBy?: DaoFurnaceOrderByWithAggregationInput | DaoFurnaceOrderByWithAggregationInput[]
    by: DaoFurnaceScalarFieldEnum[] | DaoFurnaceScalarFieldEnum
    having?: DaoFurnaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DaoFurnaceCountAggregateInputType | true
    _avg?: DaoFurnaceAvgAggregateInputType
    _sum?: DaoFurnaceSumAggregateInputType
    _min?: DaoFurnaceMinAggregateInputType
    _max?: DaoFurnaceMaxAggregateInputType
  }

  export type DaoFurnaceGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    level: number
    maxLevel: number
    efficiency: number
    isActive: boolean
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: DaoFurnaceCountAggregateOutputType | null
    _avg: DaoFurnaceAvgAggregateOutputType | null
    _sum: DaoFurnaceSumAggregateOutputType | null
    _min: DaoFurnaceMinAggregateOutputType | null
    _max: DaoFurnaceMaxAggregateOutputType | null
  }

  type GetDaoFurnaceGroupByPayload<T extends DaoFurnaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DaoFurnaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DaoFurnaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DaoFurnaceGroupByOutputType[P]>
            : GetScalarType<T[P], DaoFurnaceGroupByOutputType[P]>
        }
      >
    >


  export type DaoFurnaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    level?: boolean
    maxLevel?: boolean
    efficiency?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playerFurnaces?: boolean | DaoFurnace$playerFurnacesArgs<ExtArgs>
    _count?: boolean | DaoFurnaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["daoFurnace"]>

  export type DaoFurnaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    level?: boolean
    maxLevel?: boolean
    efficiency?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["daoFurnace"]>

  export type DaoFurnaceSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    level?: boolean
    maxLevel?: boolean
    efficiency?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DaoFurnaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerFurnaces?: boolean | DaoFurnace$playerFurnacesArgs<ExtArgs>
    _count?: boolean | DaoFurnaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DaoFurnaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DaoFurnacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DaoFurnace"
    objects: {
      playerFurnaces: Prisma.$PlayerFurnacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      level: number
      maxLevel: number
      efficiency: number
      isActive: boolean
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["daoFurnace"]>
    composites: {}
  }

  type DaoFurnaceGetPayload<S extends boolean | null | undefined | DaoFurnaceDefaultArgs> = $Result.GetResult<Prisma.$DaoFurnacePayload, S>

  type DaoFurnaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DaoFurnaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DaoFurnaceCountAggregateInputType | true
    }

  export interface DaoFurnaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DaoFurnace'], meta: { name: 'DaoFurnace' } }
    /**
     * Find zero or one DaoFurnace that matches the filter.
     * @param {DaoFurnaceFindUniqueArgs} args - Arguments to find a DaoFurnace
     * @example
     * // Get one DaoFurnace
     * const daoFurnace = await prisma.daoFurnace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DaoFurnaceFindUniqueArgs>(args: SelectSubset<T, DaoFurnaceFindUniqueArgs<ExtArgs>>): Prisma__DaoFurnaceClient<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DaoFurnace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DaoFurnaceFindUniqueOrThrowArgs} args - Arguments to find a DaoFurnace
     * @example
     * // Get one DaoFurnace
     * const daoFurnace = await prisma.daoFurnace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DaoFurnaceFindUniqueOrThrowArgs>(args: SelectSubset<T, DaoFurnaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DaoFurnaceClient<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DaoFurnace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaoFurnaceFindFirstArgs} args - Arguments to find a DaoFurnace
     * @example
     * // Get one DaoFurnace
     * const daoFurnace = await prisma.daoFurnace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DaoFurnaceFindFirstArgs>(args?: SelectSubset<T, DaoFurnaceFindFirstArgs<ExtArgs>>): Prisma__DaoFurnaceClient<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DaoFurnace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaoFurnaceFindFirstOrThrowArgs} args - Arguments to find a DaoFurnace
     * @example
     * // Get one DaoFurnace
     * const daoFurnace = await prisma.daoFurnace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DaoFurnaceFindFirstOrThrowArgs>(args?: SelectSubset<T, DaoFurnaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DaoFurnaceClient<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DaoFurnaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaoFurnaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DaoFurnaces
     * const daoFurnaces = await prisma.daoFurnace.findMany()
     * 
     * // Get first 10 DaoFurnaces
     * const daoFurnaces = await prisma.daoFurnace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const daoFurnaceWithIdOnly = await prisma.daoFurnace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DaoFurnaceFindManyArgs>(args?: SelectSubset<T, DaoFurnaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DaoFurnace.
     * @param {DaoFurnaceCreateArgs} args - Arguments to create a DaoFurnace.
     * @example
     * // Create one DaoFurnace
     * const DaoFurnace = await prisma.daoFurnace.create({
     *   data: {
     *     // ... data to create a DaoFurnace
     *   }
     * })
     * 
     */
    create<T extends DaoFurnaceCreateArgs>(args: SelectSubset<T, DaoFurnaceCreateArgs<ExtArgs>>): Prisma__DaoFurnaceClient<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DaoFurnaces.
     * @param {DaoFurnaceCreateManyArgs} args - Arguments to create many DaoFurnaces.
     * @example
     * // Create many DaoFurnaces
     * const daoFurnace = await prisma.daoFurnace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DaoFurnaceCreateManyArgs>(args?: SelectSubset<T, DaoFurnaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DaoFurnaces and returns the data saved in the database.
     * @param {DaoFurnaceCreateManyAndReturnArgs} args - Arguments to create many DaoFurnaces.
     * @example
     * // Create many DaoFurnaces
     * const daoFurnace = await prisma.daoFurnace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DaoFurnaces and only return the `id`
     * const daoFurnaceWithIdOnly = await prisma.daoFurnace.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DaoFurnaceCreateManyAndReturnArgs>(args?: SelectSubset<T, DaoFurnaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DaoFurnace.
     * @param {DaoFurnaceDeleteArgs} args - Arguments to delete one DaoFurnace.
     * @example
     * // Delete one DaoFurnace
     * const DaoFurnace = await prisma.daoFurnace.delete({
     *   where: {
     *     // ... filter to delete one DaoFurnace
     *   }
     * })
     * 
     */
    delete<T extends DaoFurnaceDeleteArgs>(args: SelectSubset<T, DaoFurnaceDeleteArgs<ExtArgs>>): Prisma__DaoFurnaceClient<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DaoFurnace.
     * @param {DaoFurnaceUpdateArgs} args - Arguments to update one DaoFurnace.
     * @example
     * // Update one DaoFurnace
     * const daoFurnace = await prisma.daoFurnace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DaoFurnaceUpdateArgs>(args: SelectSubset<T, DaoFurnaceUpdateArgs<ExtArgs>>): Prisma__DaoFurnaceClient<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DaoFurnaces.
     * @param {DaoFurnaceDeleteManyArgs} args - Arguments to filter DaoFurnaces to delete.
     * @example
     * // Delete a few DaoFurnaces
     * const { count } = await prisma.daoFurnace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DaoFurnaceDeleteManyArgs>(args?: SelectSubset<T, DaoFurnaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DaoFurnaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaoFurnaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DaoFurnaces
     * const daoFurnace = await prisma.daoFurnace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DaoFurnaceUpdateManyArgs>(args: SelectSubset<T, DaoFurnaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DaoFurnace.
     * @param {DaoFurnaceUpsertArgs} args - Arguments to update or create a DaoFurnace.
     * @example
     * // Update or create a DaoFurnace
     * const daoFurnace = await prisma.daoFurnace.upsert({
     *   create: {
     *     // ... data to create a DaoFurnace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DaoFurnace we want to update
     *   }
     * })
     */
    upsert<T extends DaoFurnaceUpsertArgs>(args: SelectSubset<T, DaoFurnaceUpsertArgs<ExtArgs>>): Prisma__DaoFurnaceClient<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DaoFurnaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaoFurnaceCountArgs} args - Arguments to filter DaoFurnaces to count.
     * @example
     * // Count the number of DaoFurnaces
     * const count = await prisma.daoFurnace.count({
     *   where: {
     *     // ... the filter for the DaoFurnaces we want to count
     *   }
     * })
    **/
    count<T extends DaoFurnaceCountArgs>(
      args?: Subset<T, DaoFurnaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DaoFurnaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DaoFurnace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaoFurnaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DaoFurnaceAggregateArgs>(args: Subset<T, DaoFurnaceAggregateArgs>): Prisma.PrismaPromise<GetDaoFurnaceAggregateType<T>>

    /**
     * Group by DaoFurnace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaoFurnaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DaoFurnaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DaoFurnaceGroupByArgs['orderBy'] }
        : { orderBy?: DaoFurnaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DaoFurnaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDaoFurnaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DaoFurnace model
   */
  readonly fields: DaoFurnaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DaoFurnace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DaoFurnaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playerFurnaces<T extends DaoFurnace$playerFurnacesArgs<ExtArgs> = {}>(args?: Subset<T, DaoFurnace$playerFurnacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DaoFurnace model
   */ 
  interface DaoFurnaceFieldRefs {
    readonly id: FieldRef<"DaoFurnace", 'String'>
    readonly name: FieldRef<"DaoFurnace", 'String'>
    readonly displayName: FieldRef<"DaoFurnace", 'String'>
    readonly description: FieldRef<"DaoFurnace", 'String'>
    readonly level: FieldRef<"DaoFurnace", 'Int'>
    readonly maxLevel: FieldRef<"DaoFurnace", 'Int'>
    readonly efficiency: FieldRef<"DaoFurnace", 'Float'>
    readonly isActive: FieldRef<"DaoFurnace", 'Boolean'>
    readonly icon: FieldRef<"DaoFurnace", 'String'>
    readonly createdAt: FieldRef<"DaoFurnace", 'DateTime'>
    readonly updatedAt: FieldRef<"DaoFurnace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DaoFurnace findUnique
   */
  export type DaoFurnaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DaoFurnaceInclude<ExtArgs> | null
    /**
     * Filter, which DaoFurnace to fetch.
     */
    where: DaoFurnaceWhereUniqueInput
  }

  /**
   * DaoFurnace findUniqueOrThrow
   */
  export type DaoFurnaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DaoFurnaceInclude<ExtArgs> | null
    /**
     * Filter, which DaoFurnace to fetch.
     */
    where: DaoFurnaceWhereUniqueInput
  }

  /**
   * DaoFurnace findFirst
   */
  export type DaoFurnaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DaoFurnaceInclude<ExtArgs> | null
    /**
     * Filter, which DaoFurnace to fetch.
     */
    where?: DaoFurnaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaoFurnaces to fetch.
     */
    orderBy?: DaoFurnaceOrderByWithRelationInput | DaoFurnaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DaoFurnaces.
     */
    cursor?: DaoFurnaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaoFurnaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaoFurnaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DaoFurnaces.
     */
    distinct?: DaoFurnaceScalarFieldEnum | DaoFurnaceScalarFieldEnum[]
  }

  /**
   * DaoFurnace findFirstOrThrow
   */
  export type DaoFurnaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DaoFurnaceInclude<ExtArgs> | null
    /**
     * Filter, which DaoFurnace to fetch.
     */
    where?: DaoFurnaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaoFurnaces to fetch.
     */
    orderBy?: DaoFurnaceOrderByWithRelationInput | DaoFurnaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DaoFurnaces.
     */
    cursor?: DaoFurnaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaoFurnaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaoFurnaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DaoFurnaces.
     */
    distinct?: DaoFurnaceScalarFieldEnum | DaoFurnaceScalarFieldEnum[]
  }

  /**
   * DaoFurnace findMany
   */
  export type DaoFurnaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DaoFurnaceInclude<ExtArgs> | null
    /**
     * Filter, which DaoFurnaces to fetch.
     */
    where?: DaoFurnaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaoFurnaces to fetch.
     */
    orderBy?: DaoFurnaceOrderByWithRelationInput | DaoFurnaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DaoFurnaces.
     */
    cursor?: DaoFurnaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaoFurnaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaoFurnaces.
     */
    skip?: number
    distinct?: DaoFurnaceScalarFieldEnum | DaoFurnaceScalarFieldEnum[]
  }

  /**
   * DaoFurnace create
   */
  export type DaoFurnaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DaoFurnaceInclude<ExtArgs> | null
    /**
     * The data needed to create a DaoFurnace.
     */
    data: XOR<DaoFurnaceCreateInput, DaoFurnaceUncheckedCreateInput>
  }

  /**
   * DaoFurnace createMany
   */
  export type DaoFurnaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DaoFurnaces.
     */
    data: DaoFurnaceCreateManyInput | DaoFurnaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DaoFurnace createManyAndReturn
   */
  export type DaoFurnaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DaoFurnaces.
     */
    data: DaoFurnaceCreateManyInput | DaoFurnaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DaoFurnace update
   */
  export type DaoFurnaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DaoFurnaceInclude<ExtArgs> | null
    /**
     * The data needed to update a DaoFurnace.
     */
    data: XOR<DaoFurnaceUpdateInput, DaoFurnaceUncheckedUpdateInput>
    /**
     * Choose, which DaoFurnace to update.
     */
    where: DaoFurnaceWhereUniqueInput
  }

  /**
   * DaoFurnace updateMany
   */
  export type DaoFurnaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DaoFurnaces.
     */
    data: XOR<DaoFurnaceUpdateManyMutationInput, DaoFurnaceUncheckedUpdateManyInput>
    /**
     * Filter which DaoFurnaces to update
     */
    where?: DaoFurnaceWhereInput
  }

  /**
   * DaoFurnace upsert
   */
  export type DaoFurnaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DaoFurnaceInclude<ExtArgs> | null
    /**
     * The filter to search for the DaoFurnace to update in case it exists.
     */
    where: DaoFurnaceWhereUniqueInput
    /**
     * In case the DaoFurnace found by the `where` argument doesn't exist, create a new DaoFurnace with this data.
     */
    create: XOR<DaoFurnaceCreateInput, DaoFurnaceUncheckedCreateInput>
    /**
     * In case the DaoFurnace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DaoFurnaceUpdateInput, DaoFurnaceUncheckedUpdateInput>
  }

  /**
   * DaoFurnace delete
   */
  export type DaoFurnaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DaoFurnaceInclude<ExtArgs> | null
    /**
     * Filter which DaoFurnace to delete.
     */
    where: DaoFurnaceWhereUniqueInput
  }

  /**
   * DaoFurnace deleteMany
   */
  export type DaoFurnaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DaoFurnaces to delete
     */
    where?: DaoFurnaceWhereInput
  }

  /**
   * DaoFurnace.playerFurnaces
   */
  export type DaoFurnace$playerFurnacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    where?: PlayerFurnaceWhereInput
    orderBy?: PlayerFurnaceOrderByWithRelationInput | PlayerFurnaceOrderByWithRelationInput[]
    cursor?: PlayerFurnaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerFurnaceScalarFieldEnum | PlayerFurnaceScalarFieldEnum[]
  }

  /**
   * DaoFurnace without action
   */
  export type DaoFurnaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaoFurnace
     */
    select?: DaoFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DaoFurnaceInclude<ExtArgs> | null
  }


  /**
   * Model PlayerFurnace
   */

  export type AggregatePlayerFurnace = {
    _count: PlayerFurnaceCountAggregateOutputType | null
    _avg: PlayerFurnaceAvgAggregateOutputType | null
    _sum: PlayerFurnaceSumAggregateOutputType | null
    _min: PlayerFurnaceMinAggregateOutputType | null
    _max: PlayerFurnaceMaxAggregateOutputType | null
  }

  export type PlayerFurnaceAvgAggregateOutputType = {
    level: number | null
    experience: number | null
  }

  export type PlayerFurnaceSumAggregateOutputType = {
    level: number | null
    experience: number | null
  }

  export type PlayerFurnaceMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    furnaceId: string | null
    level: number | null
    experience: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerFurnaceMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    furnaceId: string | null
    level: number | null
    experience: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerFurnaceCountAggregateOutputType = {
    id: number
    playerId: number
    furnaceId: number
    level: number
    experience: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerFurnaceAvgAggregateInputType = {
    level?: true
    experience?: true
  }

  export type PlayerFurnaceSumAggregateInputType = {
    level?: true
    experience?: true
  }

  export type PlayerFurnaceMinAggregateInputType = {
    id?: true
    playerId?: true
    furnaceId?: true
    level?: true
    experience?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerFurnaceMaxAggregateInputType = {
    id?: true
    playerId?: true
    furnaceId?: true
    level?: true
    experience?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerFurnaceCountAggregateInputType = {
    id?: true
    playerId?: true
    furnaceId?: true
    level?: true
    experience?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerFurnaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerFurnace to aggregate.
     */
    where?: PlayerFurnaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerFurnaces to fetch.
     */
    orderBy?: PlayerFurnaceOrderByWithRelationInput | PlayerFurnaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerFurnaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerFurnaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerFurnaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerFurnaces
    **/
    _count?: true | PlayerFurnaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerFurnaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerFurnaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerFurnaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerFurnaceMaxAggregateInputType
  }

  export type GetPlayerFurnaceAggregateType<T extends PlayerFurnaceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerFurnace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerFurnace[P]>
      : GetScalarType<T[P], AggregatePlayerFurnace[P]>
  }




  export type PlayerFurnaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerFurnaceWhereInput
    orderBy?: PlayerFurnaceOrderByWithAggregationInput | PlayerFurnaceOrderByWithAggregationInput[]
    by: PlayerFurnaceScalarFieldEnum[] | PlayerFurnaceScalarFieldEnum
    having?: PlayerFurnaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerFurnaceCountAggregateInputType | true
    _avg?: PlayerFurnaceAvgAggregateInputType
    _sum?: PlayerFurnaceSumAggregateInputType
    _min?: PlayerFurnaceMinAggregateInputType
    _max?: PlayerFurnaceMaxAggregateInputType
  }

  export type PlayerFurnaceGroupByOutputType = {
    id: string
    playerId: string
    furnaceId: string
    level: number
    experience: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlayerFurnaceCountAggregateOutputType | null
    _avg: PlayerFurnaceAvgAggregateOutputType | null
    _sum: PlayerFurnaceSumAggregateOutputType | null
    _min: PlayerFurnaceMinAggregateOutputType | null
    _max: PlayerFurnaceMaxAggregateOutputType | null
  }

  type GetPlayerFurnaceGroupByPayload<T extends PlayerFurnaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerFurnaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerFurnaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerFurnaceGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerFurnaceGroupByOutputType[P]>
        }
      >
    >


  export type PlayerFurnaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    furnaceId?: boolean
    level?: boolean
    experience?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    furnace?: boolean | DaoFurnaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerFurnace"]>

  export type PlayerFurnaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    furnaceId?: boolean
    level?: boolean
    experience?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    furnace?: boolean | DaoFurnaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerFurnace"]>

  export type PlayerFurnaceSelectScalar = {
    id?: boolean
    playerId?: boolean
    furnaceId?: boolean
    level?: boolean
    experience?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerFurnaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    furnace?: boolean | DaoFurnaceDefaultArgs<ExtArgs>
  }
  export type PlayerFurnaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    furnace?: boolean | DaoFurnaceDefaultArgs<ExtArgs>
  }

  export type $PlayerFurnacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerFurnace"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      furnace: Prisma.$DaoFurnacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      furnaceId: string
      level: number
      experience: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerFurnace"]>
    composites: {}
  }

  type PlayerFurnaceGetPayload<S extends boolean | null | undefined | PlayerFurnaceDefaultArgs> = $Result.GetResult<Prisma.$PlayerFurnacePayload, S>

  type PlayerFurnaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerFurnaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerFurnaceCountAggregateInputType | true
    }

  export interface PlayerFurnaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerFurnace'], meta: { name: 'PlayerFurnace' } }
    /**
     * Find zero or one PlayerFurnace that matches the filter.
     * @param {PlayerFurnaceFindUniqueArgs} args - Arguments to find a PlayerFurnace
     * @example
     * // Get one PlayerFurnace
     * const playerFurnace = await prisma.playerFurnace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFurnaceFindUniqueArgs>(args: SelectSubset<T, PlayerFurnaceFindUniqueArgs<ExtArgs>>): Prisma__PlayerFurnaceClient<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerFurnace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerFurnaceFindUniqueOrThrowArgs} args - Arguments to find a PlayerFurnace
     * @example
     * // Get one PlayerFurnace
     * const playerFurnace = await prisma.playerFurnace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFurnaceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFurnaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerFurnaceClient<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerFurnace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFurnaceFindFirstArgs} args - Arguments to find a PlayerFurnace
     * @example
     * // Get one PlayerFurnace
     * const playerFurnace = await prisma.playerFurnace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFurnaceFindFirstArgs>(args?: SelectSubset<T, PlayerFurnaceFindFirstArgs<ExtArgs>>): Prisma__PlayerFurnaceClient<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerFurnace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFurnaceFindFirstOrThrowArgs} args - Arguments to find a PlayerFurnace
     * @example
     * // Get one PlayerFurnace
     * const playerFurnace = await prisma.playerFurnace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFurnaceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFurnaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerFurnaceClient<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerFurnaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFurnaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerFurnaces
     * const playerFurnaces = await prisma.playerFurnace.findMany()
     * 
     * // Get first 10 PlayerFurnaces
     * const playerFurnaces = await prisma.playerFurnace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerFurnaceWithIdOnly = await prisma.playerFurnace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFurnaceFindManyArgs>(args?: SelectSubset<T, PlayerFurnaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerFurnace.
     * @param {PlayerFurnaceCreateArgs} args - Arguments to create a PlayerFurnace.
     * @example
     * // Create one PlayerFurnace
     * const PlayerFurnace = await prisma.playerFurnace.create({
     *   data: {
     *     // ... data to create a PlayerFurnace
     *   }
     * })
     * 
     */
    create<T extends PlayerFurnaceCreateArgs>(args: SelectSubset<T, PlayerFurnaceCreateArgs<ExtArgs>>): Prisma__PlayerFurnaceClient<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerFurnaces.
     * @param {PlayerFurnaceCreateManyArgs} args - Arguments to create many PlayerFurnaces.
     * @example
     * // Create many PlayerFurnaces
     * const playerFurnace = await prisma.playerFurnace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerFurnaceCreateManyArgs>(args?: SelectSubset<T, PlayerFurnaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerFurnaces and returns the data saved in the database.
     * @param {PlayerFurnaceCreateManyAndReturnArgs} args - Arguments to create many PlayerFurnaces.
     * @example
     * // Create many PlayerFurnaces
     * const playerFurnace = await prisma.playerFurnace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerFurnaces and only return the `id`
     * const playerFurnaceWithIdOnly = await prisma.playerFurnace.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerFurnaceCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerFurnaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerFurnace.
     * @param {PlayerFurnaceDeleteArgs} args - Arguments to delete one PlayerFurnace.
     * @example
     * // Delete one PlayerFurnace
     * const PlayerFurnace = await prisma.playerFurnace.delete({
     *   where: {
     *     // ... filter to delete one PlayerFurnace
     *   }
     * })
     * 
     */
    delete<T extends PlayerFurnaceDeleteArgs>(args: SelectSubset<T, PlayerFurnaceDeleteArgs<ExtArgs>>): Prisma__PlayerFurnaceClient<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerFurnace.
     * @param {PlayerFurnaceUpdateArgs} args - Arguments to update one PlayerFurnace.
     * @example
     * // Update one PlayerFurnace
     * const playerFurnace = await prisma.playerFurnace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerFurnaceUpdateArgs>(args: SelectSubset<T, PlayerFurnaceUpdateArgs<ExtArgs>>): Prisma__PlayerFurnaceClient<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerFurnaces.
     * @param {PlayerFurnaceDeleteManyArgs} args - Arguments to filter PlayerFurnaces to delete.
     * @example
     * // Delete a few PlayerFurnaces
     * const { count } = await prisma.playerFurnace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerFurnaceDeleteManyArgs>(args?: SelectSubset<T, PlayerFurnaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerFurnaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFurnaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerFurnaces
     * const playerFurnace = await prisma.playerFurnace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerFurnaceUpdateManyArgs>(args: SelectSubset<T, PlayerFurnaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerFurnace.
     * @param {PlayerFurnaceUpsertArgs} args - Arguments to update or create a PlayerFurnace.
     * @example
     * // Update or create a PlayerFurnace
     * const playerFurnace = await prisma.playerFurnace.upsert({
     *   create: {
     *     // ... data to create a PlayerFurnace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerFurnace we want to update
     *   }
     * })
     */
    upsert<T extends PlayerFurnaceUpsertArgs>(args: SelectSubset<T, PlayerFurnaceUpsertArgs<ExtArgs>>): Prisma__PlayerFurnaceClient<$Result.GetResult<Prisma.$PlayerFurnacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerFurnaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFurnaceCountArgs} args - Arguments to filter PlayerFurnaces to count.
     * @example
     * // Count the number of PlayerFurnaces
     * const count = await prisma.playerFurnace.count({
     *   where: {
     *     // ... the filter for the PlayerFurnaces we want to count
     *   }
     * })
    **/
    count<T extends PlayerFurnaceCountArgs>(
      args?: Subset<T, PlayerFurnaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerFurnaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerFurnace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFurnaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerFurnaceAggregateArgs>(args: Subset<T, PlayerFurnaceAggregateArgs>): Prisma.PrismaPromise<GetPlayerFurnaceAggregateType<T>>

    /**
     * Group by PlayerFurnace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFurnaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerFurnaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerFurnaceGroupByArgs['orderBy'] }
        : { orderBy?: PlayerFurnaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerFurnaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerFurnaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerFurnace model
   */
  readonly fields: PlayerFurnaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerFurnace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerFurnaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    furnace<T extends DaoFurnaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DaoFurnaceDefaultArgs<ExtArgs>>): Prisma__DaoFurnaceClient<$Result.GetResult<Prisma.$DaoFurnacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerFurnace model
   */ 
  interface PlayerFurnaceFieldRefs {
    readonly id: FieldRef<"PlayerFurnace", 'String'>
    readonly playerId: FieldRef<"PlayerFurnace", 'String'>
    readonly furnaceId: FieldRef<"PlayerFurnace", 'String'>
    readonly level: FieldRef<"PlayerFurnace", 'Int'>
    readonly experience: FieldRef<"PlayerFurnace", 'Int'>
    readonly isActive: FieldRef<"PlayerFurnace", 'Boolean'>
    readonly createdAt: FieldRef<"PlayerFurnace", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerFurnace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerFurnace findUnique
   */
  export type PlayerFurnaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    /**
     * Filter, which PlayerFurnace to fetch.
     */
    where: PlayerFurnaceWhereUniqueInput
  }

  /**
   * PlayerFurnace findUniqueOrThrow
   */
  export type PlayerFurnaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    /**
     * Filter, which PlayerFurnace to fetch.
     */
    where: PlayerFurnaceWhereUniqueInput
  }

  /**
   * PlayerFurnace findFirst
   */
  export type PlayerFurnaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    /**
     * Filter, which PlayerFurnace to fetch.
     */
    where?: PlayerFurnaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerFurnaces to fetch.
     */
    orderBy?: PlayerFurnaceOrderByWithRelationInput | PlayerFurnaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerFurnaces.
     */
    cursor?: PlayerFurnaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerFurnaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerFurnaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerFurnaces.
     */
    distinct?: PlayerFurnaceScalarFieldEnum | PlayerFurnaceScalarFieldEnum[]
  }

  /**
   * PlayerFurnace findFirstOrThrow
   */
  export type PlayerFurnaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    /**
     * Filter, which PlayerFurnace to fetch.
     */
    where?: PlayerFurnaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerFurnaces to fetch.
     */
    orderBy?: PlayerFurnaceOrderByWithRelationInput | PlayerFurnaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerFurnaces.
     */
    cursor?: PlayerFurnaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerFurnaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerFurnaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerFurnaces.
     */
    distinct?: PlayerFurnaceScalarFieldEnum | PlayerFurnaceScalarFieldEnum[]
  }

  /**
   * PlayerFurnace findMany
   */
  export type PlayerFurnaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    /**
     * Filter, which PlayerFurnaces to fetch.
     */
    where?: PlayerFurnaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerFurnaces to fetch.
     */
    orderBy?: PlayerFurnaceOrderByWithRelationInput | PlayerFurnaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerFurnaces.
     */
    cursor?: PlayerFurnaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerFurnaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerFurnaces.
     */
    skip?: number
    distinct?: PlayerFurnaceScalarFieldEnum | PlayerFurnaceScalarFieldEnum[]
  }

  /**
   * PlayerFurnace create
   */
  export type PlayerFurnaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerFurnace.
     */
    data: XOR<PlayerFurnaceCreateInput, PlayerFurnaceUncheckedCreateInput>
  }

  /**
   * PlayerFurnace createMany
   */
  export type PlayerFurnaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerFurnaces.
     */
    data: PlayerFurnaceCreateManyInput | PlayerFurnaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerFurnace createManyAndReturn
   */
  export type PlayerFurnaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerFurnaces.
     */
    data: PlayerFurnaceCreateManyInput | PlayerFurnaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerFurnace update
   */
  export type PlayerFurnaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerFurnace.
     */
    data: XOR<PlayerFurnaceUpdateInput, PlayerFurnaceUncheckedUpdateInput>
    /**
     * Choose, which PlayerFurnace to update.
     */
    where: PlayerFurnaceWhereUniqueInput
  }

  /**
   * PlayerFurnace updateMany
   */
  export type PlayerFurnaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerFurnaces.
     */
    data: XOR<PlayerFurnaceUpdateManyMutationInput, PlayerFurnaceUncheckedUpdateManyInput>
    /**
     * Filter which PlayerFurnaces to update
     */
    where?: PlayerFurnaceWhereInput
  }

  /**
   * PlayerFurnace upsert
   */
  export type PlayerFurnaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerFurnace to update in case it exists.
     */
    where: PlayerFurnaceWhereUniqueInput
    /**
     * In case the PlayerFurnace found by the `where` argument doesn't exist, create a new PlayerFurnace with this data.
     */
    create: XOR<PlayerFurnaceCreateInput, PlayerFurnaceUncheckedCreateInput>
    /**
     * In case the PlayerFurnace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerFurnaceUpdateInput, PlayerFurnaceUncheckedUpdateInput>
  }

  /**
   * PlayerFurnace delete
   */
  export type PlayerFurnaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
    /**
     * Filter which PlayerFurnace to delete.
     */
    where: PlayerFurnaceWhereUniqueInput
  }

  /**
   * PlayerFurnace deleteMany
   */
  export type PlayerFurnaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerFurnaces to delete
     */
    where?: PlayerFurnaceWhereInput
  }

  /**
   * PlayerFurnace without action
   */
  export type PlayerFurnaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFurnace
     */
    select?: PlayerFurnaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFurnaceInclude<ExtArgs> | null
  }


  /**
   * Model SpiritBeastType
   */

  export type AggregateSpiritBeastType = {
    _count: SpiritBeastTypeCountAggregateOutputType | null
    _min: SpiritBeastTypeMinAggregateOutputType | null
    _max: SpiritBeastTypeMaxAggregateOutputType | null
  }

  export type SpiritBeastTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    baseStats: string | null
    growthRate: string | null
    skills: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpiritBeastTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    baseStats: string | null
    growthRate: string | null
    skills: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpiritBeastTypeCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    category: number
    baseStats: number
    growthRate: number
    skills: number
    icon: number
    color: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpiritBeastTypeMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    baseStats?: true
    growthRate?: true
    skills?: true
    icon?: true
    color?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpiritBeastTypeMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    baseStats?: true
    growthRate?: true
    skills?: true
    icon?: true
    color?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpiritBeastTypeCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    baseStats?: true
    growthRate?: true
    skills?: true
    icon?: true
    color?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpiritBeastTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpiritBeastType to aggregate.
     */
    where?: SpiritBeastTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiritBeastTypes to fetch.
     */
    orderBy?: SpiritBeastTypeOrderByWithRelationInput | SpiritBeastTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpiritBeastTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiritBeastTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiritBeastTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpiritBeastTypes
    **/
    _count?: true | SpiritBeastTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpiritBeastTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpiritBeastTypeMaxAggregateInputType
  }

  export type GetSpiritBeastTypeAggregateType<T extends SpiritBeastTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSpiritBeastType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpiritBeastType[P]>
      : GetScalarType<T[P], AggregateSpiritBeastType[P]>
  }




  export type SpiritBeastTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpiritBeastTypeWhereInput
    orderBy?: SpiritBeastTypeOrderByWithAggregationInput | SpiritBeastTypeOrderByWithAggregationInput[]
    by: SpiritBeastTypeScalarFieldEnum[] | SpiritBeastTypeScalarFieldEnum
    having?: SpiritBeastTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpiritBeastTypeCountAggregateInputType | true
    _min?: SpiritBeastTypeMinAggregateInputType
    _max?: SpiritBeastTypeMaxAggregateInputType
  }

  export type SpiritBeastTypeGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    category: string
    baseStats: string
    growthRate: string
    skills: string | null
    icon: string | null
    color: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SpiritBeastTypeCountAggregateOutputType | null
    _min: SpiritBeastTypeMinAggregateOutputType | null
    _max: SpiritBeastTypeMaxAggregateOutputType | null
  }

  type GetSpiritBeastTypeGroupByPayload<T extends SpiritBeastTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpiritBeastTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpiritBeastTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpiritBeastTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SpiritBeastTypeGroupByOutputType[P]>
        }
      >
    >


  export type SpiritBeastTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    baseStats?: boolean
    growthRate?: boolean
    skills?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    beasts?: boolean | SpiritBeastType$beastsArgs<ExtArgs>
    _count?: boolean | SpiritBeastTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spiritBeastType"]>

  export type SpiritBeastTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    baseStats?: boolean
    growthRate?: boolean
    skills?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["spiritBeastType"]>

  export type SpiritBeastTypeSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    baseStats?: boolean
    growthRate?: boolean
    skills?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpiritBeastTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beasts?: boolean | SpiritBeastType$beastsArgs<ExtArgs>
    _count?: boolean | SpiritBeastTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpiritBeastTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpiritBeastTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpiritBeastType"
    objects: {
      beasts: Prisma.$SpiritBeastPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      category: string
      baseStats: string
      growthRate: string
      skills: string | null
      icon: string | null
      color: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["spiritBeastType"]>
    composites: {}
  }

  type SpiritBeastTypeGetPayload<S extends boolean | null | undefined | SpiritBeastTypeDefaultArgs> = $Result.GetResult<Prisma.$SpiritBeastTypePayload, S>

  type SpiritBeastTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpiritBeastTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpiritBeastTypeCountAggregateInputType | true
    }

  export interface SpiritBeastTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpiritBeastType'], meta: { name: 'SpiritBeastType' } }
    /**
     * Find zero or one SpiritBeastType that matches the filter.
     * @param {SpiritBeastTypeFindUniqueArgs} args - Arguments to find a SpiritBeastType
     * @example
     * // Get one SpiritBeastType
     * const spiritBeastType = await prisma.spiritBeastType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpiritBeastTypeFindUniqueArgs>(args: SelectSubset<T, SpiritBeastTypeFindUniqueArgs<ExtArgs>>): Prisma__SpiritBeastTypeClient<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpiritBeastType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpiritBeastTypeFindUniqueOrThrowArgs} args - Arguments to find a SpiritBeastType
     * @example
     * // Get one SpiritBeastType
     * const spiritBeastType = await prisma.spiritBeastType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpiritBeastTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SpiritBeastTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpiritBeastTypeClient<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpiritBeastType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastTypeFindFirstArgs} args - Arguments to find a SpiritBeastType
     * @example
     * // Get one SpiritBeastType
     * const spiritBeastType = await prisma.spiritBeastType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpiritBeastTypeFindFirstArgs>(args?: SelectSubset<T, SpiritBeastTypeFindFirstArgs<ExtArgs>>): Prisma__SpiritBeastTypeClient<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpiritBeastType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastTypeFindFirstOrThrowArgs} args - Arguments to find a SpiritBeastType
     * @example
     * // Get one SpiritBeastType
     * const spiritBeastType = await prisma.spiritBeastType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpiritBeastTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SpiritBeastTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpiritBeastTypeClient<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpiritBeastTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpiritBeastTypes
     * const spiritBeastTypes = await prisma.spiritBeastType.findMany()
     * 
     * // Get first 10 SpiritBeastTypes
     * const spiritBeastTypes = await prisma.spiritBeastType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spiritBeastTypeWithIdOnly = await prisma.spiritBeastType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpiritBeastTypeFindManyArgs>(args?: SelectSubset<T, SpiritBeastTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpiritBeastType.
     * @param {SpiritBeastTypeCreateArgs} args - Arguments to create a SpiritBeastType.
     * @example
     * // Create one SpiritBeastType
     * const SpiritBeastType = await prisma.spiritBeastType.create({
     *   data: {
     *     // ... data to create a SpiritBeastType
     *   }
     * })
     * 
     */
    create<T extends SpiritBeastTypeCreateArgs>(args: SelectSubset<T, SpiritBeastTypeCreateArgs<ExtArgs>>): Prisma__SpiritBeastTypeClient<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpiritBeastTypes.
     * @param {SpiritBeastTypeCreateManyArgs} args - Arguments to create many SpiritBeastTypes.
     * @example
     * // Create many SpiritBeastTypes
     * const spiritBeastType = await prisma.spiritBeastType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpiritBeastTypeCreateManyArgs>(args?: SelectSubset<T, SpiritBeastTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpiritBeastTypes and returns the data saved in the database.
     * @param {SpiritBeastTypeCreateManyAndReturnArgs} args - Arguments to create many SpiritBeastTypes.
     * @example
     * // Create many SpiritBeastTypes
     * const spiritBeastType = await prisma.spiritBeastType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpiritBeastTypes and only return the `id`
     * const spiritBeastTypeWithIdOnly = await prisma.spiritBeastType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpiritBeastTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, SpiritBeastTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpiritBeastType.
     * @param {SpiritBeastTypeDeleteArgs} args - Arguments to delete one SpiritBeastType.
     * @example
     * // Delete one SpiritBeastType
     * const SpiritBeastType = await prisma.spiritBeastType.delete({
     *   where: {
     *     // ... filter to delete one SpiritBeastType
     *   }
     * })
     * 
     */
    delete<T extends SpiritBeastTypeDeleteArgs>(args: SelectSubset<T, SpiritBeastTypeDeleteArgs<ExtArgs>>): Prisma__SpiritBeastTypeClient<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpiritBeastType.
     * @param {SpiritBeastTypeUpdateArgs} args - Arguments to update one SpiritBeastType.
     * @example
     * // Update one SpiritBeastType
     * const spiritBeastType = await prisma.spiritBeastType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpiritBeastTypeUpdateArgs>(args: SelectSubset<T, SpiritBeastTypeUpdateArgs<ExtArgs>>): Prisma__SpiritBeastTypeClient<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpiritBeastTypes.
     * @param {SpiritBeastTypeDeleteManyArgs} args - Arguments to filter SpiritBeastTypes to delete.
     * @example
     * // Delete a few SpiritBeastTypes
     * const { count } = await prisma.spiritBeastType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpiritBeastTypeDeleteManyArgs>(args?: SelectSubset<T, SpiritBeastTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpiritBeastTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpiritBeastTypes
     * const spiritBeastType = await prisma.spiritBeastType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpiritBeastTypeUpdateManyArgs>(args: SelectSubset<T, SpiritBeastTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpiritBeastType.
     * @param {SpiritBeastTypeUpsertArgs} args - Arguments to update or create a SpiritBeastType.
     * @example
     * // Update or create a SpiritBeastType
     * const spiritBeastType = await prisma.spiritBeastType.upsert({
     *   create: {
     *     // ... data to create a SpiritBeastType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpiritBeastType we want to update
     *   }
     * })
     */
    upsert<T extends SpiritBeastTypeUpsertArgs>(args: SelectSubset<T, SpiritBeastTypeUpsertArgs<ExtArgs>>): Prisma__SpiritBeastTypeClient<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpiritBeastTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastTypeCountArgs} args - Arguments to filter SpiritBeastTypes to count.
     * @example
     * // Count the number of SpiritBeastTypes
     * const count = await prisma.spiritBeastType.count({
     *   where: {
     *     // ... the filter for the SpiritBeastTypes we want to count
     *   }
     * })
    **/
    count<T extends SpiritBeastTypeCountArgs>(
      args?: Subset<T, SpiritBeastTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpiritBeastTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpiritBeastType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpiritBeastTypeAggregateArgs>(args: Subset<T, SpiritBeastTypeAggregateArgs>): Prisma.PrismaPromise<GetSpiritBeastTypeAggregateType<T>>

    /**
     * Group by SpiritBeastType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpiritBeastTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpiritBeastTypeGroupByArgs['orderBy'] }
        : { orderBy?: SpiritBeastTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpiritBeastTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpiritBeastTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpiritBeastType model
   */
  readonly fields: SpiritBeastTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpiritBeastType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpiritBeastTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    beasts<T extends SpiritBeastType$beastsArgs<ExtArgs> = {}>(args?: Subset<T, SpiritBeastType$beastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpiritBeastType model
   */ 
  interface SpiritBeastTypeFieldRefs {
    readonly id: FieldRef<"SpiritBeastType", 'String'>
    readonly name: FieldRef<"SpiritBeastType", 'String'>
    readonly displayName: FieldRef<"SpiritBeastType", 'String'>
    readonly description: FieldRef<"SpiritBeastType", 'String'>
    readonly category: FieldRef<"SpiritBeastType", 'String'>
    readonly baseStats: FieldRef<"SpiritBeastType", 'String'>
    readonly growthRate: FieldRef<"SpiritBeastType", 'String'>
    readonly skills: FieldRef<"SpiritBeastType", 'String'>
    readonly icon: FieldRef<"SpiritBeastType", 'String'>
    readonly color: FieldRef<"SpiritBeastType", 'String'>
    readonly isActive: FieldRef<"SpiritBeastType", 'Boolean'>
    readonly createdAt: FieldRef<"SpiritBeastType", 'DateTime'>
    readonly updatedAt: FieldRef<"SpiritBeastType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpiritBeastType findUnique
   */
  export type SpiritBeastTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastTypeInclude<ExtArgs> | null
    /**
     * Filter, which SpiritBeastType to fetch.
     */
    where: SpiritBeastTypeWhereUniqueInput
  }

  /**
   * SpiritBeastType findUniqueOrThrow
   */
  export type SpiritBeastTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastTypeInclude<ExtArgs> | null
    /**
     * Filter, which SpiritBeastType to fetch.
     */
    where: SpiritBeastTypeWhereUniqueInput
  }

  /**
   * SpiritBeastType findFirst
   */
  export type SpiritBeastTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastTypeInclude<ExtArgs> | null
    /**
     * Filter, which SpiritBeastType to fetch.
     */
    where?: SpiritBeastTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiritBeastTypes to fetch.
     */
    orderBy?: SpiritBeastTypeOrderByWithRelationInput | SpiritBeastTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpiritBeastTypes.
     */
    cursor?: SpiritBeastTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiritBeastTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiritBeastTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpiritBeastTypes.
     */
    distinct?: SpiritBeastTypeScalarFieldEnum | SpiritBeastTypeScalarFieldEnum[]
  }

  /**
   * SpiritBeastType findFirstOrThrow
   */
  export type SpiritBeastTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastTypeInclude<ExtArgs> | null
    /**
     * Filter, which SpiritBeastType to fetch.
     */
    where?: SpiritBeastTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiritBeastTypes to fetch.
     */
    orderBy?: SpiritBeastTypeOrderByWithRelationInput | SpiritBeastTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpiritBeastTypes.
     */
    cursor?: SpiritBeastTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiritBeastTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiritBeastTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpiritBeastTypes.
     */
    distinct?: SpiritBeastTypeScalarFieldEnum | SpiritBeastTypeScalarFieldEnum[]
  }

  /**
   * SpiritBeastType findMany
   */
  export type SpiritBeastTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastTypeInclude<ExtArgs> | null
    /**
     * Filter, which SpiritBeastTypes to fetch.
     */
    where?: SpiritBeastTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiritBeastTypes to fetch.
     */
    orderBy?: SpiritBeastTypeOrderByWithRelationInput | SpiritBeastTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpiritBeastTypes.
     */
    cursor?: SpiritBeastTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiritBeastTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiritBeastTypes.
     */
    skip?: number
    distinct?: SpiritBeastTypeScalarFieldEnum | SpiritBeastTypeScalarFieldEnum[]
  }

  /**
   * SpiritBeastType create
   */
  export type SpiritBeastTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a SpiritBeastType.
     */
    data: XOR<SpiritBeastTypeCreateInput, SpiritBeastTypeUncheckedCreateInput>
  }

  /**
   * SpiritBeastType createMany
   */
  export type SpiritBeastTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpiritBeastTypes.
     */
    data: SpiritBeastTypeCreateManyInput | SpiritBeastTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpiritBeastType createManyAndReturn
   */
  export type SpiritBeastTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpiritBeastTypes.
     */
    data: SpiritBeastTypeCreateManyInput | SpiritBeastTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpiritBeastType update
   */
  export type SpiritBeastTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a SpiritBeastType.
     */
    data: XOR<SpiritBeastTypeUpdateInput, SpiritBeastTypeUncheckedUpdateInput>
    /**
     * Choose, which SpiritBeastType to update.
     */
    where: SpiritBeastTypeWhereUniqueInput
  }

  /**
   * SpiritBeastType updateMany
   */
  export type SpiritBeastTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpiritBeastTypes.
     */
    data: XOR<SpiritBeastTypeUpdateManyMutationInput, SpiritBeastTypeUncheckedUpdateManyInput>
    /**
     * Filter which SpiritBeastTypes to update
     */
    where?: SpiritBeastTypeWhereInput
  }

  /**
   * SpiritBeastType upsert
   */
  export type SpiritBeastTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the SpiritBeastType to update in case it exists.
     */
    where: SpiritBeastTypeWhereUniqueInput
    /**
     * In case the SpiritBeastType found by the `where` argument doesn't exist, create a new SpiritBeastType with this data.
     */
    create: XOR<SpiritBeastTypeCreateInput, SpiritBeastTypeUncheckedCreateInput>
    /**
     * In case the SpiritBeastType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpiritBeastTypeUpdateInput, SpiritBeastTypeUncheckedUpdateInput>
  }

  /**
   * SpiritBeastType delete
   */
  export type SpiritBeastTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastTypeInclude<ExtArgs> | null
    /**
     * Filter which SpiritBeastType to delete.
     */
    where: SpiritBeastTypeWhereUniqueInput
  }

  /**
   * SpiritBeastType deleteMany
   */
  export type SpiritBeastTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpiritBeastTypes to delete
     */
    where?: SpiritBeastTypeWhereInput
  }

  /**
   * SpiritBeastType.beasts
   */
  export type SpiritBeastType$beastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    where?: SpiritBeastWhereInput
    orderBy?: SpiritBeastOrderByWithRelationInput | SpiritBeastOrderByWithRelationInput[]
    cursor?: SpiritBeastWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpiritBeastScalarFieldEnum | SpiritBeastScalarFieldEnum[]
  }

  /**
   * SpiritBeastType without action
   */
  export type SpiritBeastTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeastType
     */
    select?: SpiritBeastTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastTypeInclude<ExtArgs> | null
  }


  /**
   * Model SpiritBeast
   */

  export type AggregateSpiritBeast = {
    _count: SpiritBeastCountAggregateOutputType | null
    _avg: SpiritBeastAvgAggregateOutputType | null
    _sum: SpiritBeastSumAggregateOutputType | null
    _min: SpiritBeastMinAggregateOutputType | null
    _max: SpiritBeastMaxAggregateOutputType | null
  }

  export type SpiritBeastAvgAggregateOutputType = {
    level: number | null
    experience: number | null
    happiness: number | null
    hunger: number | null
    health: number | null
  }

  export type SpiritBeastSumAggregateOutputType = {
    level: number | null
    experience: number | null
    happiness: number | null
    hunger: number | null
    health: number | null
  }

  export type SpiritBeastMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    typeId: string | null
    name: string | null
    level: number | null
    experience: number | null
    stats: string | null
    skills: string | null
    happiness: number | null
    hunger: number | null
    health: number | null
    isActive: boolean | null
    isFighting: boolean | null
    capturedAt: Date | null
    lastFedAt: Date | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpiritBeastMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    typeId: string | null
    name: string | null
    level: number | null
    experience: number | null
    stats: string | null
    skills: string | null
    happiness: number | null
    hunger: number | null
    health: number | null
    isActive: boolean | null
    isFighting: boolean | null
    capturedAt: Date | null
    lastFedAt: Date | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpiritBeastCountAggregateOutputType = {
    id: number
    playerId: number
    typeId: number
    name: number
    level: number
    experience: number
    stats: number
    skills: number
    happiness: number
    hunger: number
    health: number
    isActive: number
    isFighting: number
    capturedAt: number
    lastFedAt: number
    lastPlayedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpiritBeastAvgAggregateInputType = {
    level?: true
    experience?: true
    happiness?: true
    hunger?: true
    health?: true
  }

  export type SpiritBeastSumAggregateInputType = {
    level?: true
    experience?: true
    happiness?: true
    hunger?: true
    health?: true
  }

  export type SpiritBeastMinAggregateInputType = {
    id?: true
    playerId?: true
    typeId?: true
    name?: true
    level?: true
    experience?: true
    stats?: true
    skills?: true
    happiness?: true
    hunger?: true
    health?: true
    isActive?: true
    isFighting?: true
    capturedAt?: true
    lastFedAt?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpiritBeastMaxAggregateInputType = {
    id?: true
    playerId?: true
    typeId?: true
    name?: true
    level?: true
    experience?: true
    stats?: true
    skills?: true
    happiness?: true
    hunger?: true
    health?: true
    isActive?: true
    isFighting?: true
    capturedAt?: true
    lastFedAt?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpiritBeastCountAggregateInputType = {
    id?: true
    playerId?: true
    typeId?: true
    name?: true
    level?: true
    experience?: true
    stats?: true
    skills?: true
    happiness?: true
    hunger?: true
    health?: true
    isActive?: true
    isFighting?: true
    capturedAt?: true
    lastFedAt?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpiritBeastAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpiritBeast to aggregate.
     */
    where?: SpiritBeastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiritBeasts to fetch.
     */
    orderBy?: SpiritBeastOrderByWithRelationInput | SpiritBeastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpiritBeastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiritBeasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiritBeasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpiritBeasts
    **/
    _count?: true | SpiritBeastCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpiritBeastAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpiritBeastSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpiritBeastMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpiritBeastMaxAggregateInputType
  }

  export type GetSpiritBeastAggregateType<T extends SpiritBeastAggregateArgs> = {
        [P in keyof T & keyof AggregateSpiritBeast]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpiritBeast[P]>
      : GetScalarType<T[P], AggregateSpiritBeast[P]>
  }




  export type SpiritBeastGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpiritBeastWhereInput
    orderBy?: SpiritBeastOrderByWithAggregationInput | SpiritBeastOrderByWithAggregationInput[]
    by: SpiritBeastScalarFieldEnum[] | SpiritBeastScalarFieldEnum
    having?: SpiritBeastScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpiritBeastCountAggregateInputType | true
    _avg?: SpiritBeastAvgAggregateInputType
    _sum?: SpiritBeastSumAggregateInputType
    _min?: SpiritBeastMinAggregateInputType
    _max?: SpiritBeastMaxAggregateInputType
  }

  export type SpiritBeastGroupByOutputType = {
    id: string
    playerId: string
    typeId: string
    name: string
    level: number
    experience: number
    stats: string
    skills: string | null
    happiness: number
    hunger: number
    health: number
    isActive: boolean
    isFighting: boolean
    capturedAt: Date
    lastFedAt: Date | null
    lastPlayedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SpiritBeastCountAggregateOutputType | null
    _avg: SpiritBeastAvgAggregateOutputType | null
    _sum: SpiritBeastSumAggregateOutputType | null
    _min: SpiritBeastMinAggregateOutputType | null
    _max: SpiritBeastMaxAggregateOutputType | null
  }

  type GetSpiritBeastGroupByPayload<T extends SpiritBeastGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpiritBeastGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpiritBeastGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpiritBeastGroupByOutputType[P]>
            : GetScalarType<T[P], SpiritBeastGroupByOutputType[P]>
        }
      >
    >


  export type SpiritBeastSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    typeId?: boolean
    name?: boolean
    level?: boolean
    experience?: boolean
    stats?: boolean
    skills?: boolean
    happiness?: boolean
    hunger?: boolean
    health?: boolean
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: boolean
    lastFedAt?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    type?: boolean | SpiritBeastTypeDefaultArgs<ExtArgs>
    feedingHistory?: boolean | SpiritBeast$feedingHistoryArgs<ExtArgs>
    huntingHistory?: boolean | SpiritBeast$huntingHistoryArgs<ExtArgs>
    _count?: boolean | SpiritBeastCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spiritBeast"]>

  export type SpiritBeastSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    typeId?: boolean
    name?: boolean
    level?: boolean
    experience?: boolean
    stats?: boolean
    skills?: boolean
    happiness?: boolean
    hunger?: boolean
    health?: boolean
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: boolean
    lastFedAt?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    type?: boolean | SpiritBeastTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spiritBeast"]>

  export type SpiritBeastSelectScalar = {
    id?: boolean
    playerId?: boolean
    typeId?: boolean
    name?: boolean
    level?: boolean
    experience?: boolean
    stats?: boolean
    skills?: boolean
    happiness?: boolean
    hunger?: boolean
    health?: boolean
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: boolean
    lastFedAt?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpiritBeastInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    type?: boolean | SpiritBeastTypeDefaultArgs<ExtArgs>
    feedingHistory?: boolean | SpiritBeast$feedingHistoryArgs<ExtArgs>
    huntingHistory?: boolean | SpiritBeast$huntingHistoryArgs<ExtArgs>
    _count?: boolean | SpiritBeastCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpiritBeastIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    type?: boolean | SpiritBeastTypeDefaultArgs<ExtArgs>
  }

  export type $SpiritBeastPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpiritBeast"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      type: Prisma.$SpiritBeastTypePayload<ExtArgs>
      feedingHistory: Prisma.$BeastFeedingHistoryPayload<ExtArgs>[]
      huntingHistory: Prisma.$HuntingHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      typeId: string
      name: string
      level: number
      experience: number
      stats: string
      skills: string | null
      happiness: number
      hunger: number
      health: number
      isActive: boolean
      isFighting: boolean
      capturedAt: Date
      lastFedAt: Date | null
      lastPlayedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["spiritBeast"]>
    composites: {}
  }

  type SpiritBeastGetPayload<S extends boolean | null | undefined | SpiritBeastDefaultArgs> = $Result.GetResult<Prisma.$SpiritBeastPayload, S>

  type SpiritBeastCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpiritBeastFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpiritBeastCountAggregateInputType | true
    }

  export interface SpiritBeastDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpiritBeast'], meta: { name: 'SpiritBeast' } }
    /**
     * Find zero or one SpiritBeast that matches the filter.
     * @param {SpiritBeastFindUniqueArgs} args - Arguments to find a SpiritBeast
     * @example
     * // Get one SpiritBeast
     * const spiritBeast = await prisma.spiritBeast.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpiritBeastFindUniqueArgs>(args: SelectSubset<T, SpiritBeastFindUniqueArgs<ExtArgs>>): Prisma__SpiritBeastClient<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpiritBeast that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpiritBeastFindUniqueOrThrowArgs} args - Arguments to find a SpiritBeast
     * @example
     * // Get one SpiritBeast
     * const spiritBeast = await prisma.spiritBeast.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpiritBeastFindUniqueOrThrowArgs>(args: SelectSubset<T, SpiritBeastFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpiritBeastClient<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpiritBeast that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastFindFirstArgs} args - Arguments to find a SpiritBeast
     * @example
     * // Get one SpiritBeast
     * const spiritBeast = await prisma.spiritBeast.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpiritBeastFindFirstArgs>(args?: SelectSubset<T, SpiritBeastFindFirstArgs<ExtArgs>>): Prisma__SpiritBeastClient<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpiritBeast that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastFindFirstOrThrowArgs} args - Arguments to find a SpiritBeast
     * @example
     * // Get one SpiritBeast
     * const spiritBeast = await prisma.spiritBeast.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpiritBeastFindFirstOrThrowArgs>(args?: SelectSubset<T, SpiritBeastFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpiritBeastClient<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpiritBeasts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpiritBeasts
     * const spiritBeasts = await prisma.spiritBeast.findMany()
     * 
     * // Get first 10 SpiritBeasts
     * const spiritBeasts = await prisma.spiritBeast.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spiritBeastWithIdOnly = await prisma.spiritBeast.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpiritBeastFindManyArgs>(args?: SelectSubset<T, SpiritBeastFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpiritBeast.
     * @param {SpiritBeastCreateArgs} args - Arguments to create a SpiritBeast.
     * @example
     * // Create one SpiritBeast
     * const SpiritBeast = await prisma.spiritBeast.create({
     *   data: {
     *     // ... data to create a SpiritBeast
     *   }
     * })
     * 
     */
    create<T extends SpiritBeastCreateArgs>(args: SelectSubset<T, SpiritBeastCreateArgs<ExtArgs>>): Prisma__SpiritBeastClient<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpiritBeasts.
     * @param {SpiritBeastCreateManyArgs} args - Arguments to create many SpiritBeasts.
     * @example
     * // Create many SpiritBeasts
     * const spiritBeast = await prisma.spiritBeast.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpiritBeastCreateManyArgs>(args?: SelectSubset<T, SpiritBeastCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpiritBeasts and returns the data saved in the database.
     * @param {SpiritBeastCreateManyAndReturnArgs} args - Arguments to create many SpiritBeasts.
     * @example
     * // Create many SpiritBeasts
     * const spiritBeast = await prisma.spiritBeast.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpiritBeasts and only return the `id`
     * const spiritBeastWithIdOnly = await prisma.spiritBeast.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpiritBeastCreateManyAndReturnArgs>(args?: SelectSubset<T, SpiritBeastCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpiritBeast.
     * @param {SpiritBeastDeleteArgs} args - Arguments to delete one SpiritBeast.
     * @example
     * // Delete one SpiritBeast
     * const SpiritBeast = await prisma.spiritBeast.delete({
     *   where: {
     *     // ... filter to delete one SpiritBeast
     *   }
     * })
     * 
     */
    delete<T extends SpiritBeastDeleteArgs>(args: SelectSubset<T, SpiritBeastDeleteArgs<ExtArgs>>): Prisma__SpiritBeastClient<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpiritBeast.
     * @param {SpiritBeastUpdateArgs} args - Arguments to update one SpiritBeast.
     * @example
     * // Update one SpiritBeast
     * const spiritBeast = await prisma.spiritBeast.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpiritBeastUpdateArgs>(args: SelectSubset<T, SpiritBeastUpdateArgs<ExtArgs>>): Prisma__SpiritBeastClient<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpiritBeasts.
     * @param {SpiritBeastDeleteManyArgs} args - Arguments to filter SpiritBeasts to delete.
     * @example
     * // Delete a few SpiritBeasts
     * const { count } = await prisma.spiritBeast.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpiritBeastDeleteManyArgs>(args?: SelectSubset<T, SpiritBeastDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpiritBeasts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpiritBeasts
     * const spiritBeast = await prisma.spiritBeast.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpiritBeastUpdateManyArgs>(args: SelectSubset<T, SpiritBeastUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpiritBeast.
     * @param {SpiritBeastUpsertArgs} args - Arguments to update or create a SpiritBeast.
     * @example
     * // Update or create a SpiritBeast
     * const spiritBeast = await prisma.spiritBeast.upsert({
     *   create: {
     *     // ... data to create a SpiritBeast
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpiritBeast we want to update
     *   }
     * })
     */
    upsert<T extends SpiritBeastUpsertArgs>(args: SelectSubset<T, SpiritBeastUpsertArgs<ExtArgs>>): Prisma__SpiritBeastClient<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpiritBeasts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastCountArgs} args - Arguments to filter SpiritBeasts to count.
     * @example
     * // Count the number of SpiritBeasts
     * const count = await prisma.spiritBeast.count({
     *   where: {
     *     // ... the filter for the SpiritBeasts we want to count
     *   }
     * })
    **/
    count<T extends SpiritBeastCountArgs>(
      args?: Subset<T, SpiritBeastCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpiritBeastCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpiritBeast.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpiritBeastAggregateArgs>(args: Subset<T, SpiritBeastAggregateArgs>): Prisma.PrismaPromise<GetSpiritBeastAggregateType<T>>

    /**
     * Group by SpiritBeast.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiritBeastGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpiritBeastGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpiritBeastGroupByArgs['orderBy'] }
        : { orderBy?: SpiritBeastGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpiritBeastGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpiritBeastGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpiritBeast model
   */
  readonly fields: SpiritBeastFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpiritBeast.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpiritBeastClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    type<T extends SpiritBeastTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpiritBeastTypeDefaultArgs<ExtArgs>>): Prisma__SpiritBeastTypeClient<$Result.GetResult<Prisma.$SpiritBeastTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    feedingHistory<T extends SpiritBeast$feedingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, SpiritBeast$feedingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    huntingHistory<T extends SpiritBeast$huntingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, SpiritBeast$huntingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpiritBeast model
   */ 
  interface SpiritBeastFieldRefs {
    readonly id: FieldRef<"SpiritBeast", 'String'>
    readonly playerId: FieldRef<"SpiritBeast", 'String'>
    readonly typeId: FieldRef<"SpiritBeast", 'String'>
    readonly name: FieldRef<"SpiritBeast", 'String'>
    readonly level: FieldRef<"SpiritBeast", 'Int'>
    readonly experience: FieldRef<"SpiritBeast", 'Int'>
    readonly stats: FieldRef<"SpiritBeast", 'String'>
    readonly skills: FieldRef<"SpiritBeast", 'String'>
    readonly happiness: FieldRef<"SpiritBeast", 'Int'>
    readonly hunger: FieldRef<"SpiritBeast", 'Int'>
    readonly health: FieldRef<"SpiritBeast", 'Int'>
    readonly isActive: FieldRef<"SpiritBeast", 'Boolean'>
    readonly isFighting: FieldRef<"SpiritBeast", 'Boolean'>
    readonly capturedAt: FieldRef<"SpiritBeast", 'DateTime'>
    readonly lastFedAt: FieldRef<"SpiritBeast", 'DateTime'>
    readonly lastPlayedAt: FieldRef<"SpiritBeast", 'DateTime'>
    readonly createdAt: FieldRef<"SpiritBeast", 'DateTime'>
    readonly updatedAt: FieldRef<"SpiritBeast", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpiritBeast findUnique
   */
  export type SpiritBeastFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    /**
     * Filter, which SpiritBeast to fetch.
     */
    where: SpiritBeastWhereUniqueInput
  }

  /**
   * SpiritBeast findUniqueOrThrow
   */
  export type SpiritBeastFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    /**
     * Filter, which SpiritBeast to fetch.
     */
    where: SpiritBeastWhereUniqueInput
  }

  /**
   * SpiritBeast findFirst
   */
  export type SpiritBeastFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    /**
     * Filter, which SpiritBeast to fetch.
     */
    where?: SpiritBeastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiritBeasts to fetch.
     */
    orderBy?: SpiritBeastOrderByWithRelationInput | SpiritBeastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpiritBeasts.
     */
    cursor?: SpiritBeastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiritBeasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiritBeasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpiritBeasts.
     */
    distinct?: SpiritBeastScalarFieldEnum | SpiritBeastScalarFieldEnum[]
  }

  /**
   * SpiritBeast findFirstOrThrow
   */
  export type SpiritBeastFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    /**
     * Filter, which SpiritBeast to fetch.
     */
    where?: SpiritBeastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiritBeasts to fetch.
     */
    orderBy?: SpiritBeastOrderByWithRelationInput | SpiritBeastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpiritBeasts.
     */
    cursor?: SpiritBeastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiritBeasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiritBeasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpiritBeasts.
     */
    distinct?: SpiritBeastScalarFieldEnum | SpiritBeastScalarFieldEnum[]
  }

  /**
   * SpiritBeast findMany
   */
  export type SpiritBeastFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    /**
     * Filter, which SpiritBeasts to fetch.
     */
    where?: SpiritBeastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiritBeasts to fetch.
     */
    orderBy?: SpiritBeastOrderByWithRelationInput | SpiritBeastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpiritBeasts.
     */
    cursor?: SpiritBeastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiritBeasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiritBeasts.
     */
    skip?: number
    distinct?: SpiritBeastScalarFieldEnum | SpiritBeastScalarFieldEnum[]
  }

  /**
   * SpiritBeast create
   */
  export type SpiritBeastCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    /**
     * The data needed to create a SpiritBeast.
     */
    data: XOR<SpiritBeastCreateInput, SpiritBeastUncheckedCreateInput>
  }

  /**
   * SpiritBeast createMany
   */
  export type SpiritBeastCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpiritBeasts.
     */
    data: SpiritBeastCreateManyInput | SpiritBeastCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpiritBeast createManyAndReturn
   */
  export type SpiritBeastCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpiritBeasts.
     */
    data: SpiritBeastCreateManyInput | SpiritBeastCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpiritBeast update
   */
  export type SpiritBeastUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    /**
     * The data needed to update a SpiritBeast.
     */
    data: XOR<SpiritBeastUpdateInput, SpiritBeastUncheckedUpdateInput>
    /**
     * Choose, which SpiritBeast to update.
     */
    where: SpiritBeastWhereUniqueInput
  }

  /**
   * SpiritBeast updateMany
   */
  export type SpiritBeastUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpiritBeasts.
     */
    data: XOR<SpiritBeastUpdateManyMutationInput, SpiritBeastUncheckedUpdateManyInput>
    /**
     * Filter which SpiritBeasts to update
     */
    where?: SpiritBeastWhereInput
  }

  /**
   * SpiritBeast upsert
   */
  export type SpiritBeastUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    /**
     * The filter to search for the SpiritBeast to update in case it exists.
     */
    where: SpiritBeastWhereUniqueInput
    /**
     * In case the SpiritBeast found by the `where` argument doesn't exist, create a new SpiritBeast with this data.
     */
    create: XOR<SpiritBeastCreateInput, SpiritBeastUncheckedCreateInput>
    /**
     * In case the SpiritBeast was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpiritBeastUpdateInput, SpiritBeastUncheckedUpdateInput>
  }

  /**
   * SpiritBeast delete
   */
  export type SpiritBeastDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    /**
     * Filter which SpiritBeast to delete.
     */
    where: SpiritBeastWhereUniqueInput
  }

  /**
   * SpiritBeast deleteMany
   */
  export type SpiritBeastDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpiritBeasts to delete
     */
    where?: SpiritBeastWhereInput
  }

  /**
   * SpiritBeast.feedingHistory
   */
  export type SpiritBeast$feedingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    where?: BeastFeedingHistoryWhereInput
    orderBy?: BeastFeedingHistoryOrderByWithRelationInput | BeastFeedingHistoryOrderByWithRelationInput[]
    cursor?: BeastFeedingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeastFeedingHistoryScalarFieldEnum | BeastFeedingHistoryScalarFieldEnum[]
  }

  /**
   * SpiritBeast.huntingHistory
   */
  export type SpiritBeast$huntingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    where?: HuntingHistoryWhereInput
    orderBy?: HuntingHistoryOrderByWithRelationInput | HuntingHistoryOrderByWithRelationInput[]
    cursor?: HuntingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HuntingHistoryScalarFieldEnum | HuntingHistoryScalarFieldEnum[]
  }

  /**
   * SpiritBeast without action
   */
  export type SpiritBeastDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
  }


  /**
   * Model BeastFood
   */

  export type AggregateBeastFood = {
    _count: BeastFoodCountAggregateOutputType | null
    _avg: BeastFoodAvgAggregateOutputType | null
    _sum: BeastFoodSumAggregateOutputType | null
    _min: BeastFoodMinAggregateOutputType | null
    _max: BeastFoodMaxAggregateOutputType | null
  }

  export type BeastFoodAvgAggregateOutputType = {
    price: number | null
  }

  export type BeastFoodSumAggregateOutputType = {
    price: number | null
  }

  export type BeastFoodMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    effects: string | null
    price: number | null
    currency: string | null
    icon: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BeastFoodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    effects: string | null
    price: number | null
    currency: string | null
    icon: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BeastFoodCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    category: number
    effects: number
    price: number
    currency: number
    icon: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BeastFoodAvgAggregateInputType = {
    price?: true
  }

  export type BeastFoodSumAggregateInputType = {
    price?: true
  }

  export type BeastFoodMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    effects?: true
    price?: true
    currency?: true
    icon?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BeastFoodMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    effects?: true
    price?: true
    currency?: true
    icon?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BeastFoodCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    effects?: true
    price?: true
    currency?: true
    icon?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BeastFoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BeastFood to aggregate.
     */
    where?: BeastFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeastFoods to fetch.
     */
    orderBy?: BeastFoodOrderByWithRelationInput | BeastFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BeastFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeastFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeastFoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BeastFoods
    **/
    _count?: true | BeastFoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BeastFoodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BeastFoodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeastFoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeastFoodMaxAggregateInputType
  }

  export type GetBeastFoodAggregateType<T extends BeastFoodAggregateArgs> = {
        [P in keyof T & keyof AggregateBeastFood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeastFood[P]>
      : GetScalarType<T[P], AggregateBeastFood[P]>
  }




  export type BeastFoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeastFoodWhereInput
    orderBy?: BeastFoodOrderByWithAggregationInput | BeastFoodOrderByWithAggregationInput[]
    by: BeastFoodScalarFieldEnum[] | BeastFoodScalarFieldEnum
    having?: BeastFoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeastFoodCountAggregateInputType | true
    _avg?: BeastFoodAvgAggregateInputType
    _sum?: BeastFoodSumAggregateInputType
    _min?: BeastFoodMinAggregateInputType
    _max?: BeastFoodMaxAggregateInputType
  }

  export type BeastFoodGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    category: string
    effects: string
    price: number
    currency: string
    icon: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BeastFoodCountAggregateOutputType | null
    _avg: BeastFoodAvgAggregateOutputType | null
    _sum: BeastFoodSumAggregateOutputType | null
    _min: BeastFoodMinAggregateOutputType | null
    _max: BeastFoodMaxAggregateOutputType | null
  }

  type GetBeastFoodGroupByPayload<T extends BeastFoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BeastFoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeastFoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeastFoodGroupByOutputType[P]>
            : GetScalarType<T[P], BeastFoodGroupByOutputType[P]>
        }
      >
    >


  export type BeastFoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    effects?: boolean
    price?: boolean
    currency?: boolean
    icon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feedingHistory?: boolean | BeastFood$feedingHistoryArgs<ExtArgs>
    _count?: boolean | BeastFoodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beastFood"]>

  export type BeastFoodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    effects?: boolean
    price?: boolean
    currency?: boolean
    icon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["beastFood"]>

  export type BeastFoodSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    effects?: boolean
    price?: boolean
    currency?: boolean
    icon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BeastFoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedingHistory?: boolean | BeastFood$feedingHistoryArgs<ExtArgs>
    _count?: boolean | BeastFoodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BeastFoodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BeastFoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BeastFood"
    objects: {
      feedingHistory: Prisma.$BeastFeedingHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      category: string
      effects: string
      price: number
      currency: string
      icon: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["beastFood"]>
    composites: {}
  }

  type BeastFoodGetPayload<S extends boolean | null | undefined | BeastFoodDefaultArgs> = $Result.GetResult<Prisma.$BeastFoodPayload, S>

  type BeastFoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BeastFoodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BeastFoodCountAggregateInputType | true
    }

  export interface BeastFoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BeastFood'], meta: { name: 'BeastFood' } }
    /**
     * Find zero or one BeastFood that matches the filter.
     * @param {BeastFoodFindUniqueArgs} args - Arguments to find a BeastFood
     * @example
     * // Get one BeastFood
     * const beastFood = await prisma.beastFood.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BeastFoodFindUniqueArgs>(args: SelectSubset<T, BeastFoodFindUniqueArgs<ExtArgs>>): Prisma__BeastFoodClient<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BeastFood that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BeastFoodFindUniqueOrThrowArgs} args - Arguments to find a BeastFood
     * @example
     * // Get one BeastFood
     * const beastFood = await prisma.beastFood.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BeastFoodFindUniqueOrThrowArgs>(args: SelectSubset<T, BeastFoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BeastFoodClient<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BeastFood that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFoodFindFirstArgs} args - Arguments to find a BeastFood
     * @example
     * // Get one BeastFood
     * const beastFood = await prisma.beastFood.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BeastFoodFindFirstArgs>(args?: SelectSubset<T, BeastFoodFindFirstArgs<ExtArgs>>): Prisma__BeastFoodClient<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BeastFood that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFoodFindFirstOrThrowArgs} args - Arguments to find a BeastFood
     * @example
     * // Get one BeastFood
     * const beastFood = await prisma.beastFood.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BeastFoodFindFirstOrThrowArgs>(args?: SelectSubset<T, BeastFoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__BeastFoodClient<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BeastFoods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BeastFoods
     * const beastFoods = await prisma.beastFood.findMany()
     * 
     * // Get first 10 BeastFoods
     * const beastFoods = await prisma.beastFood.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beastFoodWithIdOnly = await prisma.beastFood.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BeastFoodFindManyArgs>(args?: SelectSubset<T, BeastFoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BeastFood.
     * @param {BeastFoodCreateArgs} args - Arguments to create a BeastFood.
     * @example
     * // Create one BeastFood
     * const BeastFood = await prisma.beastFood.create({
     *   data: {
     *     // ... data to create a BeastFood
     *   }
     * })
     * 
     */
    create<T extends BeastFoodCreateArgs>(args: SelectSubset<T, BeastFoodCreateArgs<ExtArgs>>): Prisma__BeastFoodClient<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BeastFoods.
     * @param {BeastFoodCreateManyArgs} args - Arguments to create many BeastFoods.
     * @example
     * // Create many BeastFoods
     * const beastFood = await prisma.beastFood.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BeastFoodCreateManyArgs>(args?: SelectSubset<T, BeastFoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BeastFoods and returns the data saved in the database.
     * @param {BeastFoodCreateManyAndReturnArgs} args - Arguments to create many BeastFoods.
     * @example
     * // Create many BeastFoods
     * const beastFood = await prisma.beastFood.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BeastFoods and only return the `id`
     * const beastFoodWithIdOnly = await prisma.beastFood.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BeastFoodCreateManyAndReturnArgs>(args?: SelectSubset<T, BeastFoodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BeastFood.
     * @param {BeastFoodDeleteArgs} args - Arguments to delete one BeastFood.
     * @example
     * // Delete one BeastFood
     * const BeastFood = await prisma.beastFood.delete({
     *   where: {
     *     // ... filter to delete one BeastFood
     *   }
     * })
     * 
     */
    delete<T extends BeastFoodDeleteArgs>(args: SelectSubset<T, BeastFoodDeleteArgs<ExtArgs>>): Prisma__BeastFoodClient<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BeastFood.
     * @param {BeastFoodUpdateArgs} args - Arguments to update one BeastFood.
     * @example
     * // Update one BeastFood
     * const beastFood = await prisma.beastFood.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BeastFoodUpdateArgs>(args: SelectSubset<T, BeastFoodUpdateArgs<ExtArgs>>): Prisma__BeastFoodClient<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BeastFoods.
     * @param {BeastFoodDeleteManyArgs} args - Arguments to filter BeastFoods to delete.
     * @example
     * // Delete a few BeastFoods
     * const { count } = await prisma.beastFood.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BeastFoodDeleteManyArgs>(args?: SelectSubset<T, BeastFoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BeastFoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BeastFoods
     * const beastFood = await prisma.beastFood.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BeastFoodUpdateManyArgs>(args: SelectSubset<T, BeastFoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BeastFood.
     * @param {BeastFoodUpsertArgs} args - Arguments to update or create a BeastFood.
     * @example
     * // Update or create a BeastFood
     * const beastFood = await prisma.beastFood.upsert({
     *   create: {
     *     // ... data to create a BeastFood
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BeastFood we want to update
     *   }
     * })
     */
    upsert<T extends BeastFoodUpsertArgs>(args: SelectSubset<T, BeastFoodUpsertArgs<ExtArgs>>): Prisma__BeastFoodClient<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BeastFoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFoodCountArgs} args - Arguments to filter BeastFoods to count.
     * @example
     * // Count the number of BeastFoods
     * const count = await prisma.beastFood.count({
     *   where: {
     *     // ... the filter for the BeastFoods we want to count
     *   }
     * })
    **/
    count<T extends BeastFoodCountArgs>(
      args?: Subset<T, BeastFoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeastFoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BeastFood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeastFoodAggregateArgs>(args: Subset<T, BeastFoodAggregateArgs>): Prisma.PrismaPromise<GetBeastFoodAggregateType<T>>

    /**
     * Group by BeastFood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BeastFoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BeastFoodGroupByArgs['orderBy'] }
        : { orderBy?: BeastFoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BeastFoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeastFoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BeastFood model
   */
  readonly fields: BeastFoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BeastFood.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BeastFoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedingHistory<T extends BeastFood$feedingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, BeastFood$feedingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BeastFood model
   */ 
  interface BeastFoodFieldRefs {
    readonly id: FieldRef<"BeastFood", 'String'>
    readonly name: FieldRef<"BeastFood", 'String'>
    readonly displayName: FieldRef<"BeastFood", 'String'>
    readonly description: FieldRef<"BeastFood", 'String'>
    readonly category: FieldRef<"BeastFood", 'String'>
    readonly effects: FieldRef<"BeastFood", 'String'>
    readonly price: FieldRef<"BeastFood", 'Int'>
    readonly currency: FieldRef<"BeastFood", 'String'>
    readonly icon: FieldRef<"BeastFood", 'String'>
    readonly isActive: FieldRef<"BeastFood", 'Boolean'>
    readonly createdAt: FieldRef<"BeastFood", 'DateTime'>
    readonly updatedAt: FieldRef<"BeastFood", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BeastFood findUnique
   */
  export type BeastFoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFoodInclude<ExtArgs> | null
    /**
     * Filter, which BeastFood to fetch.
     */
    where: BeastFoodWhereUniqueInput
  }

  /**
   * BeastFood findUniqueOrThrow
   */
  export type BeastFoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFoodInclude<ExtArgs> | null
    /**
     * Filter, which BeastFood to fetch.
     */
    where: BeastFoodWhereUniqueInput
  }

  /**
   * BeastFood findFirst
   */
  export type BeastFoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFoodInclude<ExtArgs> | null
    /**
     * Filter, which BeastFood to fetch.
     */
    where?: BeastFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeastFoods to fetch.
     */
    orderBy?: BeastFoodOrderByWithRelationInput | BeastFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BeastFoods.
     */
    cursor?: BeastFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeastFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeastFoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BeastFoods.
     */
    distinct?: BeastFoodScalarFieldEnum | BeastFoodScalarFieldEnum[]
  }

  /**
   * BeastFood findFirstOrThrow
   */
  export type BeastFoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFoodInclude<ExtArgs> | null
    /**
     * Filter, which BeastFood to fetch.
     */
    where?: BeastFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeastFoods to fetch.
     */
    orderBy?: BeastFoodOrderByWithRelationInput | BeastFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BeastFoods.
     */
    cursor?: BeastFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeastFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeastFoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BeastFoods.
     */
    distinct?: BeastFoodScalarFieldEnum | BeastFoodScalarFieldEnum[]
  }

  /**
   * BeastFood findMany
   */
  export type BeastFoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFoodInclude<ExtArgs> | null
    /**
     * Filter, which BeastFoods to fetch.
     */
    where?: BeastFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeastFoods to fetch.
     */
    orderBy?: BeastFoodOrderByWithRelationInput | BeastFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BeastFoods.
     */
    cursor?: BeastFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeastFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeastFoods.
     */
    skip?: number
    distinct?: BeastFoodScalarFieldEnum | BeastFoodScalarFieldEnum[]
  }

  /**
   * BeastFood create
   */
  export type BeastFoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFoodInclude<ExtArgs> | null
    /**
     * The data needed to create a BeastFood.
     */
    data: XOR<BeastFoodCreateInput, BeastFoodUncheckedCreateInput>
  }

  /**
   * BeastFood createMany
   */
  export type BeastFoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BeastFoods.
     */
    data: BeastFoodCreateManyInput | BeastFoodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BeastFood createManyAndReturn
   */
  export type BeastFoodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BeastFoods.
     */
    data: BeastFoodCreateManyInput | BeastFoodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BeastFood update
   */
  export type BeastFoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFoodInclude<ExtArgs> | null
    /**
     * The data needed to update a BeastFood.
     */
    data: XOR<BeastFoodUpdateInput, BeastFoodUncheckedUpdateInput>
    /**
     * Choose, which BeastFood to update.
     */
    where: BeastFoodWhereUniqueInput
  }

  /**
   * BeastFood updateMany
   */
  export type BeastFoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BeastFoods.
     */
    data: XOR<BeastFoodUpdateManyMutationInput, BeastFoodUncheckedUpdateManyInput>
    /**
     * Filter which BeastFoods to update
     */
    where?: BeastFoodWhereInput
  }

  /**
   * BeastFood upsert
   */
  export type BeastFoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFoodInclude<ExtArgs> | null
    /**
     * The filter to search for the BeastFood to update in case it exists.
     */
    where: BeastFoodWhereUniqueInput
    /**
     * In case the BeastFood found by the `where` argument doesn't exist, create a new BeastFood with this data.
     */
    create: XOR<BeastFoodCreateInput, BeastFoodUncheckedCreateInput>
    /**
     * In case the BeastFood was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BeastFoodUpdateInput, BeastFoodUncheckedUpdateInput>
  }

  /**
   * BeastFood delete
   */
  export type BeastFoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFoodInclude<ExtArgs> | null
    /**
     * Filter which BeastFood to delete.
     */
    where: BeastFoodWhereUniqueInput
  }

  /**
   * BeastFood deleteMany
   */
  export type BeastFoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BeastFoods to delete
     */
    where?: BeastFoodWhereInput
  }

  /**
   * BeastFood.feedingHistory
   */
  export type BeastFood$feedingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    where?: BeastFeedingHistoryWhereInput
    orderBy?: BeastFeedingHistoryOrderByWithRelationInput | BeastFeedingHistoryOrderByWithRelationInput[]
    cursor?: BeastFeedingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeastFeedingHistoryScalarFieldEnum | BeastFeedingHistoryScalarFieldEnum[]
  }

  /**
   * BeastFood without action
   */
  export type BeastFoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFood
     */
    select?: BeastFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFoodInclude<ExtArgs> | null
  }


  /**
   * Model BeastFeedingHistory
   */

  export type AggregateBeastFeedingHistory = {
    _count: BeastFeedingHistoryCountAggregateOutputType | null
    _avg: BeastFeedingHistoryAvgAggregateOutputType | null
    _sum: BeastFeedingHistorySumAggregateOutputType | null
    _min: BeastFeedingHistoryMinAggregateOutputType | null
    _max: BeastFeedingHistoryMaxAggregateOutputType | null
  }

  export type BeastFeedingHistoryAvgAggregateOutputType = {
    quantity: number | null
  }

  export type BeastFeedingHistorySumAggregateOutputType = {
    quantity: number | null
  }

  export type BeastFeedingHistoryMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    beastId: string | null
    foodId: string | null
    quantity: number | null
    effects: string | null
    createdAt: Date | null
  }

  export type BeastFeedingHistoryMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    beastId: string | null
    foodId: string | null
    quantity: number | null
    effects: string | null
    createdAt: Date | null
  }

  export type BeastFeedingHistoryCountAggregateOutputType = {
    id: number
    playerId: number
    beastId: number
    foodId: number
    quantity: number
    effects: number
    createdAt: number
    _all: number
  }


  export type BeastFeedingHistoryAvgAggregateInputType = {
    quantity?: true
  }

  export type BeastFeedingHistorySumAggregateInputType = {
    quantity?: true
  }

  export type BeastFeedingHistoryMinAggregateInputType = {
    id?: true
    playerId?: true
    beastId?: true
    foodId?: true
    quantity?: true
    effects?: true
    createdAt?: true
  }

  export type BeastFeedingHistoryMaxAggregateInputType = {
    id?: true
    playerId?: true
    beastId?: true
    foodId?: true
    quantity?: true
    effects?: true
    createdAt?: true
  }

  export type BeastFeedingHistoryCountAggregateInputType = {
    id?: true
    playerId?: true
    beastId?: true
    foodId?: true
    quantity?: true
    effects?: true
    createdAt?: true
    _all?: true
  }

  export type BeastFeedingHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BeastFeedingHistory to aggregate.
     */
    where?: BeastFeedingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeastFeedingHistories to fetch.
     */
    orderBy?: BeastFeedingHistoryOrderByWithRelationInput | BeastFeedingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BeastFeedingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeastFeedingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeastFeedingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BeastFeedingHistories
    **/
    _count?: true | BeastFeedingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BeastFeedingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BeastFeedingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeastFeedingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeastFeedingHistoryMaxAggregateInputType
  }

  export type GetBeastFeedingHistoryAggregateType<T extends BeastFeedingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBeastFeedingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeastFeedingHistory[P]>
      : GetScalarType<T[P], AggregateBeastFeedingHistory[P]>
  }




  export type BeastFeedingHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeastFeedingHistoryWhereInput
    orderBy?: BeastFeedingHistoryOrderByWithAggregationInput | BeastFeedingHistoryOrderByWithAggregationInput[]
    by: BeastFeedingHistoryScalarFieldEnum[] | BeastFeedingHistoryScalarFieldEnum
    having?: BeastFeedingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeastFeedingHistoryCountAggregateInputType | true
    _avg?: BeastFeedingHistoryAvgAggregateInputType
    _sum?: BeastFeedingHistorySumAggregateInputType
    _min?: BeastFeedingHistoryMinAggregateInputType
    _max?: BeastFeedingHistoryMaxAggregateInputType
  }

  export type BeastFeedingHistoryGroupByOutputType = {
    id: string
    playerId: string
    beastId: string
    foodId: string
    quantity: number
    effects: string
    createdAt: Date
    _count: BeastFeedingHistoryCountAggregateOutputType | null
    _avg: BeastFeedingHistoryAvgAggregateOutputType | null
    _sum: BeastFeedingHistorySumAggregateOutputType | null
    _min: BeastFeedingHistoryMinAggregateOutputType | null
    _max: BeastFeedingHistoryMaxAggregateOutputType | null
  }

  type GetBeastFeedingHistoryGroupByPayload<T extends BeastFeedingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BeastFeedingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeastFeedingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeastFeedingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], BeastFeedingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type BeastFeedingHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    beastId?: boolean
    foodId?: boolean
    quantity?: boolean
    effects?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    beast?: boolean | SpiritBeastDefaultArgs<ExtArgs>
    food?: boolean | BeastFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beastFeedingHistory"]>

  export type BeastFeedingHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    beastId?: boolean
    foodId?: boolean
    quantity?: boolean
    effects?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    beast?: boolean | SpiritBeastDefaultArgs<ExtArgs>
    food?: boolean | BeastFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beastFeedingHistory"]>

  export type BeastFeedingHistorySelectScalar = {
    id?: boolean
    playerId?: boolean
    beastId?: boolean
    foodId?: boolean
    quantity?: boolean
    effects?: boolean
    createdAt?: boolean
  }

  export type BeastFeedingHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    beast?: boolean | SpiritBeastDefaultArgs<ExtArgs>
    food?: boolean | BeastFoodDefaultArgs<ExtArgs>
  }
  export type BeastFeedingHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    beast?: boolean | SpiritBeastDefaultArgs<ExtArgs>
    food?: boolean | BeastFoodDefaultArgs<ExtArgs>
  }

  export type $BeastFeedingHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BeastFeedingHistory"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      beast: Prisma.$SpiritBeastPayload<ExtArgs>
      food: Prisma.$BeastFoodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      beastId: string
      foodId: string
      quantity: number
      effects: string
      createdAt: Date
    }, ExtArgs["result"]["beastFeedingHistory"]>
    composites: {}
  }

  type BeastFeedingHistoryGetPayload<S extends boolean | null | undefined | BeastFeedingHistoryDefaultArgs> = $Result.GetResult<Prisma.$BeastFeedingHistoryPayload, S>

  type BeastFeedingHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BeastFeedingHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BeastFeedingHistoryCountAggregateInputType | true
    }

  export interface BeastFeedingHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BeastFeedingHistory'], meta: { name: 'BeastFeedingHistory' } }
    /**
     * Find zero or one BeastFeedingHistory that matches the filter.
     * @param {BeastFeedingHistoryFindUniqueArgs} args - Arguments to find a BeastFeedingHistory
     * @example
     * // Get one BeastFeedingHistory
     * const beastFeedingHistory = await prisma.beastFeedingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BeastFeedingHistoryFindUniqueArgs>(args: SelectSubset<T, BeastFeedingHistoryFindUniqueArgs<ExtArgs>>): Prisma__BeastFeedingHistoryClient<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BeastFeedingHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BeastFeedingHistoryFindUniqueOrThrowArgs} args - Arguments to find a BeastFeedingHistory
     * @example
     * // Get one BeastFeedingHistory
     * const beastFeedingHistory = await prisma.beastFeedingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BeastFeedingHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BeastFeedingHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BeastFeedingHistoryClient<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BeastFeedingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFeedingHistoryFindFirstArgs} args - Arguments to find a BeastFeedingHistory
     * @example
     * // Get one BeastFeedingHistory
     * const beastFeedingHistory = await prisma.beastFeedingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BeastFeedingHistoryFindFirstArgs>(args?: SelectSubset<T, BeastFeedingHistoryFindFirstArgs<ExtArgs>>): Prisma__BeastFeedingHistoryClient<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BeastFeedingHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFeedingHistoryFindFirstOrThrowArgs} args - Arguments to find a BeastFeedingHistory
     * @example
     * // Get one BeastFeedingHistory
     * const beastFeedingHistory = await prisma.beastFeedingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BeastFeedingHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BeastFeedingHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BeastFeedingHistoryClient<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BeastFeedingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFeedingHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BeastFeedingHistories
     * const beastFeedingHistories = await prisma.beastFeedingHistory.findMany()
     * 
     * // Get first 10 BeastFeedingHistories
     * const beastFeedingHistories = await prisma.beastFeedingHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beastFeedingHistoryWithIdOnly = await prisma.beastFeedingHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BeastFeedingHistoryFindManyArgs>(args?: SelectSubset<T, BeastFeedingHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BeastFeedingHistory.
     * @param {BeastFeedingHistoryCreateArgs} args - Arguments to create a BeastFeedingHistory.
     * @example
     * // Create one BeastFeedingHistory
     * const BeastFeedingHistory = await prisma.beastFeedingHistory.create({
     *   data: {
     *     // ... data to create a BeastFeedingHistory
     *   }
     * })
     * 
     */
    create<T extends BeastFeedingHistoryCreateArgs>(args: SelectSubset<T, BeastFeedingHistoryCreateArgs<ExtArgs>>): Prisma__BeastFeedingHistoryClient<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BeastFeedingHistories.
     * @param {BeastFeedingHistoryCreateManyArgs} args - Arguments to create many BeastFeedingHistories.
     * @example
     * // Create many BeastFeedingHistories
     * const beastFeedingHistory = await prisma.beastFeedingHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BeastFeedingHistoryCreateManyArgs>(args?: SelectSubset<T, BeastFeedingHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BeastFeedingHistories and returns the data saved in the database.
     * @param {BeastFeedingHistoryCreateManyAndReturnArgs} args - Arguments to create many BeastFeedingHistories.
     * @example
     * // Create many BeastFeedingHistories
     * const beastFeedingHistory = await prisma.beastFeedingHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BeastFeedingHistories and only return the `id`
     * const beastFeedingHistoryWithIdOnly = await prisma.beastFeedingHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BeastFeedingHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BeastFeedingHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BeastFeedingHistory.
     * @param {BeastFeedingHistoryDeleteArgs} args - Arguments to delete one BeastFeedingHistory.
     * @example
     * // Delete one BeastFeedingHistory
     * const BeastFeedingHistory = await prisma.beastFeedingHistory.delete({
     *   where: {
     *     // ... filter to delete one BeastFeedingHistory
     *   }
     * })
     * 
     */
    delete<T extends BeastFeedingHistoryDeleteArgs>(args: SelectSubset<T, BeastFeedingHistoryDeleteArgs<ExtArgs>>): Prisma__BeastFeedingHistoryClient<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BeastFeedingHistory.
     * @param {BeastFeedingHistoryUpdateArgs} args - Arguments to update one BeastFeedingHistory.
     * @example
     * // Update one BeastFeedingHistory
     * const beastFeedingHistory = await prisma.beastFeedingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BeastFeedingHistoryUpdateArgs>(args: SelectSubset<T, BeastFeedingHistoryUpdateArgs<ExtArgs>>): Prisma__BeastFeedingHistoryClient<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BeastFeedingHistories.
     * @param {BeastFeedingHistoryDeleteManyArgs} args - Arguments to filter BeastFeedingHistories to delete.
     * @example
     * // Delete a few BeastFeedingHistories
     * const { count } = await prisma.beastFeedingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BeastFeedingHistoryDeleteManyArgs>(args?: SelectSubset<T, BeastFeedingHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BeastFeedingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFeedingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BeastFeedingHistories
     * const beastFeedingHistory = await prisma.beastFeedingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BeastFeedingHistoryUpdateManyArgs>(args: SelectSubset<T, BeastFeedingHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BeastFeedingHistory.
     * @param {BeastFeedingHistoryUpsertArgs} args - Arguments to update or create a BeastFeedingHistory.
     * @example
     * // Update or create a BeastFeedingHistory
     * const beastFeedingHistory = await prisma.beastFeedingHistory.upsert({
     *   create: {
     *     // ... data to create a BeastFeedingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BeastFeedingHistory we want to update
     *   }
     * })
     */
    upsert<T extends BeastFeedingHistoryUpsertArgs>(args: SelectSubset<T, BeastFeedingHistoryUpsertArgs<ExtArgs>>): Prisma__BeastFeedingHistoryClient<$Result.GetResult<Prisma.$BeastFeedingHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BeastFeedingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFeedingHistoryCountArgs} args - Arguments to filter BeastFeedingHistories to count.
     * @example
     * // Count the number of BeastFeedingHistories
     * const count = await prisma.beastFeedingHistory.count({
     *   where: {
     *     // ... the filter for the BeastFeedingHistories we want to count
     *   }
     * })
    **/
    count<T extends BeastFeedingHistoryCountArgs>(
      args?: Subset<T, BeastFeedingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeastFeedingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BeastFeedingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFeedingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeastFeedingHistoryAggregateArgs>(args: Subset<T, BeastFeedingHistoryAggregateArgs>): Prisma.PrismaPromise<GetBeastFeedingHistoryAggregateType<T>>

    /**
     * Group by BeastFeedingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeastFeedingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BeastFeedingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BeastFeedingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: BeastFeedingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BeastFeedingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeastFeedingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BeastFeedingHistory model
   */
  readonly fields: BeastFeedingHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BeastFeedingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BeastFeedingHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    beast<T extends SpiritBeastDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpiritBeastDefaultArgs<ExtArgs>>): Prisma__SpiritBeastClient<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    food<T extends BeastFoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BeastFoodDefaultArgs<ExtArgs>>): Prisma__BeastFoodClient<$Result.GetResult<Prisma.$BeastFoodPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BeastFeedingHistory model
   */ 
  interface BeastFeedingHistoryFieldRefs {
    readonly id: FieldRef<"BeastFeedingHistory", 'String'>
    readonly playerId: FieldRef<"BeastFeedingHistory", 'String'>
    readonly beastId: FieldRef<"BeastFeedingHistory", 'String'>
    readonly foodId: FieldRef<"BeastFeedingHistory", 'String'>
    readonly quantity: FieldRef<"BeastFeedingHistory", 'Int'>
    readonly effects: FieldRef<"BeastFeedingHistory", 'String'>
    readonly createdAt: FieldRef<"BeastFeedingHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BeastFeedingHistory findUnique
   */
  export type BeastFeedingHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BeastFeedingHistory to fetch.
     */
    where: BeastFeedingHistoryWhereUniqueInput
  }

  /**
   * BeastFeedingHistory findUniqueOrThrow
   */
  export type BeastFeedingHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BeastFeedingHistory to fetch.
     */
    where: BeastFeedingHistoryWhereUniqueInput
  }

  /**
   * BeastFeedingHistory findFirst
   */
  export type BeastFeedingHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BeastFeedingHistory to fetch.
     */
    where?: BeastFeedingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeastFeedingHistories to fetch.
     */
    orderBy?: BeastFeedingHistoryOrderByWithRelationInput | BeastFeedingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BeastFeedingHistories.
     */
    cursor?: BeastFeedingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeastFeedingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeastFeedingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BeastFeedingHistories.
     */
    distinct?: BeastFeedingHistoryScalarFieldEnum | BeastFeedingHistoryScalarFieldEnum[]
  }

  /**
   * BeastFeedingHistory findFirstOrThrow
   */
  export type BeastFeedingHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BeastFeedingHistory to fetch.
     */
    where?: BeastFeedingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeastFeedingHistories to fetch.
     */
    orderBy?: BeastFeedingHistoryOrderByWithRelationInput | BeastFeedingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BeastFeedingHistories.
     */
    cursor?: BeastFeedingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeastFeedingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeastFeedingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BeastFeedingHistories.
     */
    distinct?: BeastFeedingHistoryScalarFieldEnum | BeastFeedingHistoryScalarFieldEnum[]
  }

  /**
   * BeastFeedingHistory findMany
   */
  export type BeastFeedingHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BeastFeedingHistories to fetch.
     */
    where?: BeastFeedingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeastFeedingHistories to fetch.
     */
    orderBy?: BeastFeedingHistoryOrderByWithRelationInput | BeastFeedingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BeastFeedingHistories.
     */
    cursor?: BeastFeedingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeastFeedingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeastFeedingHistories.
     */
    skip?: number
    distinct?: BeastFeedingHistoryScalarFieldEnum | BeastFeedingHistoryScalarFieldEnum[]
  }

  /**
   * BeastFeedingHistory create
   */
  export type BeastFeedingHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BeastFeedingHistory.
     */
    data: XOR<BeastFeedingHistoryCreateInput, BeastFeedingHistoryUncheckedCreateInput>
  }

  /**
   * BeastFeedingHistory createMany
   */
  export type BeastFeedingHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BeastFeedingHistories.
     */
    data: BeastFeedingHistoryCreateManyInput | BeastFeedingHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BeastFeedingHistory createManyAndReturn
   */
  export type BeastFeedingHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BeastFeedingHistories.
     */
    data: BeastFeedingHistoryCreateManyInput | BeastFeedingHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BeastFeedingHistory update
   */
  export type BeastFeedingHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BeastFeedingHistory.
     */
    data: XOR<BeastFeedingHistoryUpdateInput, BeastFeedingHistoryUncheckedUpdateInput>
    /**
     * Choose, which BeastFeedingHistory to update.
     */
    where: BeastFeedingHistoryWhereUniqueInput
  }

  /**
   * BeastFeedingHistory updateMany
   */
  export type BeastFeedingHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BeastFeedingHistories.
     */
    data: XOR<BeastFeedingHistoryUpdateManyMutationInput, BeastFeedingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BeastFeedingHistories to update
     */
    where?: BeastFeedingHistoryWhereInput
  }

  /**
   * BeastFeedingHistory upsert
   */
  export type BeastFeedingHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BeastFeedingHistory to update in case it exists.
     */
    where: BeastFeedingHistoryWhereUniqueInput
    /**
     * In case the BeastFeedingHistory found by the `where` argument doesn't exist, create a new BeastFeedingHistory with this data.
     */
    create: XOR<BeastFeedingHistoryCreateInput, BeastFeedingHistoryUncheckedCreateInput>
    /**
     * In case the BeastFeedingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BeastFeedingHistoryUpdateInput, BeastFeedingHistoryUncheckedUpdateInput>
  }

  /**
   * BeastFeedingHistory delete
   */
  export type BeastFeedingHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
    /**
     * Filter which BeastFeedingHistory to delete.
     */
    where: BeastFeedingHistoryWhereUniqueInput
  }

  /**
   * BeastFeedingHistory deleteMany
   */
  export type BeastFeedingHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BeastFeedingHistories to delete
     */
    where?: BeastFeedingHistoryWhereInput
  }

  /**
   * BeastFeedingHistory without action
   */
  export type BeastFeedingHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeastFeedingHistory
     */
    select?: BeastFeedingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeastFeedingHistoryInclude<ExtArgs> | null
  }


  /**
   * Model HuntingGround
   */

  export type AggregateHuntingGround = {
    _count: HuntingGroundCountAggregateOutputType | null
    _avg: HuntingGroundAvgAggregateOutputType | null
    _sum: HuntingGroundSumAggregateOutputType | null
    _min: HuntingGroundMinAggregateOutputType | null
    _max: HuntingGroundMaxAggregateOutputType | null
  }

  export type HuntingGroundAvgAggregateOutputType = {
    level: number | null
    maxLevel: number | null
  }

  export type HuntingGroundSumAggregateOutputType = {
    level: number | null
    maxLevel: number | null
  }

  export type HuntingGroundMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    level: number | null
    maxLevel: number | null
    difficulty: string | null
    beastTypes: string | null
    dropRates: string | null
    isActive: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HuntingGroundMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    level: number | null
    maxLevel: number | null
    difficulty: string | null
    beastTypes: string | null
    dropRates: string | null
    isActive: boolean | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HuntingGroundCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    level: number
    maxLevel: number
    difficulty: number
    beastTypes: number
    dropRates: number
    isActive: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HuntingGroundAvgAggregateInputType = {
    level?: true
    maxLevel?: true
  }

  export type HuntingGroundSumAggregateInputType = {
    level?: true
    maxLevel?: true
  }

  export type HuntingGroundMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    level?: true
    maxLevel?: true
    difficulty?: true
    beastTypes?: true
    dropRates?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HuntingGroundMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    level?: true
    maxLevel?: true
    difficulty?: true
    beastTypes?: true
    dropRates?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HuntingGroundCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    level?: true
    maxLevel?: true
    difficulty?: true
    beastTypes?: true
    dropRates?: true
    isActive?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HuntingGroundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HuntingGround to aggregate.
     */
    where?: HuntingGroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HuntingGrounds to fetch.
     */
    orderBy?: HuntingGroundOrderByWithRelationInput | HuntingGroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HuntingGroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HuntingGrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HuntingGrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HuntingGrounds
    **/
    _count?: true | HuntingGroundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HuntingGroundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HuntingGroundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HuntingGroundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HuntingGroundMaxAggregateInputType
  }

  export type GetHuntingGroundAggregateType<T extends HuntingGroundAggregateArgs> = {
        [P in keyof T & keyof AggregateHuntingGround]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHuntingGround[P]>
      : GetScalarType<T[P], AggregateHuntingGround[P]>
  }




  export type HuntingGroundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HuntingGroundWhereInput
    orderBy?: HuntingGroundOrderByWithAggregationInput | HuntingGroundOrderByWithAggregationInput[]
    by: HuntingGroundScalarFieldEnum[] | HuntingGroundScalarFieldEnum
    having?: HuntingGroundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HuntingGroundCountAggregateInputType | true
    _avg?: HuntingGroundAvgAggregateInputType
    _sum?: HuntingGroundSumAggregateInputType
    _min?: HuntingGroundMinAggregateInputType
    _max?: HuntingGroundMaxAggregateInputType
  }

  export type HuntingGroundGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    level: number
    maxLevel: number
    difficulty: string
    beastTypes: string
    dropRates: string
    isActive: boolean
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: HuntingGroundCountAggregateOutputType | null
    _avg: HuntingGroundAvgAggregateOutputType | null
    _sum: HuntingGroundSumAggregateOutputType | null
    _min: HuntingGroundMinAggregateOutputType | null
    _max: HuntingGroundMaxAggregateOutputType | null
  }

  type GetHuntingGroundGroupByPayload<T extends HuntingGroundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HuntingGroundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HuntingGroundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HuntingGroundGroupByOutputType[P]>
            : GetScalarType<T[P], HuntingGroundGroupByOutputType[P]>
        }
      >
    >


  export type HuntingGroundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    level?: boolean
    maxLevel?: boolean
    difficulty?: boolean
    beastTypes?: boolean
    dropRates?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    huntingHistory?: boolean | HuntingGround$huntingHistoryArgs<ExtArgs>
    _count?: boolean | HuntingGroundCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["huntingGround"]>

  export type HuntingGroundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    level?: boolean
    maxLevel?: boolean
    difficulty?: boolean
    beastTypes?: boolean
    dropRates?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["huntingGround"]>

  export type HuntingGroundSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    level?: boolean
    maxLevel?: boolean
    difficulty?: boolean
    beastTypes?: boolean
    dropRates?: boolean
    isActive?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HuntingGroundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    huntingHistory?: boolean | HuntingGround$huntingHistoryArgs<ExtArgs>
    _count?: boolean | HuntingGroundCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HuntingGroundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HuntingGroundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HuntingGround"
    objects: {
      huntingHistory: Prisma.$HuntingHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      level: number
      maxLevel: number
      difficulty: string
      beastTypes: string
      dropRates: string
      isActive: boolean
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["huntingGround"]>
    composites: {}
  }

  type HuntingGroundGetPayload<S extends boolean | null | undefined | HuntingGroundDefaultArgs> = $Result.GetResult<Prisma.$HuntingGroundPayload, S>

  type HuntingGroundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HuntingGroundFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HuntingGroundCountAggregateInputType | true
    }

  export interface HuntingGroundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HuntingGround'], meta: { name: 'HuntingGround' } }
    /**
     * Find zero or one HuntingGround that matches the filter.
     * @param {HuntingGroundFindUniqueArgs} args - Arguments to find a HuntingGround
     * @example
     * // Get one HuntingGround
     * const huntingGround = await prisma.huntingGround.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HuntingGroundFindUniqueArgs>(args: SelectSubset<T, HuntingGroundFindUniqueArgs<ExtArgs>>): Prisma__HuntingGroundClient<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HuntingGround that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HuntingGroundFindUniqueOrThrowArgs} args - Arguments to find a HuntingGround
     * @example
     * // Get one HuntingGround
     * const huntingGround = await prisma.huntingGround.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HuntingGroundFindUniqueOrThrowArgs>(args: SelectSubset<T, HuntingGroundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HuntingGroundClient<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HuntingGround that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingGroundFindFirstArgs} args - Arguments to find a HuntingGround
     * @example
     * // Get one HuntingGround
     * const huntingGround = await prisma.huntingGround.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HuntingGroundFindFirstArgs>(args?: SelectSubset<T, HuntingGroundFindFirstArgs<ExtArgs>>): Prisma__HuntingGroundClient<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HuntingGround that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingGroundFindFirstOrThrowArgs} args - Arguments to find a HuntingGround
     * @example
     * // Get one HuntingGround
     * const huntingGround = await prisma.huntingGround.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HuntingGroundFindFirstOrThrowArgs>(args?: SelectSubset<T, HuntingGroundFindFirstOrThrowArgs<ExtArgs>>): Prisma__HuntingGroundClient<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HuntingGrounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingGroundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HuntingGrounds
     * const huntingGrounds = await prisma.huntingGround.findMany()
     * 
     * // Get first 10 HuntingGrounds
     * const huntingGrounds = await prisma.huntingGround.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const huntingGroundWithIdOnly = await prisma.huntingGround.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HuntingGroundFindManyArgs>(args?: SelectSubset<T, HuntingGroundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HuntingGround.
     * @param {HuntingGroundCreateArgs} args - Arguments to create a HuntingGround.
     * @example
     * // Create one HuntingGround
     * const HuntingGround = await prisma.huntingGround.create({
     *   data: {
     *     // ... data to create a HuntingGround
     *   }
     * })
     * 
     */
    create<T extends HuntingGroundCreateArgs>(args: SelectSubset<T, HuntingGroundCreateArgs<ExtArgs>>): Prisma__HuntingGroundClient<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HuntingGrounds.
     * @param {HuntingGroundCreateManyArgs} args - Arguments to create many HuntingGrounds.
     * @example
     * // Create many HuntingGrounds
     * const huntingGround = await prisma.huntingGround.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HuntingGroundCreateManyArgs>(args?: SelectSubset<T, HuntingGroundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HuntingGrounds and returns the data saved in the database.
     * @param {HuntingGroundCreateManyAndReturnArgs} args - Arguments to create many HuntingGrounds.
     * @example
     * // Create many HuntingGrounds
     * const huntingGround = await prisma.huntingGround.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HuntingGrounds and only return the `id`
     * const huntingGroundWithIdOnly = await prisma.huntingGround.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HuntingGroundCreateManyAndReturnArgs>(args?: SelectSubset<T, HuntingGroundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HuntingGround.
     * @param {HuntingGroundDeleteArgs} args - Arguments to delete one HuntingGround.
     * @example
     * // Delete one HuntingGround
     * const HuntingGround = await prisma.huntingGround.delete({
     *   where: {
     *     // ... filter to delete one HuntingGround
     *   }
     * })
     * 
     */
    delete<T extends HuntingGroundDeleteArgs>(args: SelectSubset<T, HuntingGroundDeleteArgs<ExtArgs>>): Prisma__HuntingGroundClient<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HuntingGround.
     * @param {HuntingGroundUpdateArgs} args - Arguments to update one HuntingGround.
     * @example
     * // Update one HuntingGround
     * const huntingGround = await prisma.huntingGround.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HuntingGroundUpdateArgs>(args: SelectSubset<T, HuntingGroundUpdateArgs<ExtArgs>>): Prisma__HuntingGroundClient<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HuntingGrounds.
     * @param {HuntingGroundDeleteManyArgs} args - Arguments to filter HuntingGrounds to delete.
     * @example
     * // Delete a few HuntingGrounds
     * const { count } = await prisma.huntingGround.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HuntingGroundDeleteManyArgs>(args?: SelectSubset<T, HuntingGroundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HuntingGrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingGroundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HuntingGrounds
     * const huntingGround = await prisma.huntingGround.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HuntingGroundUpdateManyArgs>(args: SelectSubset<T, HuntingGroundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HuntingGround.
     * @param {HuntingGroundUpsertArgs} args - Arguments to update or create a HuntingGround.
     * @example
     * // Update or create a HuntingGround
     * const huntingGround = await prisma.huntingGround.upsert({
     *   create: {
     *     // ... data to create a HuntingGround
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HuntingGround we want to update
     *   }
     * })
     */
    upsert<T extends HuntingGroundUpsertArgs>(args: SelectSubset<T, HuntingGroundUpsertArgs<ExtArgs>>): Prisma__HuntingGroundClient<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HuntingGrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingGroundCountArgs} args - Arguments to filter HuntingGrounds to count.
     * @example
     * // Count the number of HuntingGrounds
     * const count = await prisma.huntingGround.count({
     *   where: {
     *     // ... the filter for the HuntingGrounds we want to count
     *   }
     * })
    **/
    count<T extends HuntingGroundCountArgs>(
      args?: Subset<T, HuntingGroundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HuntingGroundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HuntingGround.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingGroundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HuntingGroundAggregateArgs>(args: Subset<T, HuntingGroundAggregateArgs>): Prisma.PrismaPromise<GetHuntingGroundAggregateType<T>>

    /**
     * Group by HuntingGround.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingGroundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HuntingGroundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HuntingGroundGroupByArgs['orderBy'] }
        : { orderBy?: HuntingGroundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HuntingGroundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHuntingGroundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HuntingGround model
   */
  readonly fields: HuntingGroundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HuntingGround.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HuntingGroundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    huntingHistory<T extends HuntingGround$huntingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, HuntingGround$huntingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HuntingGround model
   */ 
  interface HuntingGroundFieldRefs {
    readonly id: FieldRef<"HuntingGround", 'String'>
    readonly name: FieldRef<"HuntingGround", 'String'>
    readonly displayName: FieldRef<"HuntingGround", 'String'>
    readonly description: FieldRef<"HuntingGround", 'String'>
    readonly level: FieldRef<"HuntingGround", 'Int'>
    readonly maxLevel: FieldRef<"HuntingGround", 'Int'>
    readonly difficulty: FieldRef<"HuntingGround", 'String'>
    readonly beastTypes: FieldRef<"HuntingGround", 'String'>
    readonly dropRates: FieldRef<"HuntingGround", 'String'>
    readonly isActive: FieldRef<"HuntingGround", 'Boolean'>
    readonly icon: FieldRef<"HuntingGround", 'String'>
    readonly createdAt: FieldRef<"HuntingGround", 'DateTime'>
    readonly updatedAt: FieldRef<"HuntingGround", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HuntingGround findUnique
   */
  export type HuntingGroundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingGroundInclude<ExtArgs> | null
    /**
     * Filter, which HuntingGround to fetch.
     */
    where: HuntingGroundWhereUniqueInput
  }

  /**
   * HuntingGround findUniqueOrThrow
   */
  export type HuntingGroundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingGroundInclude<ExtArgs> | null
    /**
     * Filter, which HuntingGround to fetch.
     */
    where: HuntingGroundWhereUniqueInput
  }

  /**
   * HuntingGround findFirst
   */
  export type HuntingGroundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingGroundInclude<ExtArgs> | null
    /**
     * Filter, which HuntingGround to fetch.
     */
    where?: HuntingGroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HuntingGrounds to fetch.
     */
    orderBy?: HuntingGroundOrderByWithRelationInput | HuntingGroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HuntingGrounds.
     */
    cursor?: HuntingGroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HuntingGrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HuntingGrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HuntingGrounds.
     */
    distinct?: HuntingGroundScalarFieldEnum | HuntingGroundScalarFieldEnum[]
  }

  /**
   * HuntingGround findFirstOrThrow
   */
  export type HuntingGroundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingGroundInclude<ExtArgs> | null
    /**
     * Filter, which HuntingGround to fetch.
     */
    where?: HuntingGroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HuntingGrounds to fetch.
     */
    orderBy?: HuntingGroundOrderByWithRelationInput | HuntingGroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HuntingGrounds.
     */
    cursor?: HuntingGroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HuntingGrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HuntingGrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HuntingGrounds.
     */
    distinct?: HuntingGroundScalarFieldEnum | HuntingGroundScalarFieldEnum[]
  }

  /**
   * HuntingGround findMany
   */
  export type HuntingGroundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingGroundInclude<ExtArgs> | null
    /**
     * Filter, which HuntingGrounds to fetch.
     */
    where?: HuntingGroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HuntingGrounds to fetch.
     */
    orderBy?: HuntingGroundOrderByWithRelationInput | HuntingGroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HuntingGrounds.
     */
    cursor?: HuntingGroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HuntingGrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HuntingGrounds.
     */
    skip?: number
    distinct?: HuntingGroundScalarFieldEnum | HuntingGroundScalarFieldEnum[]
  }

  /**
   * HuntingGround create
   */
  export type HuntingGroundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingGroundInclude<ExtArgs> | null
    /**
     * The data needed to create a HuntingGround.
     */
    data: XOR<HuntingGroundCreateInput, HuntingGroundUncheckedCreateInput>
  }

  /**
   * HuntingGround createMany
   */
  export type HuntingGroundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HuntingGrounds.
     */
    data: HuntingGroundCreateManyInput | HuntingGroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HuntingGround createManyAndReturn
   */
  export type HuntingGroundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HuntingGrounds.
     */
    data: HuntingGroundCreateManyInput | HuntingGroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HuntingGround update
   */
  export type HuntingGroundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingGroundInclude<ExtArgs> | null
    /**
     * The data needed to update a HuntingGround.
     */
    data: XOR<HuntingGroundUpdateInput, HuntingGroundUncheckedUpdateInput>
    /**
     * Choose, which HuntingGround to update.
     */
    where: HuntingGroundWhereUniqueInput
  }

  /**
   * HuntingGround updateMany
   */
  export type HuntingGroundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HuntingGrounds.
     */
    data: XOR<HuntingGroundUpdateManyMutationInput, HuntingGroundUncheckedUpdateManyInput>
    /**
     * Filter which HuntingGrounds to update
     */
    where?: HuntingGroundWhereInput
  }

  /**
   * HuntingGround upsert
   */
  export type HuntingGroundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingGroundInclude<ExtArgs> | null
    /**
     * The filter to search for the HuntingGround to update in case it exists.
     */
    where: HuntingGroundWhereUniqueInput
    /**
     * In case the HuntingGround found by the `where` argument doesn't exist, create a new HuntingGround with this data.
     */
    create: XOR<HuntingGroundCreateInput, HuntingGroundUncheckedCreateInput>
    /**
     * In case the HuntingGround was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HuntingGroundUpdateInput, HuntingGroundUncheckedUpdateInput>
  }

  /**
   * HuntingGround delete
   */
  export type HuntingGroundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingGroundInclude<ExtArgs> | null
    /**
     * Filter which HuntingGround to delete.
     */
    where: HuntingGroundWhereUniqueInput
  }

  /**
   * HuntingGround deleteMany
   */
  export type HuntingGroundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HuntingGrounds to delete
     */
    where?: HuntingGroundWhereInput
  }

  /**
   * HuntingGround.huntingHistory
   */
  export type HuntingGround$huntingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    where?: HuntingHistoryWhereInput
    orderBy?: HuntingHistoryOrderByWithRelationInput | HuntingHistoryOrderByWithRelationInput[]
    cursor?: HuntingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HuntingHistoryScalarFieldEnum | HuntingHistoryScalarFieldEnum[]
  }

  /**
   * HuntingGround without action
   */
  export type HuntingGroundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingGround
     */
    select?: HuntingGroundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingGroundInclude<ExtArgs> | null
  }


  /**
   * Model HuntingHistory
   */

  export type AggregateHuntingHistory = {
    _count: HuntingHistoryCountAggregateOutputType | null
    _avg: HuntingHistoryAvgAggregateOutputType | null
    _sum: HuntingHistorySumAggregateOutputType | null
    _min: HuntingHistoryMinAggregateOutputType | null
    _max: HuntingHistoryMaxAggregateOutputType | null
  }

  export type HuntingHistoryAvgAggregateOutputType = {
    duration: number | null
  }

  export type HuntingHistorySumAggregateOutputType = {
    duration: number | null
  }

  export type HuntingHistoryMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    groundId: string | null
    beastId: string | null
    success: boolean | null
    duration: number | null
    rewards: string | null
    createdAt: Date | null
  }

  export type HuntingHistoryMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    groundId: string | null
    beastId: string | null
    success: boolean | null
    duration: number | null
    rewards: string | null
    createdAt: Date | null
  }

  export type HuntingHistoryCountAggregateOutputType = {
    id: number
    playerId: number
    groundId: number
    beastId: number
    success: number
    duration: number
    rewards: number
    createdAt: number
    _all: number
  }


  export type HuntingHistoryAvgAggregateInputType = {
    duration?: true
  }

  export type HuntingHistorySumAggregateInputType = {
    duration?: true
  }

  export type HuntingHistoryMinAggregateInputType = {
    id?: true
    playerId?: true
    groundId?: true
    beastId?: true
    success?: true
    duration?: true
    rewards?: true
    createdAt?: true
  }

  export type HuntingHistoryMaxAggregateInputType = {
    id?: true
    playerId?: true
    groundId?: true
    beastId?: true
    success?: true
    duration?: true
    rewards?: true
    createdAt?: true
  }

  export type HuntingHistoryCountAggregateInputType = {
    id?: true
    playerId?: true
    groundId?: true
    beastId?: true
    success?: true
    duration?: true
    rewards?: true
    createdAt?: true
    _all?: true
  }

  export type HuntingHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HuntingHistory to aggregate.
     */
    where?: HuntingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HuntingHistories to fetch.
     */
    orderBy?: HuntingHistoryOrderByWithRelationInput | HuntingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HuntingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HuntingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HuntingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HuntingHistories
    **/
    _count?: true | HuntingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HuntingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HuntingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HuntingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HuntingHistoryMaxAggregateInputType
  }

  export type GetHuntingHistoryAggregateType<T extends HuntingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHuntingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHuntingHistory[P]>
      : GetScalarType<T[P], AggregateHuntingHistory[P]>
  }




  export type HuntingHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HuntingHistoryWhereInput
    orderBy?: HuntingHistoryOrderByWithAggregationInput | HuntingHistoryOrderByWithAggregationInput[]
    by: HuntingHistoryScalarFieldEnum[] | HuntingHistoryScalarFieldEnum
    having?: HuntingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HuntingHistoryCountAggregateInputType | true
    _avg?: HuntingHistoryAvgAggregateInputType
    _sum?: HuntingHistorySumAggregateInputType
    _min?: HuntingHistoryMinAggregateInputType
    _max?: HuntingHistoryMaxAggregateInputType
  }

  export type HuntingHistoryGroupByOutputType = {
    id: string
    playerId: string
    groundId: string
    beastId: string | null
    success: boolean
    duration: number
    rewards: string | null
    createdAt: Date
    _count: HuntingHistoryCountAggregateOutputType | null
    _avg: HuntingHistoryAvgAggregateOutputType | null
    _sum: HuntingHistorySumAggregateOutputType | null
    _min: HuntingHistoryMinAggregateOutputType | null
    _max: HuntingHistoryMaxAggregateOutputType | null
  }

  type GetHuntingHistoryGroupByPayload<T extends HuntingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HuntingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HuntingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HuntingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], HuntingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type HuntingHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    groundId?: boolean
    beastId?: boolean
    success?: boolean
    duration?: boolean
    rewards?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    ground?: boolean | HuntingGroundDefaultArgs<ExtArgs>
    beast?: boolean | HuntingHistory$beastArgs<ExtArgs>
  }, ExtArgs["result"]["huntingHistory"]>

  export type HuntingHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    groundId?: boolean
    beastId?: boolean
    success?: boolean
    duration?: boolean
    rewards?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    ground?: boolean | HuntingGroundDefaultArgs<ExtArgs>
    beast?: boolean | HuntingHistory$beastArgs<ExtArgs>
  }, ExtArgs["result"]["huntingHistory"]>

  export type HuntingHistorySelectScalar = {
    id?: boolean
    playerId?: boolean
    groundId?: boolean
    beastId?: boolean
    success?: boolean
    duration?: boolean
    rewards?: boolean
    createdAt?: boolean
  }

  export type HuntingHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    ground?: boolean | HuntingGroundDefaultArgs<ExtArgs>
    beast?: boolean | HuntingHistory$beastArgs<ExtArgs>
  }
  export type HuntingHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    ground?: boolean | HuntingGroundDefaultArgs<ExtArgs>
    beast?: boolean | HuntingHistory$beastArgs<ExtArgs>
  }

  export type $HuntingHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HuntingHistory"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      ground: Prisma.$HuntingGroundPayload<ExtArgs>
      beast: Prisma.$SpiritBeastPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      groundId: string
      beastId: string | null
      success: boolean
      duration: number
      rewards: string | null
      createdAt: Date
    }, ExtArgs["result"]["huntingHistory"]>
    composites: {}
  }

  type HuntingHistoryGetPayload<S extends boolean | null | undefined | HuntingHistoryDefaultArgs> = $Result.GetResult<Prisma.$HuntingHistoryPayload, S>

  type HuntingHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HuntingHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HuntingHistoryCountAggregateInputType | true
    }

  export interface HuntingHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HuntingHistory'], meta: { name: 'HuntingHistory' } }
    /**
     * Find zero or one HuntingHistory that matches the filter.
     * @param {HuntingHistoryFindUniqueArgs} args - Arguments to find a HuntingHistory
     * @example
     * // Get one HuntingHistory
     * const huntingHistory = await prisma.huntingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HuntingHistoryFindUniqueArgs>(args: SelectSubset<T, HuntingHistoryFindUniqueArgs<ExtArgs>>): Prisma__HuntingHistoryClient<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HuntingHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HuntingHistoryFindUniqueOrThrowArgs} args - Arguments to find a HuntingHistory
     * @example
     * // Get one HuntingHistory
     * const huntingHistory = await prisma.huntingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HuntingHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, HuntingHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HuntingHistoryClient<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HuntingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingHistoryFindFirstArgs} args - Arguments to find a HuntingHistory
     * @example
     * // Get one HuntingHistory
     * const huntingHistory = await prisma.huntingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HuntingHistoryFindFirstArgs>(args?: SelectSubset<T, HuntingHistoryFindFirstArgs<ExtArgs>>): Prisma__HuntingHistoryClient<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HuntingHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingHistoryFindFirstOrThrowArgs} args - Arguments to find a HuntingHistory
     * @example
     * // Get one HuntingHistory
     * const huntingHistory = await prisma.huntingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HuntingHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, HuntingHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__HuntingHistoryClient<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HuntingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HuntingHistories
     * const huntingHistories = await prisma.huntingHistory.findMany()
     * 
     * // Get first 10 HuntingHistories
     * const huntingHistories = await prisma.huntingHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const huntingHistoryWithIdOnly = await prisma.huntingHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HuntingHistoryFindManyArgs>(args?: SelectSubset<T, HuntingHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HuntingHistory.
     * @param {HuntingHistoryCreateArgs} args - Arguments to create a HuntingHistory.
     * @example
     * // Create one HuntingHistory
     * const HuntingHistory = await prisma.huntingHistory.create({
     *   data: {
     *     // ... data to create a HuntingHistory
     *   }
     * })
     * 
     */
    create<T extends HuntingHistoryCreateArgs>(args: SelectSubset<T, HuntingHistoryCreateArgs<ExtArgs>>): Prisma__HuntingHistoryClient<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HuntingHistories.
     * @param {HuntingHistoryCreateManyArgs} args - Arguments to create many HuntingHistories.
     * @example
     * // Create many HuntingHistories
     * const huntingHistory = await prisma.huntingHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HuntingHistoryCreateManyArgs>(args?: SelectSubset<T, HuntingHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HuntingHistories and returns the data saved in the database.
     * @param {HuntingHistoryCreateManyAndReturnArgs} args - Arguments to create many HuntingHistories.
     * @example
     * // Create many HuntingHistories
     * const huntingHistory = await prisma.huntingHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HuntingHistories and only return the `id`
     * const huntingHistoryWithIdOnly = await prisma.huntingHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HuntingHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, HuntingHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HuntingHistory.
     * @param {HuntingHistoryDeleteArgs} args - Arguments to delete one HuntingHistory.
     * @example
     * // Delete one HuntingHistory
     * const HuntingHistory = await prisma.huntingHistory.delete({
     *   where: {
     *     // ... filter to delete one HuntingHistory
     *   }
     * })
     * 
     */
    delete<T extends HuntingHistoryDeleteArgs>(args: SelectSubset<T, HuntingHistoryDeleteArgs<ExtArgs>>): Prisma__HuntingHistoryClient<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HuntingHistory.
     * @param {HuntingHistoryUpdateArgs} args - Arguments to update one HuntingHistory.
     * @example
     * // Update one HuntingHistory
     * const huntingHistory = await prisma.huntingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HuntingHistoryUpdateArgs>(args: SelectSubset<T, HuntingHistoryUpdateArgs<ExtArgs>>): Prisma__HuntingHistoryClient<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HuntingHistories.
     * @param {HuntingHistoryDeleteManyArgs} args - Arguments to filter HuntingHistories to delete.
     * @example
     * // Delete a few HuntingHistories
     * const { count } = await prisma.huntingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HuntingHistoryDeleteManyArgs>(args?: SelectSubset<T, HuntingHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HuntingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HuntingHistories
     * const huntingHistory = await prisma.huntingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HuntingHistoryUpdateManyArgs>(args: SelectSubset<T, HuntingHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HuntingHistory.
     * @param {HuntingHistoryUpsertArgs} args - Arguments to update or create a HuntingHistory.
     * @example
     * // Update or create a HuntingHistory
     * const huntingHistory = await prisma.huntingHistory.upsert({
     *   create: {
     *     // ... data to create a HuntingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HuntingHistory we want to update
     *   }
     * })
     */
    upsert<T extends HuntingHistoryUpsertArgs>(args: SelectSubset<T, HuntingHistoryUpsertArgs<ExtArgs>>): Prisma__HuntingHistoryClient<$Result.GetResult<Prisma.$HuntingHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HuntingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingHistoryCountArgs} args - Arguments to filter HuntingHistories to count.
     * @example
     * // Count the number of HuntingHistories
     * const count = await prisma.huntingHistory.count({
     *   where: {
     *     // ... the filter for the HuntingHistories we want to count
     *   }
     * })
    **/
    count<T extends HuntingHistoryCountArgs>(
      args?: Subset<T, HuntingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HuntingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HuntingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HuntingHistoryAggregateArgs>(args: Subset<T, HuntingHistoryAggregateArgs>): Prisma.PrismaPromise<GetHuntingHistoryAggregateType<T>>

    /**
     * Group by HuntingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HuntingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HuntingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: HuntingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HuntingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHuntingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HuntingHistory model
   */
  readonly fields: HuntingHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HuntingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HuntingHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ground<T extends HuntingGroundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HuntingGroundDefaultArgs<ExtArgs>>): Prisma__HuntingGroundClient<$Result.GetResult<Prisma.$HuntingGroundPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    beast<T extends HuntingHistory$beastArgs<ExtArgs> = {}>(args?: Subset<T, HuntingHistory$beastArgs<ExtArgs>>): Prisma__SpiritBeastClient<$Result.GetResult<Prisma.$SpiritBeastPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HuntingHistory model
   */ 
  interface HuntingHistoryFieldRefs {
    readonly id: FieldRef<"HuntingHistory", 'String'>
    readonly playerId: FieldRef<"HuntingHistory", 'String'>
    readonly groundId: FieldRef<"HuntingHistory", 'String'>
    readonly beastId: FieldRef<"HuntingHistory", 'String'>
    readonly success: FieldRef<"HuntingHistory", 'Boolean'>
    readonly duration: FieldRef<"HuntingHistory", 'Int'>
    readonly rewards: FieldRef<"HuntingHistory", 'String'>
    readonly createdAt: FieldRef<"HuntingHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HuntingHistory findUnique
   */
  export type HuntingHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which HuntingHistory to fetch.
     */
    where: HuntingHistoryWhereUniqueInput
  }

  /**
   * HuntingHistory findUniqueOrThrow
   */
  export type HuntingHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which HuntingHistory to fetch.
     */
    where: HuntingHistoryWhereUniqueInput
  }

  /**
   * HuntingHistory findFirst
   */
  export type HuntingHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which HuntingHistory to fetch.
     */
    where?: HuntingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HuntingHistories to fetch.
     */
    orderBy?: HuntingHistoryOrderByWithRelationInput | HuntingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HuntingHistories.
     */
    cursor?: HuntingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HuntingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HuntingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HuntingHistories.
     */
    distinct?: HuntingHistoryScalarFieldEnum | HuntingHistoryScalarFieldEnum[]
  }

  /**
   * HuntingHistory findFirstOrThrow
   */
  export type HuntingHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which HuntingHistory to fetch.
     */
    where?: HuntingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HuntingHistories to fetch.
     */
    orderBy?: HuntingHistoryOrderByWithRelationInput | HuntingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HuntingHistories.
     */
    cursor?: HuntingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HuntingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HuntingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HuntingHistories.
     */
    distinct?: HuntingHistoryScalarFieldEnum | HuntingHistoryScalarFieldEnum[]
  }

  /**
   * HuntingHistory findMany
   */
  export type HuntingHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which HuntingHistories to fetch.
     */
    where?: HuntingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HuntingHistories to fetch.
     */
    orderBy?: HuntingHistoryOrderByWithRelationInput | HuntingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HuntingHistories.
     */
    cursor?: HuntingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HuntingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HuntingHistories.
     */
    skip?: number
    distinct?: HuntingHistoryScalarFieldEnum | HuntingHistoryScalarFieldEnum[]
  }

  /**
   * HuntingHistory create
   */
  export type HuntingHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a HuntingHistory.
     */
    data: XOR<HuntingHistoryCreateInput, HuntingHistoryUncheckedCreateInput>
  }

  /**
   * HuntingHistory createMany
   */
  export type HuntingHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HuntingHistories.
     */
    data: HuntingHistoryCreateManyInput | HuntingHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HuntingHistory createManyAndReturn
   */
  export type HuntingHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HuntingHistories.
     */
    data: HuntingHistoryCreateManyInput | HuntingHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HuntingHistory update
   */
  export type HuntingHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a HuntingHistory.
     */
    data: XOR<HuntingHistoryUpdateInput, HuntingHistoryUncheckedUpdateInput>
    /**
     * Choose, which HuntingHistory to update.
     */
    where: HuntingHistoryWhereUniqueInput
  }

  /**
   * HuntingHistory updateMany
   */
  export type HuntingHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HuntingHistories.
     */
    data: XOR<HuntingHistoryUpdateManyMutationInput, HuntingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which HuntingHistories to update
     */
    where?: HuntingHistoryWhereInput
  }

  /**
   * HuntingHistory upsert
   */
  export type HuntingHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the HuntingHistory to update in case it exists.
     */
    where: HuntingHistoryWhereUniqueInput
    /**
     * In case the HuntingHistory found by the `where` argument doesn't exist, create a new HuntingHistory with this data.
     */
    create: XOR<HuntingHistoryCreateInput, HuntingHistoryUncheckedCreateInput>
    /**
     * In case the HuntingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HuntingHistoryUpdateInput, HuntingHistoryUncheckedUpdateInput>
  }

  /**
   * HuntingHistory delete
   */
  export type HuntingHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
    /**
     * Filter which HuntingHistory to delete.
     */
    where: HuntingHistoryWhereUniqueInput
  }

  /**
   * HuntingHistory deleteMany
   */
  export type HuntingHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HuntingHistories to delete
     */
    where?: HuntingHistoryWhereInput
  }

  /**
   * HuntingHistory.beast
   */
  export type HuntingHistory$beastArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiritBeast
     */
    select?: SpiritBeastSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiritBeastInclude<ExtArgs> | null
    where?: SpiritBeastWhereInput
  }

  /**
   * HuntingHistory without action
   */
  export type HuntingHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HuntingHistory
     */
    select?: HuntingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntingHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PlayerCultivation
   */

  export type AggregatePlayerCultivation = {
    _count: PlayerCultivationCountAggregateOutputType | null
    _avg: PlayerCultivationAvgAggregateOutputType | null
    _sum: PlayerCultivationSumAggregateOutputType | null
    _min: PlayerCultivationMinAggregateOutputType | null
    _max: PlayerCultivationMaxAggregateOutputType | null
  }

  export type PlayerCultivationAvgAggregateOutputType = {
    currentRealm: number | null
    currentFloor: number | null
    currentExp: number | null
    totalExpGained: number | null
  }

  export type PlayerCultivationSumAggregateOutputType = {
    currentRealm: number | null
    currentFloor: number | null
    currentExp: number | null
    totalExpGained: number | null
  }

  export type PlayerCultivationMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    currentRealm: number | null
    currentFloor: number | null
    currentExp: number | null
    totalExpGained: number | null
    currentQuality: string | null
    eternalTitles: string | null
    hasAscended: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCultivationMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    currentRealm: number | null
    currentFloor: number | null
    currentExp: number | null
    totalExpGained: number | null
    currentQuality: string | null
    eternalTitles: string | null
    hasAscended: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCultivationCountAggregateOutputType = {
    id: number
    playerId: number
    currentRealm: number
    currentFloor: number
    currentExp: number
    totalExpGained: number
    currentQuality: number
    eternalTitles: number
    hasAscended: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerCultivationAvgAggregateInputType = {
    currentRealm?: true
    currentFloor?: true
    currentExp?: true
    totalExpGained?: true
  }

  export type PlayerCultivationSumAggregateInputType = {
    currentRealm?: true
    currentFloor?: true
    currentExp?: true
    totalExpGained?: true
  }

  export type PlayerCultivationMinAggregateInputType = {
    id?: true
    playerId?: true
    currentRealm?: true
    currentFloor?: true
    currentExp?: true
    totalExpGained?: true
    currentQuality?: true
    eternalTitles?: true
    hasAscended?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCultivationMaxAggregateInputType = {
    id?: true
    playerId?: true
    currentRealm?: true
    currentFloor?: true
    currentExp?: true
    totalExpGained?: true
    currentQuality?: true
    eternalTitles?: true
    hasAscended?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCultivationCountAggregateInputType = {
    id?: true
    playerId?: true
    currentRealm?: true
    currentFloor?: true
    currentExp?: true
    totalExpGained?: true
    currentQuality?: true
    eternalTitles?: true
    hasAscended?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerCultivationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerCultivation to aggregate.
     */
    where?: PlayerCultivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCultivations to fetch.
     */
    orderBy?: PlayerCultivationOrderByWithRelationInput | PlayerCultivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerCultivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCultivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCultivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerCultivations
    **/
    _count?: true | PlayerCultivationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerCultivationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerCultivationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerCultivationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerCultivationMaxAggregateInputType
  }

  export type GetPlayerCultivationAggregateType<T extends PlayerCultivationAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerCultivation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerCultivation[P]>
      : GetScalarType<T[P], AggregatePlayerCultivation[P]>
  }




  export type PlayerCultivationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerCultivationWhereInput
    orderBy?: PlayerCultivationOrderByWithAggregationInput | PlayerCultivationOrderByWithAggregationInput[]
    by: PlayerCultivationScalarFieldEnum[] | PlayerCultivationScalarFieldEnum
    having?: PlayerCultivationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCultivationCountAggregateInputType | true
    _avg?: PlayerCultivationAvgAggregateInputType
    _sum?: PlayerCultivationSumAggregateInputType
    _min?: PlayerCultivationMinAggregateInputType
    _max?: PlayerCultivationMaxAggregateInputType
  }

  export type PlayerCultivationGroupByOutputType = {
    id: string
    playerId: string
    currentRealm: number
    currentFloor: number
    currentExp: number
    totalExpGained: number
    currentQuality: string
    eternalTitles: string
    hasAscended: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlayerCultivationCountAggregateOutputType | null
    _avg: PlayerCultivationAvgAggregateOutputType | null
    _sum: PlayerCultivationSumAggregateOutputType | null
    _min: PlayerCultivationMinAggregateOutputType | null
    _max: PlayerCultivationMaxAggregateOutputType | null
  }

  type GetPlayerCultivationGroupByPayload<T extends PlayerCultivationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerCultivationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerCultivationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerCultivationGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerCultivationGroupByOutputType[P]>
        }
      >
    >


  export type PlayerCultivationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    currentRealm?: boolean
    currentFloor?: boolean
    currentExp?: boolean
    totalExpGained?: boolean
    currentQuality?: boolean
    eternalTitles?: boolean
    hasAscended?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerCultivation"]>

  export type PlayerCultivationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    currentRealm?: boolean
    currentFloor?: boolean
    currentExp?: boolean
    totalExpGained?: boolean
    currentQuality?: boolean
    eternalTitles?: boolean
    hasAscended?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerCultivation"]>

  export type PlayerCultivationSelectScalar = {
    id?: boolean
    playerId?: boolean
    currentRealm?: boolean
    currentFloor?: boolean
    currentExp?: boolean
    totalExpGained?: boolean
    currentQuality?: boolean
    eternalTitles?: boolean
    hasAscended?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerCultivationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PlayerCultivationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $PlayerCultivationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerCultivation"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      currentRealm: number
      currentFloor: number
      currentExp: number
      totalExpGained: number
      currentQuality: string
      eternalTitles: string
      hasAscended: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerCultivation"]>
    composites: {}
  }

  type PlayerCultivationGetPayload<S extends boolean | null | undefined | PlayerCultivationDefaultArgs> = $Result.GetResult<Prisma.$PlayerCultivationPayload, S>

  type PlayerCultivationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerCultivationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerCultivationCountAggregateInputType | true
    }

  export interface PlayerCultivationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerCultivation'], meta: { name: 'PlayerCultivation' } }
    /**
     * Find zero or one PlayerCultivation that matches the filter.
     * @param {PlayerCultivationFindUniqueArgs} args - Arguments to find a PlayerCultivation
     * @example
     * // Get one PlayerCultivation
     * const playerCultivation = await prisma.playerCultivation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerCultivationFindUniqueArgs>(args: SelectSubset<T, PlayerCultivationFindUniqueArgs<ExtArgs>>): Prisma__PlayerCultivationClient<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerCultivation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerCultivationFindUniqueOrThrowArgs} args - Arguments to find a PlayerCultivation
     * @example
     * // Get one PlayerCultivation
     * const playerCultivation = await prisma.playerCultivation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerCultivationFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerCultivationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerCultivationClient<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerCultivation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCultivationFindFirstArgs} args - Arguments to find a PlayerCultivation
     * @example
     * // Get one PlayerCultivation
     * const playerCultivation = await prisma.playerCultivation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerCultivationFindFirstArgs>(args?: SelectSubset<T, PlayerCultivationFindFirstArgs<ExtArgs>>): Prisma__PlayerCultivationClient<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerCultivation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCultivationFindFirstOrThrowArgs} args - Arguments to find a PlayerCultivation
     * @example
     * // Get one PlayerCultivation
     * const playerCultivation = await prisma.playerCultivation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerCultivationFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerCultivationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerCultivationClient<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerCultivations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCultivationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerCultivations
     * const playerCultivations = await prisma.playerCultivation.findMany()
     * 
     * // Get first 10 PlayerCultivations
     * const playerCultivations = await prisma.playerCultivation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerCultivationWithIdOnly = await prisma.playerCultivation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerCultivationFindManyArgs>(args?: SelectSubset<T, PlayerCultivationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerCultivation.
     * @param {PlayerCultivationCreateArgs} args - Arguments to create a PlayerCultivation.
     * @example
     * // Create one PlayerCultivation
     * const PlayerCultivation = await prisma.playerCultivation.create({
     *   data: {
     *     // ... data to create a PlayerCultivation
     *   }
     * })
     * 
     */
    create<T extends PlayerCultivationCreateArgs>(args: SelectSubset<T, PlayerCultivationCreateArgs<ExtArgs>>): Prisma__PlayerCultivationClient<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerCultivations.
     * @param {PlayerCultivationCreateManyArgs} args - Arguments to create many PlayerCultivations.
     * @example
     * // Create many PlayerCultivations
     * const playerCultivation = await prisma.playerCultivation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCultivationCreateManyArgs>(args?: SelectSubset<T, PlayerCultivationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerCultivations and returns the data saved in the database.
     * @param {PlayerCultivationCreateManyAndReturnArgs} args - Arguments to create many PlayerCultivations.
     * @example
     * // Create many PlayerCultivations
     * const playerCultivation = await prisma.playerCultivation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerCultivations and only return the `id`
     * const playerCultivationWithIdOnly = await prisma.playerCultivation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCultivationCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCultivationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerCultivation.
     * @param {PlayerCultivationDeleteArgs} args - Arguments to delete one PlayerCultivation.
     * @example
     * // Delete one PlayerCultivation
     * const PlayerCultivation = await prisma.playerCultivation.delete({
     *   where: {
     *     // ... filter to delete one PlayerCultivation
     *   }
     * })
     * 
     */
    delete<T extends PlayerCultivationDeleteArgs>(args: SelectSubset<T, PlayerCultivationDeleteArgs<ExtArgs>>): Prisma__PlayerCultivationClient<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerCultivation.
     * @param {PlayerCultivationUpdateArgs} args - Arguments to update one PlayerCultivation.
     * @example
     * // Update one PlayerCultivation
     * const playerCultivation = await prisma.playerCultivation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerCultivationUpdateArgs>(args: SelectSubset<T, PlayerCultivationUpdateArgs<ExtArgs>>): Prisma__PlayerCultivationClient<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerCultivations.
     * @param {PlayerCultivationDeleteManyArgs} args - Arguments to filter PlayerCultivations to delete.
     * @example
     * // Delete a few PlayerCultivations
     * const { count } = await prisma.playerCultivation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerCultivationDeleteManyArgs>(args?: SelectSubset<T, PlayerCultivationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerCultivations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCultivationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerCultivations
     * const playerCultivation = await prisma.playerCultivation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerCultivationUpdateManyArgs>(args: SelectSubset<T, PlayerCultivationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerCultivation.
     * @param {PlayerCultivationUpsertArgs} args - Arguments to update or create a PlayerCultivation.
     * @example
     * // Update or create a PlayerCultivation
     * const playerCultivation = await prisma.playerCultivation.upsert({
     *   create: {
     *     // ... data to create a PlayerCultivation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerCultivation we want to update
     *   }
     * })
     */
    upsert<T extends PlayerCultivationUpsertArgs>(args: SelectSubset<T, PlayerCultivationUpsertArgs<ExtArgs>>): Prisma__PlayerCultivationClient<$Result.GetResult<Prisma.$PlayerCultivationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerCultivations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCultivationCountArgs} args - Arguments to filter PlayerCultivations to count.
     * @example
     * // Count the number of PlayerCultivations
     * const count = await prisma.playerCultivation.count({
     *   where: {
     *     // ... the filter for the PlayerCultivations we want to count
     *   }
     * })
    **/
    count<T extends PlayerCultivationCountArgs>(
      args?: Subset<T, PlayerCultivationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCultivationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerCultivation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCultivationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerCultivationAggregateArgs>(args: Subset<T, PlayerCultivationAggregateArgs>): Prisma.PrismaPromise<GetPlayerCultivationAggregateType<T>>

    /**
     * Group by PlayerCultivation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCultivationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerCultivationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerCultivationGroupByArgs['orderBy'] }
        : { orderBy?: PlayerCultivationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerCultivationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerCultivationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerCultivation model
   */
  readonly fields: PlayerCultivationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerCultivation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerCultivationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerCultivation model
   */ 
  interface PlayerCultivationFieldRefs {
    readonly id: FieldRef<"PlayerCultivation", 'String'>
    readonly playerId: FieldRef<"PlayerCultivation", 'String'>
    readonly currentRealm: FieldRef<"PlayerCultivation", 'Int'>
    readonly currentFloor: FieldRef<"PlayerCultivation", 'Int'>
    readonly currentExp: FieldRef<"PlayerCultivation", 'Int'>
    readonly totalExpGained: FieldRef<"PlayerCultivation", 'Int'>
    readonly currentQuality: FieldRef<"PlayerCultivation", 'String'>
    readonly eternalTitles: FieldRef<"PlayerCultivation", 'String'>
    readonly hasAscended: FieldRef<"PlayerCultivation", 'Boolean'>
    readonly createdAt: FieldRef<"PlayerCultivation", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerCultivation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerCultivation findUnique
   */
  export type PlayerCultivationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCultivation to fetch.
     */
    where: PlayerCultivationWhereUniqueInput
  }

  /**
   * PlayerCultivation findUniqueOrThrow
   */
  export type PlayerCultivationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCultivation to fetch.
     */
    where: PlayerCultivationWhereUniqueInput
  }

  /**
   * PlayerCultivation findFirst
   */
  export type PlayerCultivationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCultivation to fetch.
     */
    where?: PlayerCultivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCultivations to fetch.
     */
    orderBy?: PlayerCultivationOrderByWithRelationInput | PlayerCultivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerCultivations.
     */
    cursor?: PlayerCultivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCultivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCultivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerCultivations.
     */
    distinct?: PlayerCultivationScalarFieldEnum | PlayerCultivationScalarFieldEnum[]
  }

  /**
   * PlayerCultivation findFirstOrThrow
   */
  export type PlayerCultivationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCultivation to fetch.
     */
    where?: PlayerCultivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCultivations to fetch.
     */
    orderBy?: PlayerCultivationOrderByWithRelationInput | PlayerCultivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerCultivations.
     */
    cursor?: PlayerCultivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCultivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCultivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerCultivations.
     */
    distinct?: PlayerCultivationScalarFieldEnum | PlayerCultivationScalarFieldEnum[]
  }

  /**
   * PlayerCultivation findMany
   */
  export type PlayerCultivationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCultivations to fetch.
     */
    where?: PlayerCultivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCultivations to fetch.
     */
    orderBy?: PlayerCultivationOrderByWithRelationInput | PlayerCultivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerCultivations.
     */
    cursor?: PlayerCultivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCultivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCultivations.
     */
    skip?: number
    distinct?: PlayerCultivationScalarFieldEnum | PlayerCultivationScalarFieldEnum[]
  }

  /**
   * PlayerCultivation create
   */
  export type PlayerCultivationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerCultivation.
     */
    data: XOR<PlayerCultivationCreateInput, PlayerCultivationUncheckedCreateInput>
  }

  /**
   * PlayerCultivation createMany
   */
  export type PlayerCultivationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerCultivations.
     */
    data: PlayerCultivationCreateManyInput | PlayerCultivationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerCultivation createManyAndReturn
   */
  export type PlayerCultivationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerCultivations.
     */
    data: PlayerCultivationCreateManyInput | PlayerCultivationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerCultivation update
   */
  export type PlayerCultivationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerCultivation.
     */
    data: XOR<PlayerCultivationUpdateInput, PlayerCultivationUncheckedUpdateInput>
    /**
     * Choose, which PlayerCultivation to update.
     */
    where: PlayerCultivationWhereUniqueInput
  }

  /**
   * PlayerCultivation updateMany
   */
  export type PlayerCultivationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerCultivations.
     */
    data: XOR<PlayerCultivationUpdateManyMutationInput, PlayerCultivationUncheckedUpdateManyInput>
    /**
     * Filter which PlayerCultivations to update
     */
    where?: PlayerCultivationWhereInput
  }

  /**
   * PlayerCultivation upsert
   */
  export type PlayerCultivationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerCultivation to update in case it exists.
     */
    where: PlayerCultivationWhereUniqueInput
    /**
     * In case the PlayerCultivation found by the `where` argument doesn't exist, create a new PlayerCultivation with this data.
     */
    create: XOR<PlayerCultivationCreateInput, PlayerCultivationUncheckedCreateInput>
    /**
     * In case the PlayerCultivation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerCultivationUpdateInput, PlayerCultivationUncheckedUpdateInput>
  }

  /**
   * PlayerCultivation delete
   */
  export type PlayerCultivationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
    /**
     * Filter which PlayerCultivation to delete.
     */
    where: PlayerCultivationWhereUniqueInput
  }

  /**
   * PlayerCultivation deleteMany
   */
  export type PlayerCultivationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerCultivations to delete
     */
    where?: PlayerCultivationWhereInput
  }

  /**
   * PlayerCultivation without action
   */
  export type PlayerCultivationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCultivation
     */
    select?: PlayerCultivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCultivationInclude<ExtArgs> | null
  }


  /**
   * Model CultivationLog
   */

  export type AggregateCultivationLog = {
    _count: CultivationLogCountAggregateOutputType | null
    _avg: CultivationLogAvgAggregateOutputType | null
    _sum: CultivationLogSumAggregateOutputType | null
    _min: CultivationLogMinAggregateOutputType | null
    _max: CultivationLogMaxAggregateOutputType | null
  }

  export type CultivationLogAvgAggregateOutputType = {
    expGained: number | null
    levelGained: number | null
  }

  export type CultivationLogSumAggregateOutputType = {
    expGained: number | null
    levelGained: number | null
  }

  export type CultivationLogMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    type: string | null
    description: string | null
    expGained: number | null
    levelGained: number | null
    timestamp: Date | null
  }

  export type CultivationLogMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    type: string | null
    description: string | null
    expGained: number | null
    levelGained: number | null
    timestamp: Date | null
  }

  export type CultivationLogCountAggregateOutputType = {
    id: number
    playerId: number
    type: number
    description: number
    expGained: number
    levelGained: number
    timestamp: number
    _all: number
  }


  export type CultivationLogAvgAggregateInputType = {
    expGained?: true
    levelGained?: true
  }

  export type CultivationLogSumAggregateInputType = {
    expGained?: true
    levelGained?: true
  }

  export type CultivationLogMinAggregateInputType = {
    id?: true
    playerId?: true
    type?: true
    description?: true
    expGained?: true
    levelGained?: true
    timestamp?: true
  }

  export type CultivationLogMaxAggregateInputType = {
    id?: true
    playerId?: true
    type?: true
    description?: true
    expGained?: true
    levelGained?: true
    timestamp?: true
  }

  export type CultivationLogCountAggregateInputType = {
    id?: true
    playerId?: true
    type?: true
    description?: true
    expGained?: true
    levelGained?: true
    timestamp?: true
    _all?: true
  }

  export type CultivationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CultivationLog to aggregate.
     */
    where?: CultivationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationLogs to fetch.
     */
    orderBy?: CultivationLogOrderByWithRelationInput | CultivationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CultivationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CultivationLogs
    **/
    _count?: true | CultivationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CultivationLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CultivationLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CultivationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CultivationLogMaxAggregateInputType
  }

  export type GetCultivationLogAggregateType<T extends CultivationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCultivationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCultivationLog[P]>
      : GetScalarType<T[P], AggregateCultivationLog[P]>
  }




  export type CultivationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultivationLogWhereInput
    orderBy?: CultivationLogOrderByWithAggregationInput | CultivationLogOrderByWithAggregationInput[]
    by: CultivationLogScalarFieldEnum[] | CultivationLogScalarFieldEnum
    having?: CultivationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CultivationLogCountAggregateInputType | true
    _avg?: CultivationLogAvgAggregateInputType
    _sum?: CultivationLogSumAggregateInputType
    _min?: CultivationLogMinAggregateInputType
    _max?: CultivationLogMaxAggregateInputType
  }

  export type CultivationLogGroupByOutputType = {
    id: string
    playerId: string
    type: string
    description: string
    expGained: number
    levelGained: number
    timestamp: Date
    _count: CultivationLogCountAggregateOutputType | null
    _avg: CultivationLogAvgAggregateOutputType | null
    _sum: CultivationLogSumAggregateOutputType | null
    _min: CultivationLogMinAggregateOutputType | null
    _max: CultivationLogMaxAggregateOutputType | null
  }

  type GetCultivationLogGroupByPayload<T extends CultivationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CultivationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CultivationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CultivationLogGroupByOutputType[P]>
            : GetScalarType<T[P], CultivationLogGroupByOutputType[P]>
        }
      >
    >


  export type CultivationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    type?: boolean
    description?: boolean
    expGained?: boolean
    levelGained?: boolean
    timestamp?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cultivationLog"]>

  export type CultivationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    type?: boolean
    description?: boolean
    expGained?: boolean
    levelGained?: boolean
    timestamp?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cultivationLog"]>

  export type CultivationLogSelectScalar = {
    id?: boolean
    playerId?: boolean
    type?: boolean
    description?: boolean
    expGained?: boolean
    levelGained?: boolean
    timestamp?: boolean
  }

  export type CultivationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type CultivationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $CultivationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CultivationLog"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      type: string
      description: string
      expGained: number
      levelGained: number
      timestamp: Date
    }, ExtArgs["result"]["cultivationLog"]>
    composites: {}
  }

  type CultivationLogGetPayload<S extends boolean | null | undefined | CultivationLogDefaultArgs> = $Result.GetResult<Prisma.$CultivationLogPayload, S>

  type CultivationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CultivationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CultivationLogCountAggregateInputType | true
    }

  export interface CultivationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CultivationLog'], meta: { name: 'CultivationLog' } }
    /**
     * Find zero or one CultivationLog that matches the filter.
     * @param {CultivationLogFindUniqueArgs} args - Arguments to find a CultivationLog
     * @example
     * // Get one CultivationLog
     * const cultivationLog = await prisma.cultivationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CultivationLogFindUniqueArgs>(args: SelectSubset<T, CultivationLogFindUniqueArgs<ExtArgs>>): Prisma__CultivationLogClient<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CultivationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CultivationLogFindUniqueOrThrowArgs} args - Arguments to find a CultivationLog
     * @example
     * // Get one CultivationLog
     * const cultivationLog = await prisma.cultivationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CultivationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CultivationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CultivationLogClient<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CultivationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationLogFindFirstArgs} args - Arguments to find a CultivationLog
     * @example
     * // Get one CultivationLog
     * const cultivationLog = await prisma.cultivationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CultivationLogFindFirstArgs>(args?: SelectSubset<T, CultivationLogFindFirstArgs<ExtArgs>>): Prisma__CultivationLogClient<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CultivationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationLogFindFirstOrThrowArgs} args - Arguments to find a CultivationLog
     * @example
     * // Get one CultivationLog
     * const cultivationLog = await prisma.cultivationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CultivationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CultivationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CultivationLogClient<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CultivationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CultivationLogs
     * const cultivationLogs = await prisma.cultivationLog.findMany()
     * 
     * // Get first 10 CultivationLogs
     * const cultivationLogs = await prisma.cultivationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cultivationLogWithIdOnly = await prisma.cultivationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CultivationLogFindManyArgs>(args?: SelectSubset<T, CultivationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CultivationLog.
     * @param {CultivationLogCreateArgs} args - Arguments to create a CultivationLog.
     * @example
     * // Create one CultivationLog
     * const CultivationLog = await prisma.cultivationLog.create({
     *   data: {
     *     // ... data to create a CultivationLog
     *   }
     * })
     * 
     */
    create<T extends CultivationLogCreateArgs>(args: SelectSubset<T, CultivationLogCreateArgs<ExtArgs>>): Prisma__CultivationLogClient<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CultivationLogs.
     * @param {CultivationLogCreateManyArgs} args - Arguments to create many CultivationLogs.
     * @example
     * // Create many CultivationLogs
     * const cultivationLog = await prisma.cultivationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CultivationLogCreateManyArgs>(args?: SelectSubset<T, CultivationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CultivationLogs and returns the data saved in the database.
     * @param {CultivationLogCreateManyAndReturnArgs} args - Arguments to create many CultivationLogs.
     * @example
     * // Create many CultivationLogs
     * const cultivationLog = await prisma.cultivationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CultivationLogs and only return the `id`
     * const cultivationLogWithIdOnly = await prisma.cultivationLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CultivationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CultivationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CultivationLog.
     * @param {CultivationLogDeleteArgs} args - Arguments to delete one CultivationLog.
     * @example
     * // Delete one CultivationLog
     * const CultivationLog = await prisma.cultivationLog.delete({
     *   where: {
     *     // ... filter to delete one CultivationLog
     *   }
     * })
     * 
     */
    delete<T extends CultivationLogDeleteArgs>(args: SelectSubset<T, CultivationLogDeleteArgs<ExtArgs>>): Prisma__CultivationLogClient<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CultivationLog.
     * @param {CultivationLogUpdateArgs} args - Arguments to update one CultivationLog.
     * @example
     * // Update one CultivationLog
     * const cultivationLog = await prisma.cultivationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CultivationLogUpdateArgs>(args: SelectSubset<T, CultivationLogUpdateArgs<ExtArgs>>): Prisma__CultivationLogClient<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CultivationLogs.
     * @param {CultivationLogDeleteManyArgs} args - Arguments to filter CultivationLogs to delete.
     * @example
     * // Delete a few CultivationLogs
     * const { count } = await prisma.cultivationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CultivationLogDeleteManyArgs>(args?: SelectSubset<T, CultivationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CultivationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CultivationLogs
     * const cultivationLog = await prisma.cultivationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CultivationLogUpdateManyArgs>(args: SelectSubset<T, CultivationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CultivationLog.
     * @param {CultivationLogUpsertArgs} args - Arguments to update or create a CultivationLog.
     * @example
     * // Update or create a CultivationLog
     * const cultivationLog = await prisma.cultivationLog.upsert({
     *   create: {
     *     // ... data to create a CultivationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CultivationLog we want to update
     *   }
     * })
     */
    upsert<T extends CultivationLogUpsertArgs>(args: SelectSubset<T, CultivationLogUpsertArgs<ExtArgs>>): Prisma__CultivationLogClient<$Result.GetResult<Prisma.$CultivationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CultivationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationLogCountArgs} args - Arguments to filter CultivationLogs to count.
     * @example
     * // Count the number of CultivationLogs
     * const count = await prisma.cultivationLog.count({
     *   where: {
     *     // ... the filter for the CultivationLogs we want to count
     *   }
     * })
    **/
    count<T extends CultivationLogCountArgs>(
      args?: Subset<T, CultivationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CultivationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CultivationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CultivationLogAggregateArgs>(args: Subset<T, CultivationLogAggregateArgs>): Prisma.PrismaPromise<GetCultivationLogAggregateType<T>>

    /**
     * Group by CultivationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CultivationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CultivationLogGroupByArgs['orderBy'] }
        : { orderBy?: CultivationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CultivationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCultivationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CultivationLog model
   */
  readonly fields: CultivationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CultivationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CultivationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CultivationLog model
   */ 
  interface CultivationLogFieldRefs {
    readonly id: FieldRef<"CultivationLog", 'String'>
    readonly playerId: FieldRef<"CultivationLog", 'String'>
    readonly type: FieldRef<"CultivationLog", 'String'>
    readonly description: FieldRef<"CultivationLog", 'String'>
    readonly expGained: FieldRef<"CultivationLog", 'Int'>
    readonly levelGained: FieldRef<"CultivationLog", 'Int'>
    readonly timestamp: FieldRef<"CultivationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CultivationLog findUnique
   */
  export type CultivationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
    /**
     * Filter, which CultivationLog to fetch.
     */
    where: CultivationLogWhereUniqueInput
  }

  /**
   * CultivationLog findUniqueOrThrow
   */
  export type CultivationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
    /**
     * Filter, which CultivationLog to fetch.
     */
    where: CultivationLogWhereUniqueInput
  }

  /**
   * CultivationLog findFirst
   */
  export type CultivationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
    /**
     * Filter, which CultivationLog to fetch.
     */
    where?: CultivationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationLogs to fetch.
     */
    orderBy?: CultivationLogOrderByWithRelationInput | CultivationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CultivationLogs.
     */
    cursor?: CultivationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CultivationLogs.
     */
    distinct?: CultivationLogScalarFieldEnum | CultivationLogScalarFieldEnum[]
  }

  /**
   * CultivationLog findFirstOrThrow
   */
  export type CultivationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
    /**
     * Filter, which CultivationLog to fetch.
     */
    where?: CultivationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationLogs to fetch.
     */
    orderBy?: CultivationLogOrderByWithRelationInput | CultivationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CultivationLogs.
     */
    cursor?: CultivationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CultivationLogs.
     */
    distinct?: CultivationLogScalarFieldEnum | CultivationLogScalarFieldEnum[]
  }

  /**
   * CultivationLog findMany
   */
  export type CultivationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
    /**
     * Filter, which CultivationLogs to fetch.
     */
    where?: CultivationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationLogs to fetch.
     */
    orderBy?: CultivationLogOrderByWithRelationInput | CultivationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CultivationLogs.
     */
    cursor?: CultivationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationLogs.
     */
    skip?: number
    distinct?: CultivationLogScalarFieldEnum | CultivationLogScalarFieldEnum[]
  }

  /**
   * CultivationLog create
   */
  export type CultivationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CultivationLog.
     */
    data: XOR<CultivationLogCreateInput, CultivationLogUncheckedCreateInput>
  }

  /**
   * CultivationLog createMany
   */
  export type CultivationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CultivationLogs.
     */
    data: CultivationLogCreateManyInput | CultivationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CultivationLog createManyAndReturn
   */
  export type CultivationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CultivationLogs.
     */
    data: CultivationLogCreateManyInput | CultivationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CultivationLog update
   */
  export type CultivationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CultivationLog.
     */
    data: XOR<CultivationLogUpdateInput, CultivationLogUncheckedUpdateInput>
    /**
     * Choose, which CultivationLog to update.
     */
    where: CultivationLogWhereUniqueInput
  }

  /**
   * CultivationLog updateMany
   */
  export type CultivationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CultivationLogs.
     */
    data: XOR<CultivationLogUpdateManyMutationInput, CultivationLogUncheckedUpdateManyInput>
    /**
     * Filter which CultivationLogs to update
     */
    where?: CultivationLogWhereInput
  }

  /**
   * CultivationLog upsert
   */
  export type CultivationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CultivationLog to update in case it exists.
     */
    where: CultivationLogWhereUniqueInput
    /**
     * In case the CultivationLog found by the `where` argument doesn't exist, create a new CultivationLog with this data.
     */
    create: XOR<CultivationLogCreateInput, CultivationLogUncheckedCreateInput>
    /**
     * In case the CultivationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CultivationLogUpdateInput, CultivationLogUncheckedUpdateInput>
  }

  /**
   * CultivationLog delete
   */
  export type CultivationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
    /**
     * Filter which CultivationLog to delete.
     */
    where: CultivationLogWhereUniqueInput
  }

  /**
   * CultivationLog deleteMany
   */
  export type CultivationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CultivationLogs to delete
     */
    where?: CultivationLogWhereInput
  }

  /**
   * CultivationLog without action
   */
  export type CultivationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationLog
     */
    select?: CultivationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    level: 'level',
    realm: 'realm',
    experience: 'experience',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    icon: 'icon',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const PlayerResourceScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    resourceId: 'resourceId',
    amount: 'amount',
    locked: 'locked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerResourceScalarFieldEnum = (typeof PlayerResourceScalarFieldEnum)[keyof typeof PlayerResourceScalarFieldEnum]


  export const CompanionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    icon: 'icon',
    rarity: 'rarity',
    basePower: 'basePower',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanionScalarFieldEnum = (typeof CompanionScalarFieldEnum)[keyof typeof CompanionScalarFieldEnum]


  export const PlayerCompanionScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    companionId: 'companionId',
    level: 'level',
    power: 'power',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerCompanionScalarFieldEnum = (typeof PlayerCompanionScalarFieldEnum)[keyof typeof PlayerCompanionScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    icon: 'icon',
    category: 'category',
    points: 'points',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const PlayerAchievementScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    achievementId: 'achievementId',
    unlockedAt: 'unlockedAt'
  };

  export type PlayerAchievementScalarFieldEnum = (typeof PlayerAchievementScalarFieldEnum)[keyof typeof PlayerAchievementScalarFieldEnum]


  export const QuestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    category: 'category',
    difficulty: 'difficulty',
    rewards: 'rewards',
    requirements: 'requirements',
    isActive: 'isActive',
    isRepeatable: 'isRepeatable',
    repeatInterval: 'repeatInterval',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestScalarFieldEnum = (typeof QuestScalarFieldEnum)[keyof typeof QuestScalarFieldEnum]


  export const PlayerQuestScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    questId: 'questId',
    status: 'status',
    progress: 'progress',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    lastCompletedAt: 'lastCompletedAt',
    cooldownUntil: 'cooldownUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerQuestScalarFieldEnum = (typeof PlayerQuestScalarFieldEnum)[keyof typeof PlayerQuestScalarFieldEnum]


  export const PlayerStatsScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    hp: 'hp',
    mp: 'mp',
    attack: 'attack',
    defense: 'defense',
    speed: 'speed',
    luck: 'luck',
    wisdom: 'wisdom',
    strength: 'strength',
    agility: 'agility',
    vitality: 'vitality',
    spirit: 'spirit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerStatsScalarFieldEnum = (typeof PlayerStatsScalarFieldEnum)[keyof typeof PlayerStatsScalarFieldEnum]


  export const EquipmentTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    slot: 'slot',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentTypeScalarFieldEnum = (typeof EquipmentTypeScalarFieldEnum)[keyof typeof EquipmentTypeScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    typeId: 'typeId',
    rarity: 'rarity',
    level: 'level',
    stats: 'stats',
    requirements: 'requirements',
    price: 'price',
    isTradeable: 'isTradeable',
    isSellable: 'isSellable',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const PlayerEquipmentScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    equipmentId: 'equipmentId',
    isEquipped: 'isEquipped',
    durability: 'durability',
    enhancement: 'enhancement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerEquipmentScalarFieldEnum = (typeof PlayerEquipmentScalarFieldEnum)[keyof typeof PlayerEquipmentScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    category: 'category',
    type: 'type',
    level: 'level',
    maxLevel: 'maxLevel',
    cooldown: 'cooldown',
    mpCost: 'mpCost',
    damage: 'damage',
    effects: 'effects',
    requirements: 'requirements',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const PlayerSkillScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    skillId: 'skillId',
    level: 'level',
    isLearned: 'isLearned',
    learnedAt: 'learnedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerSkillScalarFieldEnum = (typeof PlayerSkillScalarFieldEnum)[keyof typeof PlayerSkillScalarFieldEnum]


  export const TalentTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    icon: 'icon',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TalentTypeScalarFieldEnum = (typeof TalentTypeScalarFieldEnum)[keyof typeof TalentTypeScalarFieldEnum]


  export const TalentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    typeId: 'typeId',
    rarity: 'rarity',
    level: 'level',
    maxLevel: 'maxLevel',
    effects: 'effects',
    requirements: 'requirements',
    cost: 'cost',
    isActive: 'isActive',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TalentScalarFieldEnum = (typeof TalentScalarFieldEnum)[keyof typeof TalentScalarFieldEnum]


  export const PlayerTalentScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    talentId: 'talentId',
    level: 'level',
    isUnlocked: 'isUnlocked',
    unlockedAt: 'unlockedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerTalentScalarFieldEnum = (typeof PlayerTalentScalarFieldEnum)[keyof typeof PlayerTalentScalarFieldEnum]


  export const BuffScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    type: 'type',
    category: 'category',
    effects: 'effects',
    duration: 'duration',
    stackable: 'stackable',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuffScalarFieldEnum = (typeof BuffScalarFieldEnum)[keyof typeof BuffScalarFieldEnum]


  export const PlayerBuffScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    buffId: 'buffId',
    level: 'level',
    stacks: 'stacks',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerBuffScalarFieldEnum = (typeof PlayerBuffScalarFieldEnum)[keyof typeof PlayerBuffScalarFieldEnum]


  export const GameConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    type: 'type',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameConfigScalarFieldEnum = (typeof GameConfigScalarFieldEnum)[keyof typeof GameConfigScalarFieldEnum]


  export const ShopScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    category: 'category',
    isActive: 'isActive',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopScalarFieldEnum = (typeof ShopScalarFieldEnum)[keyof typeof ShopScalarFieldEnum]


  export const ShopItemScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    itemType: 'itemType',
    itemId: 'itemId',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    price: 'price',
    currency: 'currency',
    stock: 'stock',
    isActive: 'isActive',
    level: 'level',
    rarity: 'rarity',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopItemScalarFieldEnum = (typeof ShopItemScalarFieldEnum)[keyof typeof ShopItemScalarFieldEnum]


  export const PurchaseHistoryScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    shopId: 'shopId',
    itemId: 'itemId',
    itemName: 'itemName',
    quantity: 'quantity',
    price: 'price',
    currency: 'currency',
    totalCost: 'totalCost',
    createdAt: 'createdAt'
  };

  export type PurchaseHistoryScalarFieldEnum = (typeof PurchaseHistoryScalarFieldEnum)[keyof typeof PurchaseHistoryScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    itemType: 'itemType',
    itemId: 'itemId',
    name: 'name',
    quantity: 'quantity',
    stackable: 'stackable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    category: 'category',
    level: 'level',
    successRate: 'successRate',
    materials: 'materials',
    result: 'result',
    experience: 'experience',
    isActive: 'isActive',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const CraftingHistoryScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    recipeId: 'recipeId',
    success: 'success',
    quantity: 'quantity',
    materials: 'materials',
    result: 'result',
    createdAt: 'createdAt'
  };

  export type CraftingHistoryScalarFieldEnum = (typeof CraftingHistoryScalarFieldEnum)[keyof typeof CraftingHistoryScalarFieldEnum]


  export const DaoFurnaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    level: 'level',
    maxLevel: 'maxLevel',
    efficiency: 'efficiency',
    isActive: 'isActive',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DaoFurnaceScalarFieldEnum = (typeof DaoFurnaceScalarFieldEnum)[keyof typeof DaoFurnaceScalarFieldEnum]


  export const PlayerFurnaceScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    furnaceId: 'furnaceId',
    level: 'level',
    experience: 'experience',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerFurnaceScalarFieldEnum = (typeof PlayerFurnaceScalarFieldEnum)[keyof typeof PlayerFurnaceScalarFieldEnum]


  export const SpiritBeastTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    category: 'category',
    baseStats: 'baseStats',
    growthRate: 'growthRate',
    skills: 'skills',
    icon: 'icon',
    color: 'color',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpiritBeastTypeScalarFieldEnum = (typeof SpiritBeastTypeScalarFieldEnum)[keyof typeof SpiritBeastTypeScalarFieldEnum]


  export const SpiritBeastScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    typeId: 'typeId',
    name: 'name',
    level: 'level',
    experience: 'experience',
    stats: 'stats',
    skills: 'skills',
    happiness: 'happiness',
    hunger: 'hunger',
    health: 'health',
    isActive: 'isActive',
    isFighting: 'isFighting',
    capturedAt: 'capturedAt',
    lastFedAt: 'lastFedAt',
    lastPlayedAt: 'lastPlayedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpiritBeastScalarFieldEnum = (typeof SpiritBeastScalarFieldEnum)[keyof typeof SpiritBeastScalarFieldEnum]


  export const BeastFoodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    category: 'category',
    effects: 'effects',
    price: 'price',
    currency: 'currency',
    icon: 'icon',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BeastFoodScalarFieldEnum = (typeof BeastFoodScalarFieldEnum)[keyof typeof BeastFoodScalarFieldEnum]


  export const BeastFeedingHistoryScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    beastId: 'beastId',
    foodId: 'foodId',
    quantity: 'quantity',
    effects: 'effects',
    createdAt: 'createdAt'
  };

  export type BeastFeedingHistoryScalarFieldEnum = (typeof BeastFeedingHistoryScalarFieldEnum)[keyof typeof BeastFeedingHistoryScalarFieldEnum]


  export const HuntingGroundScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    level: 'level',
    maxLevel: 'maxLevel',
    difficulty: 'difficulty',
    beastTypes: 'beastTypes',
    dropRates: 'dropRates',
    isActive: 'isActive',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HuntingGroundScalarFieldEnum = (typeof HuntingGroundScalarFieldEnum)[keyof typeof HuntingGroundScalarFieldEnum]


  export const HuntingHistoryScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    groundId: 'groundId',
    beastId: 'beastId',
    success: 'success',
    duration: 'duration',
    rewards: 'rewards',
    createdAt: 'createdAt'
  };

  export type HuntingHistoryScalarFieldEnum = (typeof HuntingHistoryScalarFieldEnum)[keyof typeof HuntingHistoryScalarFieldEnum]


  export const PlayerCultivationScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    currentRealm: 'currentRealm',
    currentFloor: 'currentFloor',
    currentExp: 'currentExp',
    totalExpGained: 'totalExpGained',
    currentQuality: 'currentQuality',
    eternalTitles: 'eternalTitles',
    hasAscended: 'hasAscended',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerCultivationScalarFieldEnum = (typeof PlayerCultivationScalarFieldEnum)[keyof typeof PlayerCultivationScalarFieldEnum]


  export const CultivationLogScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    type: 'type',
    description: 'description',
    expGained: 'expGained',
    levelGained: 'levelGained',
    timestamp: 'timestamp'
  };

  export type CultivationLogScalarFieldEnum = (typeof CultivationLogScalarFieldEnum)[keyof typeof CultivationLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    player?: XOR<PlayerNullableRelationFilter, PlayerWhereInput> | null
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    player?: XOR<PlayerNullableRelationFilter, PlayerWhereInput> | null
    sessions?: SessionListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: StringFilter<"Player"> | string
    userId?: StringFilter<"Player"> | string
    name?: StringFilter<"Player"> | string
    level?: IntFilter<"Player"> | number
    realm?: StringFilter<"Player"> | string
    experience?: BigIntFilter<"Player"> | bigint | number
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    resources?: PlayerResourceListRelationFilter
    companions?: PlayerCompanionListRelationFilter
    achievements?: PlayerAchievementListRelationFilter
    quests?: PlayerQuestListRelationFilter
    stats?: XOR<PlayerStatsNullableRelationFilter, PlayerStatsWhereInput> | null
    equipments?: PlayerEquipmentListRelationFilter
    skills?: PlayerSkillListRelationFilter
    talents?: PlayerTalentListRelationFilter
    buffs?: PlayerBuffListRelationFilter
    purchases?: PurchaseHistoryListRelationFilter
    inventory?: InventoryListRelationFilter
    craftingHistory?: CraftingHistoryListRelationFilter
    furnaces?: PlayerFurnaceListRelationFilter
    spiritBeasts?: SpiritBeastListRelationFilter
    beastFeedingHistory?: BeastFeedingHistoryListRelationFilter
    huntingHistory?: HuntingHistoryListRelationFilter
    cultivationLogs?: CultivationLogListRelationFilter
    cultivation?: XOR<PlayerCultivationNullableRelationFilter, PlayerCultivationWhereInput> | null
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    realm?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    resources?: PlayerResourceOrderByRelationAggregateInput
    companions?: PlayerCompanionOrderByRelationAggregateInput
    achievements?: PlayerAchievementOrderByRelationAggregateInput
    quests?: PlayerQuestOrderByRelationAggregateInput
    stats?: PlayerStatsOrderByWithRelationInput
    equipments?: PlayerEquipmentOrderByRelationAggregateInput
    skills?: PlayerSkillOrderByRelationAggregateInput
    talents?: PlayerTalentOrderByRelationAggregateInput
    buffs?: PlayerBuffOrderByRelationAggregateInput
    purchases?: PurchaseHistoryOrderByRelationAggregateInput
    inventory?: InventoryOrderByRelationAggregateInput
    craftingHistory?: CraftingHistoryOrderByRelationAggregateInput
    furnaces?: PlayerFurnaceOrderByRelationAggregateInput
    spiritBeasts?: SpiritBeastOrderByRelationAggregateInput
    beastFeedingHistory?: BeastFeedingHistoryOrderByRelationAggregateInput
    huntingHistory?: HuntingHistoryOrderByRelationAggregateInput
    cultivationLogs?: CultivationLogOrderByRelationAggregateInput
    cultivation?: PlayerCultivationOrderByWithRelationInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    name?: StringFilter<"Player"> | string
    level?: IntFilter<"Player"> | number
    realm?: StringFilter<"Player"> | string
    experience?: BigIntFilter<"Player"> | bigint | number
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    resources?: PlayerResourceListRelationFilter
    companions?: PlayerCompanionListRelationFilter
    achievements?: PlayerAchievementListRelationFilter
    quests?: PlayerQuestListRelationFilter
    stats?: XOR<PlayerStatsNullableRelationFilter, PlayerStatsWhereInput> | null
    equipments?: PlayerEquipmentListRelationFilter
    skills?: PlayerSkillListRelationFilter
    talents?: PlayerTalentListRelationFilter
    buffs?: PlayerBuffListRelationFilter
    purchases?: PurchaseHistoryListRelationFilter
    inventory?: InventoryListRelationFilter
    craftingHistory?: CraftingHistoryListRelationFilter
    furnaces?: PlayerFurnaceListRelationFilter
    spiritBeasts?: SpiritBeastListRelationFilter
    beastFeedingHistory?: BeastFeedingHistoryListRelationFilter
    huntingHistory?: HuntingHistoryListRelationFilter
    cultivationLogs?: CultivationLogListRelationFilter
    cultivation?: XOR<PlayerCultivationNullableRelationFilter, PlayerCultivationWhereInput> | null
  }, "id" | "userId">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    realm?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Player"> | string
    userId?: StringWithAggregatesFilter<"Player"> | string
    name?: StringWithAggregatesFilter<"Player"> | string
    level?: IntWithAggregatesFilter<"Player"> | number
    realm?: StringWithAggregatesFilter<"Player"> | string
    experience?: BigIntWithAggregatesFilter<"Player"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: StringFilter<"Resource"> | string
    name?: StringFilter<"Resource"> | string
    displayName?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    icon?: StringNullableFilter<"Resource"> | string | null
    color?: StringNullableFilter<"Resource"> | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    playerResources?: PlayerResourceListRelationFilter
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    playerResources?: PlayerResourceOrderByRelationAggregateInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    displayName?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    icon?: StringNullableFilter<"Resource"> | string | null
    color?: StringNullableFilter<"Resource"> | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    playerResources?: PlayerResourceListRelationFilter
  }, "id" | "name">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resource"> | string
    name?: StringWithAggregatesFilter<"Resource"> | string
    displayName?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    color?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type PlayerResourceWhereInput = {
    AND?: PlayerResourceWhereInput | PlayerResourceWhereInput[]
    OR?: PlayerResourceWhereInput[]
    NOT?: PlayerResourceWhereInput | PlayerResourceWhereInput[]
    id?: StringFilter<"PlayerResource"> | string
    playerId?: StringFilter<"PlayerResource"> | string
    resourceId?: StringFilter<"PlayerResource"> | string
    amount?: DecimalFilter<"PlayerResource"> | Decimal | DecimalJsLike | number | string
    locked?: DecimalFilter<"PlayerResource"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PlayerResource"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerResource"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
  }

  export type PlayerResourceOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    resourceId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type PlayerResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_resourceId?: PlayerResourcePlayerIdResourceIdCompoundUniqueInput
    AND?: PlayerResourceWhereInput | PlayerResourceWhereInput[]
    OR?: PlayerResourceWhereInput[]
    NOT?: PlayerResourceWhereInput | PlayerResourceWhereInput[]
    playerId?: StringFilter<"PlayerResource"> | string
    resourceId?: StringFilter<"PlayerResource"> | string
    amount?: DecimalFilter<"PlayerResource"> | Decimal | DecimalJsLike | number | string
    locked?: DecimalFilter<"PlayerResource"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PlayerResource"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerResource"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
  }, "id" | "playerId_resourceId">

  export type PlayerResourceOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    resourceId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerResourceCountOrderByAggregateInput
    _avg?: PlayerResourceAvgOrderByAggregateInput
    _max?: PlayerResourceMaxOrderByAggregateInput
    _min?: PlayerResourceMinOrderByAggregateInput
    _sum?: PlayerResourceSumOrderByAggregateInput
  }

  export type PlayerResourceScalarWhereWithAggregatesInput = {
    AND?: PlayerResourceScalarWhereWithAggregatesInput | PlayerResourceScalarWhereWithAggregatesInput[]
    OR?: PlayerResourceScalarWhereWithAggregatesInput[]
    NOT?: PlayerResourceScalarWhereWithAggregatesInput | PlayerResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerResource"> | string
    playerId?: StringWithAggregatesFilter<"PlayerResource"> | string
    resourceId?: StringWithAggregatesFilter<"PlayerResource"> | string
    amount?: DecimalWithAggregatesFilter<"PlayerResource"> | Decimal | DecimalJsLike | number | string
    locked?: DecimalWithAggregatesFilter<"PlayerResource"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"PlayerResource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerResource"> | Date | string
  }

  export type CompanionWhereInput = {
    AND?: CompanionWhereInput | CompanionWhereInput[]
    OR?: CompanionWhereInput[]
    NOT?: CompanionWhereInput | CompanionWhereInput[]
    id?: StringFilter<"Companion"> | string
    name?: StringFilter<"Companion"> | string
    displayName?: StringFilter<"Companion"> | string
    description?: StringNullableFilter<"Companion"> | string | null
    icon?: StringNullableFilter<"Companion"> | string | null
    rarity?: StringFilter<"Companion"> | string
    basePower?: IntFilter<"Companion"> | number
    createdAt?: DateTimeFilter<"Companion"> | Date | string
    updatedAt?: DateTimeFilter<"Companion"> | Date | string
    playerCompanions?: PlayerCompanionListRelationFilter
  }

  export type CompanionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    rarity?: SortOrder
    basePower?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    playerCompanions?: PlayerCompanionOrderByRelationAggregateInput
  }

  export type CompanionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CompanionWhereInput | CompanionWhereInput[]
    OR?: CompanionWhereInput[]
    NOT?: CompanionWhereInput | CompanionWhereInput[]
    displayName?: StringFilter<"Companion"> | string
    description?: StringNullableFilter<"Companion"> | string | null
    icon?: StringNullableFilter<"Companion"> | string | null
    rarity?: StringFilter<"Companion"> | string
    basePower?: IntFilter<"Companion"> | number
    createdAt?: DateTimeFilter<"Companion"> | Date | string
    updatedAt?: DateTimeFilter<"Companion"> | Date | string
    playerCompanions?: PlayerCompanionListRelationFilter
  }, "id" | "name">

  export type CompanionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    rarity?: SortOrder
    basePower?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanionCountOrderByAggregateInput
    _avg?: CompanionAvgOrderByAggregateInput
    _max?: CompanionMaxOrderByAggregateInput
    _min?: CompanionMinOrderByAggregateInput
    _sum?: CompanionSumOrderByAggregateInput
  }

  export type CompanionScalarWhereWithAggregatesInput = {
    AND?: CompanionScalarWhereWithAggregatesInput | CompanionScalarWhereWithAggregatesInput[]
    OR?: CompanionScalarWhereWithAggregatesInput[]
    NOT?: CompanionScalarWhereWithAggregatesInput | CompanionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Companion"> | string
    name?: StringWithAggregatesFilter<"Companion"> | string
    displayName?: StringWithAggregatesFilter<"Companion"> | string
    description?: StringNullableWithAggregatesFilter<"Companion"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Companion"> | string | null
    rarity?: StringWithAggregatesFilter<"Companion"> | string
    basePower?: IntWithAggregatesFilter<"Companion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Companion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Companion"> | Date | string
  }

  export type PlayerCompanionWhereInput = {
    AND?: PlayerCompanionWhereInput | PlayerCompanionWhereInput[]
    OR?: PlayerCompanionWhereInput[]
    NOT?: PlayerCompanionWhereInput | PlayerCompanionWhereInput[]
    id?: StringFilter<"PlayerCompanion"> | string
    playerId?: StringFilter<"PlayerCompanion"> | string
    companionId?: StringFilter<"PlayerCompanion"> | string
    level?: IntFilter<"PlayerCompanion"> | number
    power?: IntFilter<"PlayerCompanion"> | number
    isActive?: BoolFilter<"PlayerCompanion"> | boolean
    createdAt?: DateTimeFilter<"PlayerCompanion"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerCompanion"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    companion?: XOR<CompanionRelationFilter, CompanionWhereInput>
  }

  export type PlayerCompanionOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    companionId?: SortOrder
    level?: SortOrder
    power?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    companion?: CompanionOrderByWithRelationInput
  }

  export type PlayerCompanionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_companionId?: PlayerCompanionPlayerIdCompanionIdCompoundUniqueInput
    AND?: PlayerCompanionWhereInput | PlayerCompanionWhereInput[]
    OR?: PlayerCompanionWhereInput[]
    NOT?: PlayerCompanionWhereInput | PlayerCompanionWhereInput[]
    playerId?: StringFilter<"PlayerCompanion"> | string
    companionId?: StringFilter<"PlayerCompanion"> | string
    level?: IntFilter<"PlayerCompanion"> | number
    power?: IntFilter<"PlayerCompanion"> | number
    isActive?: BoolFilter<"PlayerCompanion"> | boolean
    createdAt?: DateTimeFilter<"PlayerCompanion"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerCompanion"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    companion?: XOR<CompanionRelationFilter, CompanionWhereInput>
  }, "id" | "playerId_companionId">

  export type PlayerCompanionOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    companionId?: SortOrder
    level?: SortOrder
    power?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCompanionCountOrderByAggregateInput
    _avg?: PlayerCompanionAvgOrderByAggregateInput
    _max?: PlayerCompanionMaxOrderByAggregateInput
    _min?: PlayerCompanionMinOrderByAggregateInput
    _sum?: PlayerCompanionSumOrderByAggregateInput
  }

  export type PlayerCompanionScalarWhereWithAggregatesInput = {
    AND?: PlayerCompanionScalarWhereWithAggregatesInput | PlayerCompanionScalarWhereWithAggregatesInput[]
    OR?: PlayerCompanionScalarWhereWithAggregatesInput[]
    NOT?: PlayerCompanionScalarWhereWithAggregatesInput | PlayerCompanionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerCompanion"> | string
    playerId?: StringWithAggregatesFilter<"PlayerCompanion"> | string
    companionId?: StringWithAggregatesFilter<"PlayerCompanion"> | string
    level?: IntWithAggregatesFilter<"PlayerCompanion"> | number
    power?: IntWithAggregatesFilter<"PlayerCompanion"> | number
    isActive?: BoolWithAggregatesFilter<"PlayerCompanion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlayerCompanion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerCompanion"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    displayName?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    icon?: StringNullableFilter<"Achievement"> | string | null
    category?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    playerAchievements?: PlayerAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    playerAchievements?: PlayerAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    displayName?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    icon?: StringNullableFilter<"Achievement"> | string | null
    category?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    playerAchievements?: PlayerAchievementListRelationFilter
  }, "id" | "name">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    displayName?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    category?: StringWithAggregatesFilter<"Achievement"> | string
    points?: IntWithAggregatesFilter<"Achievement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type PlayerAchievementWhereInput = {
    AND?: PlayerAchievementWhereInput | PlayerAchievementWhereInput[]
    OR?: PlayerAchievementWhereInput[]
    NOT?: PlayerAchievementWhereInput | PlayerAchievementWhereInput[]
    id?: StringFilter<"PlayerAchievement"> | string
    playerId?: StringFilter<"PlayerAchievement"> | string
    achievementId?: StringFilter<"PlayerAchievement"> | string
    unlockedAt?: DateTimeFilter<"PlayerAchievement"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
  }

  export type PlayerAchievementOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type PlayerAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_achievementId?: PlayerAchievementPlayerIdAchievementIdCompoundUniqueInput
    AND?: PlayerAchievementWhereInput | PlayerAchievementWhereInput[]
    OR?: PlayerAchievementWhereInput[]
    NOT?: PlayerAchievementWhereInput | PlayerAchievementWhereInput[]
    playerId?: StringFilter<"PlayerAchievement"> | string
    achievementId?: StringFilter<"PlayerAchievement"> | string
    unlockedAt?: DateTimeFilter<"PlayerAchievement"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
  }, "id" | "playerId_achievementId">

  export type PlayerAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    _count?: PlayerAchievementCountOrderByAggregateInput
    _max?: PlayerAchievementMaxOrderByAggregateInput
    _min?: PlayerAchievementMinOrderByAggregateInput
  }

  export type PlayerAchievementScalarWhereWithAggregatesInput = {
    AND?: PlayerAchievementScalarWhereWithAggregatesInput | PlayerAchievementScalarWhereWithAggregatesInput[]
    OR?: PlayerAchievementScalarWhereWithAggregatesInput[]
    NOT?: PlayerAchievementScalarWhereWithAggregatesInput | PlayerAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerAchievement"> | string
    playerId?: StringWithAggregatesFilter<"PlayerAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"PlayerAchievement"> | string
    unlockedAt?: DateTimeWithAggregatesFilter<"PlayerAchievement"> | Date | string
  }

  export type QuestWhereInput = {
    AND?: QuestWhereInput | QuestWhereInput[]
    OR?: QuestWhereInput[]
    NOT?: QuestWhereInput | QuestWhereInput[]
    id?: StringFilter<"Quest"> | string
    name?: StringFilter<"Quest"> | string
    displayName?: StringFilter<"Quest"> | string
    description?: StringNullableFilter<"Quest"> | string | null
    category?: StringFilter<"Quest"> | string
    difficulty?: StringFilter<"Quest"> | string
    rewards?: StringNullableFilter<"Quest"> | string | null
    requirements?: StringNullableFilter<"Quest"> | string | null
    isActive?: BoolFilter<"Quest"> | boolean
    isRepeatable?: BoolFilter<"Quest"> | boolean
    repeatInterval?: IntNullableFilter<"Quest"> | number | null
    createdAt?: DateTimeFilter<"Quest"> | Date | string
    updatedAt?: DateTimeFilter<"Quest"> | Date | string
    playerQuests?: PlayerQuestListRelationFilter
  }

  export type QuestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    rewards?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isRepeatable?: SortOrder
    repeatInterval?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    playerQuests?: PlayerQuestOrderByRelationAggregateInput
  }

  export type QuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: QuestWhereInput | QuestWhereInput[]
    OR?: QuestWhereInput[]
    NOT?: QuestWhereInput | QuestWhereInput[]
    displayName?: StringFilter<"Quest"> | string
    description?: StringNullableFilter<"Quest"> | string | null
    category?: StringFilter<"Quest"> | string
    difficulty?: StringFilter<"Quest"> | string
    rewards?: StringNullableFilter<"Quest"> | string | null
    requirements?: StringNullableFilter<"Quest"> | string | null
    isActive?: BoolFilter<"Quest"> | boolean
    isRepeatable?: BoolFilter<"Quest"> | boolean
    repeatInterval?: IntNullableFilter<"Quest"> | number | null
    createdAt?: DateTimeFilter<"Quest"> | Date | string
    updatedAt?: DateTimeFilter<"Quest"> | Date | string
    playerQuests?: PlayerQuestListRelationFilter
  }, "id" | "name">

  export type QuestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    rewards?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isRepeatable?: SortOrder
    repeatInterval?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestCountOrderByAggregateInput
    _avg?: QuestAvgOrderByAggregateInput
    _max?: QuestMaxOrderByAggregateInput
    _min?: QuestMinOrderByAggregateInput
    _sum?: QuestSumOrderByAggregateInput
  }

  export type QuestScalarWhereWithAggregatesInput = {
    AND?: QuestScalarWhereWithAggregatesInput | QuestScalarWhereWithAggregatesInput[]
    OR?: QuestScalarWhereWithAggregatesInput[]
    NOT?: QuestScalarWhereWithAggregatesInput | QuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quest"> | string
    name?: StringWithAggregatesFilter<"Quest"> | string
    displayName?: StringWithAggregatesFilter<"Quest"> | string
    description?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    category?: StringWithAggregatesFilter<"Quest"> | string
    difficulty?: StringWithAggregatesFilter<"Quest"> | string
    rewards?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    requirements?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    isActive?: BoolWithAggregatesFilter<"Quest"> | boolean
    isRepeatable?: BoolWithAggregatesFilter<"Quest"> | boolean
    repeatInterval?: IntNullableWithAggregatesFilter<"Quest"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Quest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quest"> | Date | string
  }

  export type PlayerQuestWhereInput = {
    AND?: PlayerQuestWhereInput | PlayerQuestWhereInput[]
    OR?: PlayerQuestWhereInput[]
    NOT?: PlayerQuestWhereInput | PlayerQuestWhereInput[]
    id?: StringFilter<"PlayerQuest"> | string
    playerId?: StringFilter<"PlayerQuest"> | string
    questId?: StringFilter<"PlayerQuest"> | string
    status?: StringFilter<"PlayerQuest"> | string
    progress?: StringNullableFilter<"PlayerQuest"> | string | null
    startedAt?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    lastCompletedAt?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    cooldownUntil?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerQuest"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerQuest"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    quest?: XOR<QuestRelationFilter, QuestWhereInput>
  }

  export type PlayerQuestOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    questId?: SortOrder
    status?: SortOrder
    progress?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastCompletedAt?: SortOrderInput | SortOrder
    cooldownUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    quest?: QuestOrderByWithRelationInput
  }

  export type PlayerQuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_questId?: PlayerQuestPlayerIdQuestIdCompoundUniqueInput
    AND?: PlayerQuestWhereInput | PlayerQuestWhereInput[]
    OR?: PlayerQuestWhereInput[]
    NOT?: PlayerQuestWhereInput | PlayerQuestWhereInput[]
    playerId?: StringFilter<"PlayerQuest"> | string
    questId?: StringFilter<"PlayerQuest"> | string
    status?: StringFilter<"PlayerQuest"> | string
    progress?: StringNullableFilter<"PlayerQuest"> | string | null
    startedAt?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    lastCompletedAt?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    cooldownUntil?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerQuest"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerQuest"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    quest?: XOR<QuestRelationFilter, QuestWhereInput>
  }, "id" | "playerId_questId">

  export type PlayerQuestOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    questId?: SortOrder
    status?: SortOrder
    progress?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastCompletedAt?: SortOrderInput | SortOrder
    cooldownUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerQuestCountOrderByAggregateInput
    _max?: PlayerQuestMaxOrderByAggregateInput
    _min?: PlayerQuestMinOrderByAggregateInput
  }

  export type PlayerQuestScalarWhereWithAggregatesInput = {
    AND?: PlayerQuestScalarWhereWithAggregatesInput | PlayerQuestScalarWhereWithAggregatesInput[]
    OR?: PlayerQuestScalarWhereWithAggregatesInput[]
    NOT?: PlayerQuestScalarWhereWithAggregatesInput | PlayerQuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerQuest"> | string
    playerId?: StringWithAggregatesFilter<"PlayerQuest"> | string
    questId?: StringWithAggregatesFilter<"PlayerQuest"> | string
    status?: StringWithAggregatesFilter<"PlayerQuest"> | string
    progress?: StringNullableWithAggregatesFilter<"PlayerQuest"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"PlayerQuest"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"PlayerQuest"> | Date | string | null
    lastCompletedAt?: DateTimeNullableWithAggregatesFilter<"PlayerQuest"> | Date | string | null
    cooldownUntil?: DateTimeNullableWithAggregatesFilter<"PlayerQuest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlayerQuest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerQuest"> | Date | string
  }

  export type PlayerStatsWhereInput = {
    AND?: PlayerStatsWhereInput | PlayerStatsWhereInput[]
    OR?: PlayerStatsWhereInput[]
    NOT?: PlayerStatsWhereInput | PlayerStatsWhereInput[]
    id?: StringFilter<"PlayerStats"> | string
    playerId?: StringFilter<"PlayerStats"> | string
    hp?: IntFilter<"PlayerStats"> | number
    mp?: IntFilter<"PlayerStats"> | number
    attack?: IntFilter<"PlayerStats"> | number
    defense?: IntFilter<"PlayerStats"> | number
    speed?: IntFilter<"PlayerStats"> | number
    luck?: IntFilter<"PlayerStats"> | number
    wisdom?: IntFilter<"PlayerStats"> | number
    strength?: IntFilter<"PlayerStats"> | number
    agility?: IntFilter<"PlayerStats"> | number
    vitality?: IntFilter<"PlayerStats"> | number
    spirit?: IntFilter<"PlayerStats"> | number
    createdAt?: DateTimeFilter<"PlayerStats"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerStats"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type PlayerStatsOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    hp?: SortOrder
    mp?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    luck?: SortOrder
    wisdom?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    vitality?: SortOrder
    spirit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type PlayerStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: PlayerStatsWhereInput | PlayerStatsWhereInput[]
    OR?: PlayerStatsWhereInput[]
    NOT?: PlayerStatsWhereInput | PlayerStatsWhereInput[]
    hp?: IntFilter<"PlayerStats"> | number
    mp?: IntFilter<"PlayerStats"> | number
    attack?: IntFilter<"PlayerStats"> | number
    defense?: IntFilter<"PlayerStats"> | number
    speed?: IntFilter<"PlayerStats"> | number
    luck?: IntFilter<"PlayerStats"> | number
    wisdom?: IntFilter<"PlayerStats"> | number
    strength?: IntFilter<"PlayerStats"> | number
    agility?: IntFilter<"PlayerStats"> | number
    vitality?: IntFilter<"PlayerStats"> | number
    spirit?: IntFilter<"PlayerStats"> | number
    createdAt?: DateTimeFilter<"PlayerStats"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerStats"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }, "id" | "playerId">

  export type PlayerStatsOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    hp?: SortOrder
    mp?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    luck?: SortOrder
    wisdom?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    vitality?: SortOrder
    spirit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerStatsCountOrderByAggregateInput
    _avg?: PlayerStatsAvgOrderByAggregateInput
    _max?: PlayerStatsMaxOrderByAggregateInput
    _min?: PlayerStatsMinOrderByAggregateInput
    _sum?: PlayerStatsSumOrderByAggregateInput
  }

  export type PlayerStatsScalarWhereWithAggregatesInput = {
    AND?: PlayerStatsScalarWhereWithAggregatesInput | PlayerStatsScalarWhereWithAggregatesInput[]
    OR?: PlayerStatsScalarWhereWithAggregatesInput[]
    NOT?: PlayerStatsScalarWhereWithAggregatesInput | PlayerStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerStats"> | string
    playerId?: StringWithAggregatesFilter<"PlayerStats"> | string
    hp?: IntWithAggregatesFilter<"PlayerStats"> | number
    mp?: IntWithAggregatesFilter<"PlayerStats"> | number
    attack?: IntWithAggregatesFilter<"PlayerStats"> | number
    defense?: IntWithAggregatesFilter<"PlayerStats"> | number
    speed?: IntWithAggregatesFilter<"PlayerStats"> | number
    luck?: IntWithAggregatesFilter<"PlayerStats"> | number
    wisdom?: IntWithAggregatesFilter<"PlayerStats"> | number
    strength?: IntWithAggregatesFilter<"PlayerStats"> | number
    agility?: IntWithAggregatesFilter<"PlayerStats"> | number
    vitality?: IntWithAggregatesFilter<"PlayerStats"> | number
    spirit?: IntWithAggregatesFilter<"PlayerStats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlayerStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerStats"> | Date | string
  }

  export type EquipmentTypeWhereInput = {
    AND?: EquipmentTypeWhereInput | EquipmentTypeWhereInput[]
    OR?: EquipmentTypeWhereInput[]
    NOT?: EquipmentTypeWhereInput | EquipmentTypeWhereInput[]
    id?: StringFilter<"EquipmentType"> | string
    name?: StringFilter<"EquipmentType"> | string
    displayName?: StringFilter<"EquipmentType"> | string
    description?: StringNullableFilter<"EquipmentType"> | string | null
    slot?: StringFilter<"EquipmentType"> | string
    icon?: StringNullableFilter<"EquipmentType"> | string | null
    createdAt?: DateTimeFilter<"EquipmentType"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentType"> | Date | string
    equipments?: EquipmentListRelationFilter
  }

  export type EquipmentTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    slot?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    equipments?: EquipmentOrderByRelationAggregateInput
  }

  export type EquipmentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slot?: string
    AND?: EquipmentTypeWhereInput | EquipmentTypeWhereInput[]
    OR?: EquipmentTypeWhereInput[]
    NOT?: EquipmentTypeWhereInput | EquipmentTypeWhereInput[]
    displayName?: StringFilter<"EquipmentType"> | string
    description?: StringNullableFilter<"EquipmentType"> | string | null
    icon?: StringNullableFilter<"EquipmentType"> | string | null
    createdAt?: DateTimeFilter<"EquipmentType"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentType"> | Date | string
    equipments?: EquipmentListRelationFilter
  }, "id" | "name" | "slot">

  export type EquipmentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    slot?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentTypeCountOrderByAggregateInput
    _max?: EquipmentTypeMaxOrderByAggregateInput
    _min?: EquipmentTypeMinOrderByAggregateInput
  }

  export type EquipmentTypeScalarWhereWithAggregatesInput = {
    AND?: EquipmentTypeScalarWhereWithAggregatesInput | EquipmentTypeScalarWhereWithAggregatesInput[]
    OR?: EquipmentTypeScalarWhereWithAggregatesInput[]
    NOT?: EquipmentTypeScalarWhereWithAggregatesInput | EquipmentTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentType"> | string
    name?: StringWithAggregatesFilter<"EquipmentType"> | string
    displayName?: StringWithAggregatesFilter<"EquipmentType"> | string
    description?: StringNullableWithAggregatesFilter<"EquipmentType"> | string | null
    slot?: StringWithAggregatesFilter<"EquipmentType"> | string
    icon?: StringNullableWithAggregatesFilter<"EquipmentType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EquipmentType"> | Date | string
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    displayName?: StringFilter<"Equipment"> | string
    description?: StringNullableFilter<"Equipment"> | string | null
    typeId?: StringFilter<"Equipment"> | string
    rarity?: StringFilter<"Equipment"> | string
    level?: IntFilter<"Equipment"> | number
    stats?: StringNullableFilter<"Equipment"> | string | null
    requirements?: StringNullableFilter<"Equipment"> | string | null
    price?: IntFilter<"Equipment"> | number
    isTradeable?: BoolFilter<"Equipment"> | boolean
    isSellable?: BoolFilter<"Equipment"> | boolean
    icon?: StringNullableFilter<"Equipment"> | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    type?: XOR<EquipmentTypeRelationFilter, EquipmentTypeWhereInput>
    playerEquipments?: PlayerEquipmentListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    typeId?: SortOrder
    rarity?: SortOrder
    level?: SortOrder
    stats?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    price?: SortOrder
    isTradeable?: SortOrder
    isSellable?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: EquipmentTypeOrderByWithRelationInput
    playerEquipments?: PlayerEquipmentOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    displayName?: StringFilter<"Equipment"> | string
    description?: StringNullableFilter<"Equipment"> | string | null
    typeId?: StringFilter<"Equipment"> | string
    rarity?: StringFilter<"Equipment"> | string
    level?: IntFilter<"Equipment"> | number
    stats?: StringNullableFilter<"Equipment"> | string | null
    requirements?: StringNullableFilter<"Equipment"> | string | null
    price?: IntFilter<"Equipment"> | number
    isTradeable?: BoolFilter<"Equipment"> | boolean
    isSellable?: BoolFilter<"Equipment"> | boolean
    icon?: StringNullableFilter<"Equipment"> | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    type?: XOR<EquipmentTypeRelationFilter, EquipmentTypeWhereInput>
    playerEquipments?: PlayerEquipmentListRelationFilter
  }, "id" | "name">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    typeId?: SortOrder
    rarity?: SortOrder
    level?: SortOrder
    stats?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    price?: SortOrder
    isTradeable?: SortOrder
    isSellable?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    name?: StringWithAggregatesFilter<"Equipment"> | string
    displayName?: StringWithAggregatesFilter<"Equipment"> | string
    description?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    typeId?: StringWithAggregatesFilter<"Equipment"> | string
    rarity?: StringWithAggregatesFilter<"Equipment"> | string
    level?: IntWithAggregatesFilter<"Equipment"> | number
    stats?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    requirements?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    price?: IntWithAggregatesFilter<"Equipment"> | number
    isTradeable?: BoolWithAggregatesFilter<"Equipment"> | boolean
    isSellable?: BoolWithAggregatesFilter<"Equipment"> | boolean
    icon?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
  }

  export type PlayerEquipmentWhereInput = {
    AND?: PlayerEquipmentWhereInput | PlayerEquipmentWhereInput[]
    OR?: PlayerEquipmentWhereInput[]
    NOT?: PlayerEquipmentWhereInput | PlayerEquipmentWhereInput[]
    id?: StringFilter<"PlayerEquipment"> | string
    playerId?: StringFilter<"PlayerEquipment"> | string
    equipmentId?: StringFilter<"PlayerEquipment"> | string
    isEquipped?: BoolFilter<"PlayerEquipment"> | boolean
    durability?: IntFilter<"PlayerEquipment"> | number
    enhancement?: IntFilter<"PlayerEquipment"> | number
    createdAt?: DateTimeFilter<"PlayerEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerEquipment"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }

  export type PlayerEquipmentOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    equipmentId?: SortOrder
    isEquipped?: SortOrder
    durability?: SortOrder
    enhancement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type PlayerEquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_equipmentId?: PlayerEquipmentPlayerIdEquipmentIdCompoundUniqueInput
    AND?: PlayerEquipmentWhereInput | PlayerEquipmentWhereInput[]
    OR?: PlayerEquipmentWhereInput[]
    NOT?: PlayerEquipmentWhereInput | PlayerEquipmentWhereInput[]
    playerId?: StringFilter<"PlayerEquipment"> | string
    equipmentId?: StringFilter<"PlayerEquipment"> | string
    isEquipped?: BoolFilter<"PlayerEquipment"> | boolean
    durability?: IntFilter<"PlayerEquipment"> | number
    enhancement?: IntFilter<"PlayerEquipment"> | number
    createdAt?: DateTimeFilter<"PlayerEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerEquipment"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }, "id" | "playerId_equipmentId">

  export type PlayerEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    equipmentId?: SortOrder
    isEquipped?: SortOrder
    durability?: SortOrder
    enhancement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerEquipmentCountOrderByAggregateInput
    _avg?: PlayerEquipmentAvgOrderByAggregateInput
    _max?: PlayerEquipmentMaxOrderByAggregateInput
    _min?: PlayerEquipmentMinOrderByAggregateInput
    _sum?: PlayerEquipmentSumOrderByAggregateInput
  }

  export type PlayerEquipmentScalarWhereWithAggregatesInput = {
    AND?: PlayerEquipmentScalarWhereWithAggregatesInput | PlayerEquipmentScalarWhereWithAggregatesInput[]
    OR?: PlayerEquipmentScalarWhereWithAggregatesInput[]
    NOT?: PlayerEquipmentScalarWhereWithAggregatesInput | PlayerEquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerEquipment"> | string
    playerId?: StringWithAggregatesFilter<"PlayerEquipment"> | string
    equipmentId?: StringWithAggregatesFilter<"PlayerEquipment"> | string
    isEquipped?: BoolWithAggregatesFilter<"PlayerEquipment"> | boolean
    durability?: IntWithAggregatesFilter<"PlayerEquipment"> | number
    enhancement?: IntWithAggregatesFilter<"PlayerEquipment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlayerEquipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerEquipment"> | Date | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    displayName?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    category?: StringFilter<"Skill"> | string
    type?: StringFilter<"Skill"> | string
    level?: IntFilter<"Skill"> | number
    maxLevel?: IntFilter<"Skill"> | number
    cooldown?: IntFilter<"Skill"> | number
    mpCost?: IntFilter<"Skill"> | number
    damage?: IntFilter<"Skill"> | number
    effects?: StringNullableFilter<"Skill"> | string | null
    requirements?: StringNullableFilter<"Skill"> | string | null
    icon?: StringNullableFilter<"Skill"> | string | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    playerSkills?: PlayerSkillListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    type?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    cooldown?: SortOrder
    mpCost?: SortOrder
    damage?: SortOrder
    effects?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    playerSkills?: PlayerSkillOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    displayName?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    category?: StringFilter<"Skill"> | string
    type?: StringFilter<"Skill"> | string
    level?: IntFilter<"Skill"> | number
    maxLevel?: IntFilter<"Skill"> | number
    cooldown?: IntFilter<"Skill"> | number
    mpCost?: IntFilter<"Skill"> | number
    damage?: IntFilter<"Skill"> | number
    effects?: StringNullableFilter<"Skill"> | string | null
    requirements?: StringNullableFilter<"Skill"> | string | null
    icon?: StringNullableFilter<"Skill"> | string | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    playerSkills?: PlayerSkillListRelationFilter
  }, "id" | "name">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    type?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    cooldown?: SortOrder
    mpCost?: SortOrder
    damage?: SortOrder
    effects?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _avg?: SkillAvgOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
    _sum?: SkillSumOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Skill"> | string
    name?: StringWithAggregatesFilter<"Skill"> | string
    displayName?: StringWithAggregatesFilter<"Skill"> | string
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    category?: StringWithAggregatesFilter<"Skill"> | string
    type?: StringWithAggregatesFilter<"Skill"> | string
    level?: IntWithAggregatesFilter<"Skill"> | number
    maxLevel?: IntWithAggregatesFilter<"Skill"> | number
    cooldown?: IntWithAggregatesFilter<"Skill"> | number
    mpCost?: IntWithAggregatesFilter<"Skill"> | number
    damage?: IntWithAggregatesFilter<"Skill"> | number
    effects?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    requirements?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
  }

  export type PlayerSkillWhereInput = {
    AND?: PlayerSkillWhereInput | PlayerSkillWhereInput[]
    OR?: PlayerSkillWhereInput[]
    NOT?: PlayerSkillWhereInput | PlayerSkillWhereInput[]
    id?: StringFilter<"PlayerSkill"> | string
    playerId?: StringFilter<"PlayerSkill"> | string
    skillId?: StringFilter<"PlayerSkill"> | string
    level?: IntFilter<"PlayerSkill"> | number
    isLearned?: BoolFilter<"PlayerSkill"> | boolean
    learnedAt?: DateTimeNullableFilter<"PlayerSkill"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerSkill"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerSkill"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type PlayerSkillOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    isLearned?: SortOrder
    learnedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type PlayerSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_skillId?: PlayerSkillPlayerIdSkillIdCompoundUniqueInput
    AND?: PlayerSkillWhereInput | PlayerSkillWhereInput[]
    OR?: PlayerSkillWhereInput[]
    NOT?: PlayerSkillWhereInput | PlayerSkillWhereInput[]
    playerId?: StringFilter<"PlayerSkill"> | string
    skillId?: StringFilter<"PlayerSkill"> | string
    level?: IntFilter<"PlayerSkill"> | number
    isLearned?: BoolFilter<"PlayerSkill"> | boolean
    learnedAt?: DateTimeNullableFilter<"PlayerSkill"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerSkill"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerSkill"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "id" | "playerId_skillId">

  export type PlayerSkillOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    isLearned?: SortOrder
    learnedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerSkillCountOrderByAggregateInput
    _avg?: PlayerSkillAvgOrderByAggregateInput
    _max?: PlayerSkillMaxOrderByAggregateInput
    _min?: PlayerSkillMinOrderByAggregateInput
    _sum?: PlayerSkillSumOrderByAggregateInput
  }

  export type PlayerSkillScalarWhereWithAggregatesInput = {
    AND?: PlayerSkillScalarWhereWithAggregatesInput | PlayerSkillScalarWhereWithAggregatesInput[]
    OR?: PlayerSkillScalarWhereWithAggregatesInput[]
    NOT?: PlayerSkillScalarWhereWithAggregatesInput | PlayerSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerSkill"> | string
    playerId?: StringWithAggregatesFilter<"PlayerSkill"> | string
    skillId?: StringWithAggregatesFilter<"PlayerSkill"> | string
    level?: IntWithAggregatesFilter<"PlayerSkill"> | number
    isLearned?: BoolWithAggregatesFilter<"PlayerSkill"> | boolean
    learnedAt?: DateTimeNullableWithAggregatesFilter<"PlayerSkill"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlayerSkill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerSkill"> | Date | string
  }

  export type TalentTypeWhereInput = {
    AND?: TalentTypeWhereInput | TalentTypeWhereInput[]
    OR?: TalentTypeWhereInput[]
    NOT?: TalentTypeWhereInput | TalentTypeWhereInput[]
    id?: StringFilter<"TalentType"> | string
    name?: StringFilter<"TalentType"> | string
    displayName?: StringFilter<"TalentType"> | string
    description?: StringNullableFilter<"TalentType"> | string | null
    icon?: StringNullableFilter<"TalentType"> | string | null
    color?: StringNullableFilter<"TalentType"> | string | null
    createdAt?: DateTimeFilter<"TalentType"> | Date | string
    updatedAt?: DateTimeFilter<"TalentType"> | Date | string
    talents?: TalentListRelationFilter
  }

  export type TalentTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    talents?: TalentOrderByRelationAggregateInput
  }

  export type TalentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TalentTypeWhereInput | TalentTypeWhereInput[]
    OR?: TalentTypeWhereInput[]
    NOT?: TalentTypeWhereInput | TalentTypeWhereInput[]
    displayName?: StringFilter<"TalentType"> | string
    description?: StringNullableFilter<"TalentType"> | string | null
    icon?: StringNullableFilter<"TalentType"> | string | null
    color?: StringNullableFilter<"TalentType"> | string | null
    createdAt?: DateTimeFilter<"TalentType"> | Date | string
    updatedAt?: DateTimeFilter<"TalentType"> | Date | string
    talents?: TalentListRelationFilter
  }, "id" | "name">

  export type TalentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TalentTypeCountOrderByAggregateInput
    _max?: TalentTypeMaxOrderByAggregateInput
    _min?: TalentTypeMinOrderByAggregateInput
  }

  export type TalentTypeScalarWhereWithAggregatesInput = {
    AND?: TalentTypeScalarWhereWithAggregatesInput | TalentTypeScalarWhereWithAggregatesInput[]
    OR?: TalentTypeScalarWhereWithAggregatesInput[]
    NOT?: TalentTypeScalarWhereWithAggregatesInput | TalentTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TalentType"> | string
    name?: StringWithAggregatesFilter<"TalentType"> | string
    displayName?: StringWithAggregatesFilter<"TalentType"> | string
    description?: StringNullableWithAggregatesFilter<"TalentType"> | string | null
    icon?: StringNullableWithAggregatesFilter<"TalentType"> | string | null
    color?: StringNullableWithAggregatesFilter<"TalentType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TalentType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TalentType"> | Date | string
  }

  export type TalentWhereInput = {
    AND?: TalentWhereInput | TalentWhereInput[]
    OR?: TalentWhereInput[]
    NOT?: TalentWhereInput | TalentWhereInput[]
    id?: StringFilter<"Talent"> | string
    name?: StringFilter<"Talent"> | string
    displayName?: StringFilter<"Talent"> | string
    description?: StringNullableFilter<"Talent"> | string | null
    typeId?: StringFilter<"Talent"> | string
    rarity?: StringFilter<"Talent"> | string
    level?: IntFilter<"Talent"> | number
    maxLevel?: IntFilter<"Talent"> | number
    effects?: StringNullableFilter<"Talent"> | string | null
    requirements?: StringNullableFilter<"Talent"> | string | null
    cost?: IntFilter<"Talent"> | number
    isActive?: BoolFilter<"Talent"> | boolean
    icon?: StringNullableFilter<"Talent"> | string | null
    createdAt?: DateTimeFilter<"Talent"> | Date | string
    updatedAt?: DateTimeFilter<"Talent"> | Date | string
    type?: XOR<TalentTypeRelationFilter, TalentTypeWhereInput>
    playerTalents?: PlayerTalentListRelationFilter
  }

  export type TalentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    typeId?: SortOrder
    rarity?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    effects?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    cost?: SortOrder
    isActive?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: TalentTypeOrderByWithRelationInput
    playerTalents?: PlayerTalentOrderByRelationAggregateInput
  }

  export type TalentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TalentWhereInput | TalentWhereInput[]
    OR?: TalentWhereInput[]
    NOT?: TalentWhereInput | TalentWhereInput[]
    displayName?: StringFilter<"Talent"> | string
    description?: StringNullableFilter<"Talent"> | string | null
    typeId?: StringFilter<"Talent"> | string
    rarity?: StringFilter<"Talent"> | string
    level?: IntFilter<"Talent"> | number
    maxLevel?: IntFilter<"Talent"> | number
    effects?: StringNullableFilter<"Talent"> | string | null
    requirements?: StringNullableFilter<"Talent"> | string | null
    cost?: IntFilter<"Talent"> | number
    isActive?: BoolFilter<"Talent"> | boolean
    icon?: StringNullableFilter<"Talent"> | string | null
    createdAt?: DateTimeFilter<"Talent"> | Date | string
    updatedAt?: DateTimeFilter<"Talent"> | Date | string
    type?: XOR<TalentTypeRelationFilter, TalentTypeWhereInput>
    playerTalents?: PlayerTalentListRelationFilter
  }, "id" | "name">

  export type TalentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    typeId?: SortOrder
    rarity?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    effects?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    cost?: SortOrder
    isActive?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TalentCountOrderByAggregateInput
    _avg?: TalentAvgOrderByAggregateInput
    _max?: TalentMaxOrderByAggregateInput
    _min?: TalentMinOrderByAggregateInput
    _sum?: TalentSumOrderByAggregateInput
  }

  export type TalentScalarWhereWithAggregatesInput = {
    AND?: TalentScalarWhereWithAggregatesInput | TalentScalarWhereWithAggregatesInput[]
    OR?: TalentScalarWhereWithAggregatesInput[]
    NOT?: TalentScalarWhereWithAggregatesInput | TalentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Talent"> | string
    name?: StringWithAggregatesFilter<"Talent"> | string
    displayName?: StringWithAggregatesFilter<"Talent"> | string
    description?: StringNullableWithAggregatesFilter<"Talent"> | string | null
    typeId?: StringWithAggregatesFilter<"Talent"> | string
    rarity?: StringWithAggregatesFilter<"Talent"> | string
    level?: IntWithAggregatesFilter<"Talent"> | number
    maxLevel?: IntWithAggregatesFilter<"Talent"> | number
    effects?: StringNullableWithAggregatesFilter<"Talent"> | string | null
    requirements?: StringNullableWithAggregatesFilter<"Talent"> | string | null
    cost?: IntWithAggregatesFilter<"Talent"> | number
    isActive?: BoolWithAggregatesFilter<"Talent"> | boolean
    icon?: StringNullableWithAggregatesFilter<"Talent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Talent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Talent"> | Date | string
  }

  export type PlayerTalentWhereInput = {
    AND?: PlayerTalentWhereInput | PlayerTalentWhereInput[]
    OR?: PlayerTalentWhereInput[]
    NOT?: PlayerTalentWhereInput | PlayerTalentWhereInput[]
    id?: StringFilter<"PlayerTalent"> | string
    playerId?: StringFilter<"PlayerTalent"> | string
    talentId?: StringFilter<"PlayerTalent"> | string
    level?: IntFilter<"PlayerTalent"> | number
    isUnlocked?: BoolFilter<"PlayerTalent"> | boolean
    unlockedAt?: DateTimeNullableFilter<"PlayerTalent"> | Date | string | null
    isActive?: BoolFilter<"PlayerTalent"> | boolean
    createdAt?: DateTimeFilter<"PlayerTalent"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerTalent"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    talent?: XOR<TalentRelationFilter, TalentWhereInput>
  }

  export type PlayerTalentOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    talentId?: SortOrder
    level?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    talent?: TalentOrderByWithRelationInput
  }

  export type PlayerTalentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_talentId?: PlayerTalentPlayerIdTalentIdCompoundUniqueInput
    AND?: PlayerTalentWhereInput | PlayerTalentWhereInput[]
    OR?: PlayerTalentWhereInput[]
    NOT?: PlayerTalentWhereInput | PlayerTalentWhereInput[]
    playerId?: StringFilter<"PlayerTalent"> | string
    talentId?: StringFilter<"PlayerTalent"> | string
    level?: IntFilter<"PlayerTalent"> | number
    isUnlocked?: BoolFilter<"PlayerTalent"> | boolean
    unlockedAt?: DateTimeNullableFilter<"PlayerTalent"> | Date | string | null
    isActive?: BoolFilter<"PlayerTalent"> | boolean
    createdAt?: DateTimeFilter<"PlayerTalent"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerTalent"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    talent?: XOR<TalentRelationFilter, TalentWhereInput>
  }, "id" | "playerId_talentId">

  export type PlayerTalentOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    talentId?: SortOrder
    level?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerTalentCountOrderByAggregateInput
    _avg?: PlayerTalentAvgOrderByAggregateInput
    _max?: PlayerTalentMaxOrderByAggregateInput
    _min?: PlayerTalentMinOrderByAggregateInput
    _sum?: PlayerTalentSumOrderByAggregateInput
  }

  export type PlayerTalentScalarWhereWithAggregatesInput = {
    AND?: PlayerTalentScalarWhereWithAggregatesInput | PlayerTalentScalarWhereWithAggregatesInput[]
    OR?: PlayerTalentScalarWhereWithAggregatesInput[]
    NOT?: PlayerTalentScalarWhereWithAggregatesInput | PlayerTalentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerTalent"> | string
    playerId?: StringWithAggregatesFilter<"PlayerTalent"> | string
    talentId?: StringWithAggregatesFilter<"PlayerTalent"> | string
    level?: IntWithAggregatesFilter<"PlayerTalent"> | number
    isUnlocked?: BoolWithAggregatesFilter<"PlayerTalent"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"PlayerTalent"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"PlayerTalent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlayerTalent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerTalent"> | Date | string
  }

  export type BuffWhereInput = {
    AND?: BuffWhereInput | BuffWhereInput[]
    OR?: BuffWhereInput[]
    NOT?: BuffWhereInput | BuffWhereInput[]
    id?: StringFilter<"Buff"> | string
    name?: StringFilter<"Buff"> | string
    displayName?: StringFilter<"Buff"> | string
    description?: StringNullableFilter<"Buff"> | string | null
    type?: StringFilter<"Buff"> | string
    category?: StringFilter<"Buff"> | string
    effects?: StringNullableFilter<"Buff"> | string | null
    duration?: IntFilter<"Buff"> | number
    stackable?: BoolFilter<"Buff"> | boolean
    icon?: StringNullableFilter<"Buff"> | string | null
    createdAt?: DateTimeFilter<"Buff"> | Date | string
    updatedAt?: DateTimeFilter<"Buff"> | Date | string
    playerBuffs?: PlayerBuffListRelationFilter
  }

  export type BuffOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    effects?: SortOrderInput | SortOrder
    duration?: SortOrder
    stackable?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    playerBuffs?: PlayerBuffOrderByRelationAggregateInput
  }

  export type BuffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BuffWhereInput | BuffWhereInput[]
    OR?: BuffWhereInput[]
    NOT?: BuffWhereInput | BuffWhereInput[]
    displayName?: StringFilter<"Buff"> | string
    description?: StringNullableFilter<"Buff"> | string | null
    type?: StringFilter<"Buff"> | string
    category?: StringFilter<"Buff"> | string
    effects?: StringNullableFilter<"Buff"> | string | null
    duration?: IntFilter<"Buff"> | number
    stackable?: BoolFilter<"Buff"> | boolean
    icon?: StringNullableFilter<"Buff"> | string | null
    createdAt?: DateTimeFilter<"Buff"> | Date | string
    updatedAt?: DateTimeFilter<"Buff"> | Date | string
    playerBuffs?: PlayerBuffListRelationFilter
  }, "id" | "name">

  export type BuffOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    effects?: SortOrderInput | SortOrder
    duration?: SortOrder
    stackable?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuffCountOrderByAggregateInput
    _avg?: BuffAvgOrderByAggregateInput
    _max?: BuffMaxOrderByAggregateInput
    _min?: BuffMinOrderByAggregateInput
    _sum?: BuffSumOrderByAggregateInput
  }

  export type BuffScalarWhereWithAggregatesInput = {
    AND?: BuffScalarWhereWithAggregatesInput | BuffScalarWhereWithAggregatesInput[]
    OR?: BuffScalarWhereWithAggregatesInput[]
    NOT?: BuffScalarWhereWithAggregatesInput | BuffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Buff"> | string
    name?: StringWithAggregatesFilter<"Buff"> | string
    displayName?: StringWithAggregatesFilter<"Buff"> | string
    description?: StringNullableWithAggregatesFilter<"Buff"> | string | null
    type?: StringWithAggregatesFilter<"Buff"> | string
    category?: StringWithAggregatesFilter<"Buff"> | string
    effects?: StringNullableWithAggregatesFilter<"Buff"> | string | null
    duration?: IntWithAggregatesFilter<"Buff"> | number
    stackable?: BoolWithAggregatesFilter<"Buff"> | boolean
    icon?: StringNullableWithAggregatesFilter<"Buff"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Buff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Buff"> | Date | string
  }

  export type PlayerBuffWhereInput = {
    AND?: PlayerBuffWhereInput | PlayerBuffWhereInput[]
    OR?: PlayerBuffWhereInput[]
    NOT?: PlayerBuffWhereInput | PlayerBuffWhereInput[]
    id?: StringFilter<"PlayerBuff"> | string
    playerId?: StringFilter<"PlayerBuff"> | string
    buffId?: StringFilter<"PlayerBuff"> | string
    level?: IntFilter<"PlayerBuff"> | number
    stacks?: IntFilter<"PlayerBuff"> | number
    expiresAt?: DateTimeNullableFilter<"PlayerBuff"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerBuff"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerBuff"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    buff?: XOR<BuffRelationFilter, BuffWhereInput>
  }

  export type PlayerBuffOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    buffId?: SortOrder
    level?: SortOrder
    stacks?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    buff?: BuffOrderByWithRelationInput
  }

  export type PlayerBuffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_buffId?: PlayerBuffPlayerIdBuffIdCompoundUniqueInput
    AND?: PlayerBuffWhereInput | PlayerBuffWhereInput[]
    OR?: PlayerBuffWhereInput[]
    NOT?: PlayerBuffWhereInput | PlayerBuffWhereInput[]
    playerId?: StringFilter<"PlayerBuff"> | string
    buffId?: StringFilter<"PlayerBuff"> | string
    level?: IntFilter<"PlayerBuff"> | number
    stacks?: IntFilter<"PlayerBuff"> | number
    expiresAt?: DateTimeNullableFilter<"PlayerBuff"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerBuff"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerBuff"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    buff?: XOR<BuffRelationFilter, BuffWhereInput>
  }, "id" | "playerId_buffId">

  export type PlayerBuffOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    buffId?: SortOrder
    level?: SortOrder
    stacks?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerBuffCountOrderByAggregateInput
    _avg?: PlayerBuffAvgOrderByAggregateInput
    _max?: PlayerBuffMaxOrderByAggregateInput
    _min?: PlayerBuffMinOrderByAggregateInput
    _sum?: PlayerBuffSumOrderByAggregateInput
  }

  export type PlayerBuffScalarWhereWithAggregatesInput = {
    AND?: PlayerBuffScalarWhereWithAggregatesInput | PlayerBuffScalarWhereWithAggregatesInput[]
    OR?: PlayerBuffScalarWhereWithAggregatesInput[]
    NOT?: PlayerBuffScalarWhereWithAggregatesInput | PlayerBuffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerBuff"> | string
    playerId?: StringWithAggregatesFilter<"PlayerBuff"> | string
    buffId?: StringWithAggregatesFilter<"PlayerBuff"> | string
    level?: IntWithAggregatesFilter<"PlayerBuff"> | number
    stacks?: IntWithAggregatesFilter<"PlayerBuff"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PlayerBuff"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlayerBuff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerBuff"> | Date | string
  }

  export type GameConfigWhereInput = {
    AND?: GameConfigWhereInput | GameConfigWhereInput[]
    OR?: GameConfigWhereInput[]
    NOT?: GameConfigWhereInput | GameConfigWhereInput[]
    id?: StringFilter<"GameConfig"> | string
    key?: StringFilter<"GameConfig"> | string
    value?: StringFilter<"GameConfig"> | string
    type?: StringFilter<"GameConfig"> | string
    category?: StringFilter<"GameConfig"> | string
    createdAt?: DateTimeFilter<"GameConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GameConfig"> | Date | string
  }

  export type GameConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: GameConfigWhereInput | GameConfigWhereInput[]
    OR?: GameConfigWhereInput[]
    NOT?: GameConfigWhereInput | GameConfigWhereInput[]
    value?: StringFilter<"GameConfig"> | string
    type?: StringFilter<"GameConfig"> | string
    category?: StringFilter<"GameConfig"> | string
    createdAt?: DateTimeFilter<"GameConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GameConfig"> | Date | string
  }, "id" | "key">

  export type GameConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameConfigCountOrderByAggregateInput
    _max?: GameConfigMaxOrderByAggregateInput
    _min?: GameConfigMinOrderByAggregateInput
  }

  export type GameConfigScalarWhereWithAggregatesInput = {
    AND?: GameConfigScalarWhereWithAggregatesInput | GameConfigScalarWhereWithAggregatesInput[]
    OR?: GameConfigScalarWhereWithAggregatesInput[]
    NOT?: GameConfigScalarWhereWithAggregatesInput | GameConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameConfig"> | string
    key?: StringWithAggregatesFilter<"GameConfig"> | string
    value?: StringWithAggregatesFilter<"GameConfig"> | string
    type?: StringWithAggregatesFilter<"GameConfig"> | string
    category?: StringWithAggregatesFilter<"GameConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GameConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameConfig"> | Date | string
  }

  export type ShopWhereInput = {
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    id?: StringFilter<"Shop"> | string
    name?: StringFilter<"Shop"> | string
    displayName?: StringFilter<"Shop"> | string
    description?: StringNullableFilter<"Shop"> | string | null
    category?: StringFilter<"Shop"> | string
    isActive?: BoolFilter<"Shop"> | boolean
    icon?: StringNullableFilter<"Shop"> | string | null
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    items?: ShopItemListRelationFilter
    purchases?: PurchaseHistoryListRelationFilter
  }

  export type ShopOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    isActive?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: ShopItemOrderByRelationAggregateInput
    purchases?: PurchaseHistoryOrderByRelationAggregateInput
  }

  export type ShopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    displayName?: StringFilter<"Shop"> | string
    description?: StringNullableFilter<"Shop"> | string | null
    category?: StringFilter<"Shop"> | string
    isActive?: BoolFilter<"Shop"> | boolean
    icon?: StringNullableFilter<"Shop"> | string | null
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    items?: ShopItemListRelationFilter
    purchases?: PurchaseHistoryListRelationFilter
  }, "id" | "name">

  export type ShopOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    isActive?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopCountOrderByAggregateInput
    _max?: ShopMaxOrderByAggregateInput
    _min?: ShopMinOrderByAggregateInput
  }

  export type ShopScalarWhereWithAggregatesInput = {
    AND?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    OR?: ShopScalarWhereWithAggregatesInput[]
    NOT?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shop"> | string
    name?: StringWithAggregatesFilter<"Shop"> | string
    displayName?: StringWithAggregatesFilter<"Shop"> | string
    description?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    category?: StringWithAggregatesFilter<"Shop"> | string
    isActive?: BoolWithAggregatesFilter<"Shop"> | boolean
    icon?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
  }

  export type ShopItemWhereInput = {
    AND?: ShopItemWhereInput | ShopItemWhereInput[]
    OR?: ShopItemWhereInput[]
    NOT?: ShopItemWhereInput | ShopItemWhereInput[]
    id?: StringFilter<"ShopItem"> | string
    shopId?: StringFilter<"ShopItem"> | string
    itemType?: StringFilter<"ShopItem"> | string
    itemId?: StringFilter<"ShopItem"> | string
    name?: StringFilter<"ShopItem"> | string
    displayName?: StringFilter<"ShopItem"> | string
    description?: StringNullableFilter<"ShopItem"> | string | null
    price?: IntFilter<"ShopItem"> | number
    currency?: StringFilter<"ShopItem"> | string
    stock?: IntFilter<"ShopItem"> | number
    isActive?: BoolFilter<"ShopItem"> | boolean
    level?: IntFilter<"ShopItem"> | number
    rarity?: StringFilter<"ShopItem"> | string
    icon?: StringNullableFilter<"ShopItem"> | string | null
    createdAt?: DateTimeFilter<"ShopItem"> | Date | string
    updatedAt?: DateTimeFilter<"ShopItem"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type ShopItemOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    level?: SortOrder
    rarity?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shop?: ShopOrderByWithRelationInput
  }

  export type ShopItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shopId_itemId?: ShopItemShopIdItemIdCompoundUniqueInput
    AND?: ShopItemWhereInput | ShopItemWhereInput[]
    OR?: ShopItemWhereInput[]
    NOT?: ShopItemWhereInput | ShopItemWhereInput[]
    shopId?: StringFilter<"ShopItem"> | string
    itemType?: StringFilter<"ShopItem"> | string
    itemId?: StringFilter<"ShopItem"> | string
    name?: StringFilter<"ShopItem"> | string
    displayName?: StringFilter<"ShopItem"> | string
    description?: StringNullableFilter<"ShopItem"> | string | null
    price?: IntFilter<"ShopItem"> | number
    currency?: StringFilter<"ShopItem"> | string
    stock?: IntFilter<"ShopItem"> | number
    isActive?: BoolFilter<"ShopItem"> | boolean
    level?: IntFilter<"ShopItem"> | number
    rarity?: StringFilter<"ShopItem"> | string
    icon?: StringNullableFilter<"ShopItem"> | string | null
    createdAt?: DateTimeFilter<"ShopItem"> | Date | string
    updatedAt?: DateTimeFilter<"ShopItem"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id" | "shopId_itemId">

  export type ShopItemOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    level?: SortOrder
    rarity?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopItemCountOrderByAggregateInput
    _avg?: ShopItemAvgOrderByAggregateInput
    _max?: ShopItemMaxOrderByAggregateInput
    _min?: ShopItemMinOrderByAggregateInput
    _sum?: ShopItemSumOrderByAggregateInput
  }

  export type ShopItemScalarWhereWithAggregatesInput = {
    AND?: ShopItemScalarWhereWithAggregatesInput | ShopItemScalarWhereWithAggregatesInput[]
    OR?: ShopItemScalarWhereWithAggregatesInput[]
    NOT?: ShopItemScalarWhereWithAggregatesInput | ShopItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopItem"> | string
    shopId?: StringWithAggregatesFilter<"ShopItem"> | string
    itemType?: StringWithAggregatesFilter<"ShopItem"> | string
    itemId?: StringWithAggregatesFilter<"ShopItem"> | string
    name?: StringWithAggregatesFilter<"ShopItem"> | string
    displayName?: StringWithAggregatesFilter<"ShopItem"> | string
    description?: StringNullableWithAggregatesFilter<"ShopItem"> | string | null
    price?: IntWithAggregatesFilter<"ShopItem"> | number
    currency?: StringWithAggregatesFilter<"ShopItem"> | string
    stock?: IntWithAggregatesFilter<"ShopItem"> | number
    isActive?: BoolWithAggregatesFilter<"ShopItem"> | boolean
    level?: IntWithAggregatesFilter<"ShopItem"> | number
    rarity?: StringWithAggregatesFilter<"ShopItem"> | string
    icon?: StringNullableWithAggregatesFilter<"ShopItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShopItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopItem"> | Date | string
  }

  export type PurchaseHistoryWhereInput = {
    AND?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    OR?: PurchaseHistoryWhereInput[]
    NOT?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    id?: StringFilter<"PurchaseHistory"> | string
    playerId?: StringFilter<"PurchaseHistory"> | string
    shopId?: StringFilter<"PurchaseHistory"> | string
    itemId?: StringFilter<"PurchaseHistory"> | string
    itemName?: StringFilter<"PurchaseHistory"> | string
    quantity?: IntFilter<"PurchaseHistory"> | number
    price?: IntFilter<"PurchaseHistory"> | number
    currency?: StringFilter<"PurchaseHistory"> | string
    totalCost?: IntFilter<"PurchaseHistory"> | number
    createdAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type PurchaseHistoryOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    shopId?: SortOrder
    itemId?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
  }

  export type PurchaseHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    OR?: PurchaseHistoryWhereInput[]
    NOT?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    playerId?: StringFilter<"PurchaseHistory"> | string
    shopId?: StringFilter<"PurchaseHistory"> | string
    itemId?: StringFilter<"PurchaseHistory"> | string
    itemName?: StringFilter<"PurchaseHistory"> | string
    quantity?: IntFilter<"PurchaseHistory"> | number
    price?: IntFilter<"PurchaseHistory"> | number
    currency?: StringFilter<"PurchaseHistory"> | string
    totalCost?: IntFilter<"PurchaseHistory"> | number
    createdAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id">

  export type PurchaseHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    shopId?: SortOrder
    itemId?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    _count?: PurchaseHistoryCountOrderByAggregateInput
    _avg?: PurchaseHistoryAvgOrderByAggregateInput
    _max?: PurchaseHistoryMaxOrderByAggregateInput
    _min?: PurchaseHistoryMinOrderByAggregateInput
    _sum?: PurchaseHistorySumOrderByAggregateInput
  }

  export type PurchaseHistoryScalarWhereWithAggregatesInput = {
    AND?: PurchaseHistoryScalarWhereWithAggregatesInput | PurchaseHistoryScalarWhereWithAggregatesInput[]
    OR?: PurchaseHistoryScalarWhereWithAggregatesInput[]
    NOT?: PurchaseHistoryScalarWhereWithAggregatesInput | PurchaseHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseHistory"> | string
    playerId?: StringWithAggregatesFilter<"PurchaseHistory"> | string
    shopId?: StringWithAggregatesFilter<"PurchaseHistory"> | string
    itemId?: StringWithAggregatesFilter<"PurchaseHistory"> | string
    itemName?: StringWithAggregatesFilter<"PurchaseHistory"> | string
    quantity?: IntWithAggregatesFilter<"PurchaseHistory"> | number
    price?: IntWithAggregatesFilter<"PurchaseHistory"> | number
    currency?: StringWithAggregatesFilter<"PurchaseHistory"> | string
    totalCost?: IntWithAggregatesFilter<"PurchaseHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseHistory"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    playerId?: StringFilter<"Inventory"> | string
    itemType?: StringFilter<"Inventory"> | string
    itemId?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    quantity?: IntFilter<"Inventory"> | number
    stackable?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    stackable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_itemId?: InventoryPlayerIdItemIdCompoundUniqueInput
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    playerId?: StringFilter<"Inventory"> | string
    itemType?: StringFilter<"Inventory"> | string
    itemId?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    quantity?: IntFilter<"Inventory"> | number
    stackable?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }, "id" | "playerId_itemId">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    stackable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    playerId?: StringWithAggregatesFilter<"Inventory"> | string
    itemType?: StringWithAggregatesFilter<"Inventory"> | string
    itemId?: StringWithAggregatesFilter<"Inventory"> | string
    name?: StringWithAggregatesFilter<"Inventory"> | string
    quantity?: IntWithAggregatesFilter<"Inventory"> | number
    stackable?: BoolWithAggregatesFilter<"Inventory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: StringFilter<"Recipe"> | string
    name?: StringFilter<"Recipe"> | string
    displayName?: StringFilter<"Recipe"> | string
    description?: StringNullableFilter<"Recipe"> | string | null
    category?: StringFilter<"Recipe"> | string
    level?: IntFilter<"Recipe"> | number
    successRate?: FloatFilter<"Recipe"> | number
    materials?: StringFilter<"Recipe"> | string
    result?: StringFilter<"Recipe"> | string
    experience?: IntFilter<"Recipe"> | number
    isActive?: BoolFilter<"Recipe"> | boolean
    icon?: StringNullableFilter<"Recipe"> | string | null
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    craftingHistory?: CraftingHistoryListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    level?: SortOrder
    successRate?: SortOrder
    materials?: SortOrder
    result?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    craftingHistory?: CraftingHistoryOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    displayName?: StringFilter<"Recipe"> | string
    description?: StringNullableFilter<"Recipe"> | string | null
    category?: StringFilter<"Recipe"> | string
    level?: IntFilter<"Recipe"> | number
    successRate?: FloatFilter<"Recipe"> | number
    materials?: StringFilter<"Recipe"> | string
    result?: StringFilter<"Recipe"> | string
    experience?: IntFilter<"Recipe"> | number
    isActive?: BoolFilter<"Recipe"> | boolean
    icon?: StringNullableFilter<"Recipe"> | string | null
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    craftingHistory?: CraftingHistoryListRelationFilter
  }, "id" | "name">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    level?: SortOrder
    successRate?: SortOrder
    materials?: SortOrder
    result?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipe"> | string
    name?: StringWithAggregatesFilter<"Recipe"> | string
    displayName?: StringWithAggregatesFilter<"Recipe"> | string
    description?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    category?: StringWithAggregatesFilter<"Recipe"> | string
    level?: IntWithAggregatesFilter<"Recipe"> | number
    successRate?: FloatWithAggregatesFilter<"Recipe"> | number
    materials?: StringWithAggregatesFilter<"Recipe"> | string
    result?: StringWithAggregatesFilter<"Recipe"> | string
    experience?: IntWithAggregatesFilter<"Recipe"> | number
    isActive?: BoolWithAggregatesFilter<"Recipe"> | boolean
    icon?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
  }

  export type CraftingHistoryWhereInput = {
    AND?: CraftingHistoryWhereInput | CraftingHistoryWhereInput[]
    OR?: CraftingHistoryWhereInput[]
    NOT?: CraftingHistoryWhereInput | CraftingHistoryWhereInput[]
    id?: StringFilter<"CraftingHistory"> | string
    playerId?: StringFilter<"CraftingHistory"> | string
    recipeId?: StringFilter<"CraftingHistory"> | string
    success?: BoolFilter<"CraftingHistory"> | boolean
    quantity?: IntFilter<"CraftingHistory"> | number
    materials?: StringFilter<"CraftingHistory"> | string
    result?: StringFilter<"CraftingHistory"> | string
    createdAt?: DateTimeFilter<"CraftingHistory"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }

  export type CraftingHistoryOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    recipeId?: SortOrder
    success?: SortOrder
    quantity?: SortOrder
    materials?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
  }

  export type CraftingHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CraftingHistoryWhereInput | CraftingHistoryWhereInput[]
    OR?: CraftingHistoryWhereInput[]
    NOT?: CraftingHistoryWhereInput | CraftingHistoryWhereInput[]
    playerId?: StringFilter<"CraftingHistory"> | string
    recipeId?: StringFilter<"CraftingHistory"> | string
    success?: BoolFilter<"CraftingHistory"> | boolean
    quantity?: IntFilter<"CraftingHistory"> | number
    materials?: StringFilter<"CraftingHistory"> | string
    result?: StringFilter<"CraftingHistory"> | string
    createdAt?: DateTimeFilter<"CraftingHistory"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }, "id">

  export type CraftingHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    recipeId?: SortOrder
    success?: SortOrder
    quantity?: SortOrder
    materials?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    _count?: CraftingHistoryCountOrderByAggregateInput
    _avg?: CraftingHistoryAvgOrderByAggregateInput
    _max?: CraftingHistoryMaxOrderByAggregateInput
    _min?: CraftingHistoryMinOrderByAggregateInput
    _sum?: CraftingHistorySumOrderByAggregateInput
  }

  export type CraftingHistoryScalarWhereWithAggregatesInput = {
    AND?: CraftingHistoryScalarWhereWithAggregatesInput | CraftingHistoryScalarWhereWithAggregatesInput[]
    OR?: CraftingHistoryScalarWhereWithAggregatesInput[]
    NOT?: CraftingHistoryScalarWhereWithAggregatesInput | CraftingHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CraftingHistory"> | string
    playerId?: StringWithAggregatesFilter<"CraftingHistory"> | string
    recipeId?: StringWithAggregatesFilter<"CraftingHistory"> | string
    success?: BoolWithAggregatesFilter<"CraftingHistory"> | boolean
    quantity?: IntWithAggregatesFilter<"CraftingHistory"> | number
    materials?: StringWithAggregatesFilter<"CraftingHistory"> | string
    result?: StringWithAggregatesFilter<"CraftingHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CraftingHistory"> | Date | string
  }

  export type DaoFurnaceWhereInput = {
    AND?: DaoFurnaceWhereInput | DaoFurnaceWhereInput[]
    OR?: DaoFurnaceWhereInput[]
    NOT?: DaoFurnaceWhereInput | DaoFurnaceWhereInput[]
    id?: StringFilter<"DaoFurnace"> | string
    name?: StringFilter<"DaoFurnace"> | string
    displayName?: StringFilter<"DaoFurnace"> | string
    description?: StringNullableFilter<"DaoFurnace"> | string | null
    level?: IntFilter<"DaoFurnace"> | number
    maxLevel?: IntFilter<"DaoFurnace"> | number
    efficiency?: FloatFilter<"DaoFurnace"> | number
    isActive?: BoolFilter<"DaoFurnace"> | boolean
    icon?: StringNullableFilter<"DaoFurnace"> | string | null
    createdAt?: DateTimeFilter<"DaoFurnace"> | Date | string
    updatedAt?: DateTimeFilter<"DaoFurnace"> | Date | string
    playerFurnaces?: PlayerFurnaceListRelationFilter
  }

  export type DaoFurnaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    efficiency?: SortOrder
    isActive?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    playerFurnaces?: PlayerFurnaceOrderByRelationAggregateInput
  }

  export type DaoFurnaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DaoFurnaceWhereInput | DaoFurnaceWhereInput[]
    OR?: DaoFurnaceWhereInput[]
    NOT?: DaoFurnaceWhereInput | DaoFurnaceWhereInput[]
    displayName?: StringFilter<"DaoFurnace"> | string
    description?: StringNullableFilter<"DaoFurnace"> | string | null
    level?: IntFilter<"DaoFurnace"> | number
    maxLevel?: IntFilter<"DaoFurnace"> | number
    efficiency?: FloatFilter<"DaoFurnace"> | number
    isActive?: BoolFilter<"DaoFurnace"> | boolean
    icon?: StringNullableFilter<"DaoFurnace"> | string | null
    createdAt?: DateTimeFilter<"DaoFurnace"> | Date | string
    updatedAt?: DateTimeFilter<"DaoFurnace"> | Date | string
    playerFurnaces?: PlayerFurnaceListRelationFilter
  }, "id" | "name">

  export type DaoFurnaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    efficiency?: SortOrder
    isActive?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DaoFurnaceCountOrderByAggregateInput
    _avg?: DaoFurnaceAvgOrderByAggregateInput
    _max?: DaoFurnaceMaxOrderByAggregateInput
    _min?: DaoFurnaceMinOrderByAggregateInput
    _sum?: DaoFurnaceSumOrderByAggregateInput
  }

  export type DaoFurnaceScalarWhereWithAggregatesInput = {
    AND?: DaoFurnaceScalarWhereWithAggregatesInput | DaoFurnaceScalarWhereWithAggregatesInput[]
    OR?: DaoFurnaceScalarWhereWithAggregatesInput[]
    NOT?: DaoFurnaceScalarWhereWithAggregatesInput | DaoFurnaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DaoFurnace"> | string
    name?: StringWithAggregatesFilter<"DaoFurnace"> | string
    displayName?: StringWithAggregatesFilter<"DaoFurnace"> | string
    description?: StringNullableWithAggregatesFilter<"DaoFurnace"> | string | null
    level?: IntWithAggregatesFilter<"DaoFurnace"> | number
    maxLevel?: IntWithAggregatesFilter<"DaoFurnace"> | number
    efficiency?: FloatWithAggregatesFilter<"DaoFurnace"> | number
    isActive?: BoolWithAggregatesFilter<"DaoFurnace"> | boolean
    icon?: StringNullableWithAggregatesFilter<"DaoFurnace"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DaoFurnace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DaoFurnace"> | Date | string
  }

  export type PlayerFurnaceWhereInput = {
    AND?: PlayerFurnaceWhereInput | PlayerFurnaceWhereInput[]
    OR?: PlayerFurnaceWhereInput[]
    NOT?: PlayerFurnaceWhereInput | PlayerFurnaceWhereInput[]
    id?: StringFilter<"PlayerFurnace"> | string
    playerId?: StringFilter<"PlayerFurnace"> | string
    furnaceId?: StringFilter<"PlayerFurnace"> | string
    level?: IntFilter<"PlayerFurnace"> | number
    experience?: IntFilter<"PlayerFurnace"> | number
    isActive?: BoolFilter<"PlayerFurnace"> | boolean
    createdAt?: DateTimeFilter<"PlayerFurnace"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerFurnace"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    furnace?: XOR<DaoFurnaceRelationFilter, DaoFurnaceWhereInput>
  }

  export type PlayerFurnaceOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    furnaceId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    furnace?: DaoFurnaceOrderByWithRelationInput
  }

  export type PlayerFurnaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_furnaceId?: PlayerFurnacePlayerIdFurnaceIdCompoundUniqueInput
    AND?: PlayerFurnaceWhereInput | PlayerFurnaceWhereInput[]
    OR?: PlayerFurnaceWhereInput[]
    NOT?: PlayerFurnaceWhereInput | PlayerFurnaceWhereInput[]
    playerId?: StringFilter<"PlayerFurnace"> | string
    furnaceId?: StringFilter<"PlayerFurnace"> | string
    level?: IntFilter<"PlayerFurnace"> | number
    experience?: IntFilter<"PlayerFurnace"> | number
    isActive?: BoolFilter<"PlayerFurnace"> | boolean
    createdAt?: DateTimeFilter<"PlayerFurnace"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerFurnace"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    furnace?: XOR<DaoFurnaceRelationFilter, DaoFurnaceWhereInput>
  }, "id" | "playerId_furnaceId">

  export type PlayerFurnaceOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    furnaceId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerFurnaceCountOrderByAggregateInput
    _avg?: PlayerFurnaceAvgOrderByAggregateInput
    _max?: PlayerFurnaceMaxOrderByAggregateInput
    _min?: PlayerFurnaceMinOrderByAggregateInput
    _sum?: PlayerFurnaceSumOrderByAggregateInput
  }

  export type PlayerFurnaceScalarWhereWithAggregatesInput = {
    AND?: PlayerFurnaceScalarWhereWithAggregatesInput | PlayerFurnaceScalarWhereWithAggregatesInput[]
    OR?: PlayerFurnaceScalarWhereWithAggregatesInput[]
    NOT?: PlayerFurnaceScalarWhereWithAggregatesInput | PlayerFurnaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerFurnace"> | string
    playerId?: StringWithAggregatesFilter<"PlayerFurnace"> | string
    furnaceId?: StringWithAggregatesFilter<"PlayerFurnace"> | string
    level?: IntWithAggregatesFilter<"PlayerFurnace"> | number
    experience?: IntWithAggregatesFilter<"PlayerFurnace"> | number
    isActive?: BoolWithAggregatesFilter<"PlayerFurnace"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlayerFurnace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerFurnace"> | Date | string
  }

  export type SpiritBeastTypeWhereInput = {
    AND?: SpiritBeastTypeWhereInput | SpiritBeastTypeWhereInput[]
    OR?: SpiritBeastTypeWhereInput[]
    NOT?: SpiritBeastTypeWhereInput | SpiritBeastTypeWhereInput[]
    id?: StringFilter<"SpiritBeastType"> | string
    name?: StringFilter<"SpiritBeastType"> | string
    displayName?: StringFilter<"SpiritBeastType"> | string
    description?: StringNullableFilter<"SpiritBeastType"> | string | null
    category?: StringFilter<"SpiritBeastType"> | string
    baseStats?: StringFilter<"SpiritBeastType"> | string
    growthRate?: StringFilter<"SpiritBeastType"> | string
    skills?: StringNullableFilter<"SpiritBeastType"> | string | null
    icon?: StringNullableFilter<"SpiritBeastType"> | string | null
    color?: StringNullableFilter<"SpiritBeastType"> | string | null
    isActive?: BoolFilter<"SpiritBeastType"> | boolean
    createdAt?: DateTimeFilter<"SpiritBeastType"> | Date | string
    updatedAt?: DateTimeFilter<"SpiritBeastType"> | Date | string
    beasts?: SpiritBeastListRelationFilter
  }

  export type SpiritBeastTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    baseStats?: SortOrder
    growthRate?: SortOrder
    skills?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    beasts?: SpiritBeastOrderByRelationAggregateInput
  }

  export type SpiritBeastTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SpiritBeastTypeWhereInput | SpiritBeastTypeWhereInput[]
    OR?: SpiritBeastTypeWhereInput[]
    NOT?: SpiritBeastTypeWhereInput | SpiritBeastTypeWhereInput[]
    displayName?: StringFilter<"SpiritBeastType"> | string
    description?: StringNullableFilter<"SpiritBeastType"> | string | null
    category?: StringFilter<"SpiritBeastType"> | string
    baseStats?: StringFilter<"SpiritBeastType"> | string
    growthRate?: StringFilter<"SpiritBeastType"> | string
    skills?: StringNullableFilter<"SpiritBeastType"> | string | null
    icon?: StringNullableFilter<"SpiritBeastType"> | string | null
    color?: StringNullableFilter<"SpiritBeastType"> | string | null
    isActive?: BoolFilter<"SpiritBeastType"> | boolean
    createdAt?: DateTimeFilter<"SpiritBeastType"> | Date | string
    updatedAt?: DateTimeFilter<"SpiritBeastType"> | Date | string
    beasts?: SpiritBeastListRelationFilter
  }, "id" | "name">

  export type SpiritBeastTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    baseStats?: SortOrder
    growthRate?: SortOrder
    skills?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpiritBeastTypeCountOrderByAggregateInput
    _max?: SpiritBeastTypeMaxOrderByAggregateInput
    _min?: SpiritBeastTypeMinOrderByAggregateInput
  }

  export type SpiritBeastTypeScalarWhereWithAggregatesInput = {
    AND?: SpiritBeastTypeScalarWhereWithAggregatesInput | SpiritBeastTypeScalarWhereWithAggregatesInput[]
    OR?: SpiritBeastTypeScalarWhereWithAggregatesInput[]
    NOT?: SpiritBeastTypeScalarWhereWithAggregatesInput | SpiritBeastTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpiritBeastType"> | string
    name?: StringWithAggregatesFilter<"SpiritBeastType"> | string
    displayName?: StringWithAggregatesFilter<"SpiritBeastType"> | string
    description?: StringNullableWithAggregatesFilter<"SpiritBeastType"> | string | null
    category?: StringWithAggregatesFilter<"SpiritBeastType"> | string
    baseStats?: StringWithAggregatesFilter<"SpiritBeastType"> | string
    growthRate?: StringWithAggregatesFilter<"SpiritBeastType"> | string
    skills?: StringNullableWithAggregatesFilter<"SpiritBeastType"> | string | null
    icon?: StringNullableWithAggregatesFilter<"SpiritBeastType"> | string | null
    color?: StringNullableWithAggregatesFilter<"SpiritBeastType"> | string | null
    isActive?: BoolWithAggregatesFilter<"SpiritBeastType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SpiritBeastType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SpiritBeastType"> | Date | string
  }

  export type SpiritBeastWhereInput = {
    AND?: SpiritBeastWhereInput | SpiritBeastWhereInput[]
    OR?: SpiritBeastWhereInput[]
    NOT?: SpiritBeastWhereInput | SpiritBeastWhereInput[]
    id?: StringFilter<"SpiritBeast"> | string
    playerId?: StringFilter<"SpiritBeast"> | string
    typeId?: StringFilter<"SpiritBeast"> | string
    name?: StringFilter<"SpiritBeast"> | string
    level?: IntFilter<"SpiritBeast"> | number
    experience?: IntFilter<"SpiritBeast"> | number
    stats?: StringFilter<"SpiritBeast"> | string
    skills?: StringNullableFilter<"SpiritBeast"> | string | null
    happiness?: IntFilter<"SpiritBeast"> | number
    hunger?: IntFilter<"SpiritBeast"> | number
    health?: IntFilter<"SpiritBeast"> | number
    isActive?: BoolFilter<"SpiritBeast"> | boolean
    isFighting?: BoolFilter<"SpiritBeast"> | boolean
    capturedAt?: DateTimeFilter<"SpiritBeast"> | Date | string
    lastFedAt?: DateTimeNullableFilter<"SpiritBeast"> | Date | string | null
    lastPlayedAt?: DateTimeNullableFilter<"SpiritBeast"> | Date | string | null
    createdAt?: DateTimeFilter<"SpiritBeast"> | Date | string
    updatedAt?: DateTimeFilter<"SpiritBeast"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    type?: XOR<SpiritBeastTypeRelationFilter, SpiritBeastTypeWhereInput>
    feedingHistory?: BeastFeedingHistoryListRelationFilter
    huntingHistory?: HuntingHistoryListRelationFilter
  }

  export type SpiritBeastOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    typeId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    stats?: SortOrder
    skills?: SortOrderInput | SortOrder
    happiness?: SortOrder
    hunger?: SortOrder
    health?: SortOrder
    isActive?: SortOrder
    isFighting?: SortOrder
    capturedAt?: SortOrder
    lastFedAt?: SortOrderInput | SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    type?: SpiritBeastTypeOrderByWithRelationInput
    feedingHistory?: BeastFeedingHistoryOrderByRelationAggregateInput
    huntingHistory?: HuntingHistoryOrderByRelationAggregateInput
  }

  export type SpiritBeastWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpiritBeastWhereInput | SpiritBeastWhereInput[]
    OR?: SpiritBeastWhereInput[]
    NOT?: SpiritBeastWhereInput | SpiritBeastWhereInput[]
    playerId?: StringFilter<"SpiritBeast"> | string
    typeId?: StringFilter<"SpiritBeast"> | string
    name?: StringFilter<"SpiritBeast"> | string
    level?: IntFilter<"SpiritBeast"> | number
    experience?: IntFilter<"SpiritBeast"> | number
    stats?: StringFilter<"SpiritBeast"> | string
    skills?: StringNullableFilter<"SpiritBeast"> | string | null
    happiness?: IntFilter<"SpiritBeast"> | number
    hunger?: IntFilter<"SpiritBeast"> | number
    health?: IntFilter<"SpiritBeast"> | number
    isActive?: BoolFilter<"SpiritBeast"> | boolean
    isFighting?: BoolFilter<"SpiritBeast"> | boolean
    capturedAt?: DateTimeFilter<"SpiritBeast"> | Date | string
    lastFedAt?: DateTimeNullableFilter<"SpiritBeast"> | Date | string | null
    lastPlayedAt?: DateTimeNullableFilter<"SpiritBeast"> | Date | string | null
    createdAt?: DateTimeFilter<"SpiritBeast"> | Date | string
    updatedAt?: DateTimeFilter<"SpiritBeast"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    type?: XOR<SpiritBeastTypeRelationFilter, SpiritBeastTypeWhereInput>
    feedingHistory?: BeastFeedingHistoryListRelationFilter
    huntingHistory?: HuntingHistoryListRelationFilter
  }, "id">

  export type SpiritBeastOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    typeId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    stats?: SortOrder
    skills?: SortOrderInput | SortOrder
    happiness?: SortOrder
    hunger?: SortOrder
    health?: SortOrder
    isActive?: SortOrder
    isFighting?: SortOrder
    capturedAt?: SortOrder
    lastFedAt?: SortOrderInput | SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpiritBeastCountOrderByAggregateInput
    _avg?: SpiritBeastAvgOrderByAggregateInput
    _max?: SpiritBeastMaxOrderByAggregateInput
    _min?: SpiritBeastMinOrderByAggregateInput
    _sum?: SpiritBeastSumOrderByAggregateInput
  }

  export type SpiritBeastScalarWhereWithAggregatesInput = {
    AND?: SpiritBeastScalarWhereWithAggregatesInput | SpiritBeastScalarWhereWithAggregatesInput[]
    OR?: SpiritBeastScalarWhereWithAggregatesInput[]
    NOT?: SpiritBeastScalarWhereWithAggregatesInput | SpiritBeastScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpiritBeast"> | string
    playerId?: StringWithAggregatesFilter<"SpiritBeast"> | string
    typeId?: StringWithAggregatesFilter<"SpiritBeast"> | string
    name?: StringWithAggregatesFilter<"SpiritBeast"> | string
    level?: IntWithAggregatesFilter<"SpiritBeast"> | number
    experience?: IntWithAggregatesFilter<"SpiritBeast"> | number
    stats?: StringWithAggregatesFilter<"SpiritBeast"> | string
    skills?: StringNullableWithAggregatesFilter<"SpiritBeast"> | string | null
    happiness?: IntWithAggregatesFilter<"SpiritBeast"> | number
    hunger?: IntWithAggregatesFilter<"SpiritBeast"> | number
    health?: IntWithAggregatesFilter<"SpiritBeast"> | number
    isActive?: BoolWithAggregatesFilter<"SpiritBeast"> | boolean
    isFighting?: BoolWithAggregatesFilter<"SpiritBeast"> | boolean
    capturedAt?: DateTimeWithAggregatesFilter<"SpiritBeast"> | Date | string
    lastFedAt?: DateTimeNullableWithAggregatesFilter<"SpiritBeast"> | Date | string | null
    lastPlayedAt?: DateTimeNullableWithAggregatesFilter<"SpiritBeast"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SpiritBeast"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SpiritBeast"> | Date | string
  }

  export type BeastFoodWhereInput = {
    AND?: BeastFoodWhereInput | BeastFoodWhereInput[]
    OR?: BeastFoodWhereInput[]
    NOT?: BeastFoodWhereInput | BeastFoodWhereInput[]
    id?: StringFilter<"BeastFood"> | string
    name?: StringFilter<"BeastFood"> | string
    displayName?: StringFilter<"BeastFood"> | string
    description?: StringNullableFilter<"BeastFood"> | string | null
    category?: StringFilter<"BeastFood"> | string
    effects?: StringFilter<"BeastFood"> | string
    price?: IntFilter<"BeastFood"> | number
    currency?: StringFilter<"BeastFood"> | string
    icon?: StringNullableFilter<"BeastFood"> | string | null
    isActive?: BoolFilter<"BeastFood"> | boolean
    createdAt?: DateTimeFilter<"BeastFood"> | Date | string
    updatedAt?: DateTimeFilter<"BeastFood"> | Date | string
    feedingHistory?: BeastFeedingHistoryListRelationFilter
  }

  export type BeastFoodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    effects?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feedingHistory?: BeastFeedingHistoryOrderByRelationAggregateInput
  }

  export type BeastFoodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BeastFoodWhereInput | BeastFoodWhereInput[]
    OR?: BeastFoodWhereInput[]
    NOT?: BeastFoodWhereInput | BeastFoodWhereInput[]
    displayName?: StringFilter<"BeastFood"> | string
    description?: StringNullableFilter<"BeastFood"> | string | null
    category?: StringFilter<"BeastFood"> | string
    effects?: StringFilter<"BeastFood"> | string
    price?: IntFilter<"BeastFood"> | number
    currency?: StringFilter<"BeastFood"> | string
    icon?: StringNullableFilter<"BeastFood"> | string | null
    isActive?: BoolFilter<"BeastFood"> | boolean
    createdAt?: DateTimeFilter<"BeastFood"> | Date | string
    updatedAt?: DateTimeFilter<"BeastFood"> | Date | string
    feedingHistory?: BeastFeedingHistoryListRelationFilter
  }, "id" | "name">

  export type BeastFoodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    effects?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BeastFoodCountOrderByAggregateInput
    _avg?: BeastFoodAvgOrderByAggregateInput
    _max?: BeastFoodMaxOrderByAggregateInput
    _min?: BeastFoodMinOrderByAggregateInput
    _sum?: BeastFoodSumOrderByAggregateInput
  }

  export type BeastFoodScalarWhereWithAggregatesInput = {
    AND?: BeastFoodScalarWhereWithAggregatesInput | BeastFoodScalarWhereWithAggregatesInput[]
    OR?: BeastFoodScalarWhereWithAggregatesInput[]
    NOT?: BeastFoodScalarWhereWithAggregatesInput | BeastFoodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BeastFood"> | string
    name?: StringWithAggregatesFilter<"BeastFood"> | string
    displayName?: StringWithAggregatesFilter<"BeastFood"> | string
    description?: StringNullableWithAggregatesFilter<"BeastFood"> | string | null
    category?: StringWithAggregatesFilter<"BeastFood"> | string
    effects?: StringWithAggregatesFilter<"BeastFood"> | string
    price?: IntWithAggregatesFilter<"BeastFood"> | number
    currency?: StringWithAggregatesFilter<"BeastFood"> | string
    icon?: StringNullableWithAggregatesFilter<"BeastFood"> | string | null
    isActive?: BoolWithAggregatesFilter<"BeastFood"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BeastFood"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BeastFood"> | Date | string
  }

  export type BeastFeedingHistoryWhereInput = {
    AND?: BeastFeedingHistoryWhereInput | BeastFeedingHistoryWhereInput[]
    OR?: BeastFeedingHistoryWhereInput[]
    NOT?: BeastFeedingHistoryWhereInput | BeastFeedingHistoryWhereInput[]
    id?: StringFilter<"BeastFeedingHistory"> | string
    playerId?: StringFilter<"BeastFeedingHistory"> | string
    beastId?: StringFilter<"BeastFeedingHistory"> | string
    foodId?: StringFilter<"BeastFeedingHistory"> | string
    quantity?: IntFilter<"BeastFeedingHistory"> | number
    effects?: StringFilter<"BeastFeedingHistory"> | string
    createdAt?: DateTimeFilter<"BeastFeedingHistory"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    beast?: XOR<SpiritBeastRelationFilter, SpiritBeastWhereInput>
    food?: XOR<BeastFoodRelationFilter, BeastFoodWhereInput>
  }

  export type BeastFeedingHistoryOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    beastId?: SortOrder
    foodId?: SortOrder
    quantity?: SortOrder
    effects?: SortOrder
    createdAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    beast?: SpiritBeastOrderByWithRelationInput
    food?: BeastFoodOrderByWithRelationInput
  }

  export type BeastFeedingHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BeastFeedingHistoryWhereInput | BeastFeedingHistoryWhereInput[]
    OR?: BeastFeedingHistoryWhereInput[]
    NOT?: BeastFeedingHistoryWhereInput | BeastFeedingHistoryWhereInput[]
    playerId?: StringFilter<"BeastFeedingHistory"> | string
    beastId?: StringFilter<"BeastFeedingHistory"> | string
    foodId?: StringFilter<"BeastFeedingHistory"> | string
    quantity?: IntFilter<"BeastFeedingHistory"> | number
    effects?: StringFilter<"BeastFeedingHistory"> | string
    createdAt?: DateTimeFilter<"BeastFeedingHistory"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    beast?: XOR<SpiritBeastRelationFilter, SpiritBeastWhereInput>
    food?: XOR<BeastFoodRelationFilter, BeastFoodWhereInput>
  }, "id">

  export type BeastFeedingHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    beastId?: SortOrder
    foodId?: SortOrder
    quantity?: SortOrder
    effects?: SortOrder
    createdAt?: SortOrder
    _count?: BeastFeedingHistoryCountOrderByAggregateInput
    _avg?: BeastFeedingHistoryAvgOrderByAggregateInput
    _max?: BeastFeedingHistoryMaxOrderByAggregateInput
    _min?: BeastFeedingHistoryMinOrderByAggregateInput
    _sum?: BeastFeedingHistorySumOrderByAggregateInput
  }

  export type BeastFeedingHistoryScalarWhereWithAggregatesInput = {
    AND?: BeastFeedingHistoryScalarWhereWithAggregatesInput | BeastFeedingHistoryScalarWhereWithAggregatesInput[]
    OR?: BeastFeedingHistoryScalarWhereWithAggregatesInput[]
    NOT?: BeastFeedingHistoryScalarWhereWithAggregatesInput | BeastFeedingHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BeastFeedingHistory"> | string
    playerId?: StringWithAggregatesFilter<"BeastFeedingHistory"> | string
    beastId?: StringWithAggregatesFilter<"BeastFeedingHistory"> | string
    foodId?: StringWithAggregatesFilter<"BeastFeedingHistory"> | string
    quantity?: IntWithAggregatesFilter<"BeastFeedingHistory"> | number
    effects?: StringWithAggregatesFilter<"BeastFeedingHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BeastFeedingHistory"> | Date | string
  }

  export type HuntingGroundWhereInput = {
    AND?: HuntingGroundWhereInput | HuntingGroundWhereInput[]
    OR?: HuntingGroundWhereInput[]
    NOT?: HuntingGroundWhereInput | HuntingGroundWhereInput[]
    id?: StringFilter<"HuntingGround"> | string
    name?: StringFilter<"HuntingGround"> | string
    displayName?: StringFilter<"HuntingGround"> | string
    description?: StringNullableFilter<"HuntingGround"> | string | null
    level?: IntFilter<"HuntingGround"> | number
    maxLevel?: IntFilter<"HuntingGround"> | number
    difficulty?: StringFilter<"HuntingGround"> | string
    beastTypes?: StringFilter<"HuntingGround"> | string
    dropRates?: StringFilter<"HuntingGround"> | string
    isActive?: BoolFilter<"HuntingGround"> | boolean
    icon?: StringNullableFilter<"HuntingGround"> | string | null
    createdAt?: DateTimeFilter<"HuntingGround"> | Date | string
    updatedAt?: DateTimeFilter<"HuntingGround"> | Date | string
    huntingHistory?: HuntingHistoryListRelationFilter
  }

  export type HuntingGroundOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    difficulty?: SortOrder
    beastTypes?: SortOrder
    dropRates?: SortOrder
    isActive?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    huntingHistory?: HuntingHistoryOrderByRelationAggregateInput
  }

  export type HuntingGroundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: HuntingGroundWhereInput | HuntingGroundWhereInput[]
    OR?: HuntingGroundWhereInput[]
    NOT?: HuntingGroundWhereInput | HuntingGroundWhereInput[]
    displayName?: StringFilter<"HuntingGround"> | string
    description?: StringNullableFilter<"HuntingGround"> | string | null
    level?: IntFilter<"HuntingGround"> | number
    maxLevel?: IntFilter<"HuntingGround"> | number
    difficulty?: StringFilter<"HuntingGround"> | string
    beastTypes?: StringFilter<"HuntingGround"> | string
    dropRates?: StringFilter<"HuntingGround"> | string
    isActive?: BoolFilter<"HuntingGround"> | boolean
    icon?: StringNullableFilter<"HuntingGround"> | string | null
    createdAt?: DateTimeFilter<"HuntingGround"> | Date | string
    updatedAt?: DateTimeFilter<"HuntingGround"> | Date | string
    huntingHistory?: HuntingHistoryListRelationFilter
  }, "id" | "name">

  export type HuntingGroundOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    difficulty?: SortOrder
    beastTypes?: SortOrder
    dropRates?: SortOrder
    isActive?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HuntingGroundCountOrderByAggregateInput
    _avg?: HuntingGroundAvgOrderByAggregateInput
    _max?: HuntingGroundMaxOrderByAggregateInput
    _min?: HuntingGroundMinOrderByAggregateInput
    _sum?: HuntingGroundSumOrderByAggregateInput
  }

  export type HuntingGroundScalarWhereWithAggregatesInput = {
    AND?: HuntingGroundScalarWhereWithAggregatesInput | HuntingGroundScalarWhereWithAggregatesInput[]
    OR?: HuntingGroundScalarWhereWithAggregatesInput[]
    NOT?: HuntingGroundScalarWhereWithAggregatesInput | HuntingGroundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HuntingGround"> | string
    name?: StringWithAggregatesFilter<"HuntingGround"> | string
    displayName?: StringWithAggregatesFilter<"HuntingGround"> | string
    description?: StringNullableWithAggregatesFilter<"HuntingGround"> | string | null
    level?: IntWithAggregatesFilter<"HuntingGround"> | number
    maxLevel?: IntWithAggregatesFilter<"HuntingGround"> | number
    difficulty?: StringWithAggregatesFilter<"HuntingGround"> | string
    beastTypes?: StringWithAggregatesFilter<"HuntingGround"> | string
    dropRates?: StringWithAggregatesFilter<"HuntingGround"> | string
    isActive?: BoolWithAggregatesFilter<"HuntingGround"> | boolean
    icon?: StringNullableWithAggregatesFilter<"HuntingGround"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HuntingGround"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HuntingGround"> | Date | string
  }

  export type HuntingHistoryWhereInput = {
    AND?: HuntingHistoryWhereInput | HuntingHistoryWhereInput[]
    OR?: HuntingHistoryWhereInput[]
    NOT?: HuntingHistoryWhereInput | HuntingHistoryWhereInput[]
    id?: StringFilter<"HuntingHistory"> | string
    playerId?: StringFilter<"HuntingHistory"> | string
    groundId?: StringFilter<"HuntingHistory"> | string
    beastId?: StringNullableFilter<"HuntingHistory"> | string | null
    success?: BoolFilter<"HuntingHistory"> | boolean
    duration?: IntFilter<"HuntingHistory"> | number
    rewards?: StringNullableFilter<"HuntingHistory"> | string | null
    createdAt?: DateTimeFilter<"HuntingHistory"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    ground?: XOR<HuntingGroundRelationFilter, HuntingGroundWhereInput>
    beast?: XOR<SpiritBeastNullableRelationFilter, SpiritBeastWhereInput> | null
  }

  export type HuntingHistoryOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    groundId?: SortOrder
    beastId?: SortOrderInput | SortOrder
    success?: SortOrder
    duration?: SortOrder
    rewards?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    ground?: HuntingGroundOrderByWithRelationInput
    beast?: SpiritBeastOrderByWithRelationInput
  }

  export type HuntingHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HuntingHistoryWhereInput | HuntingHistoryWhereInput[]
    OR?: HuntingHistoryWhereInput[]
    NOT?: HuntingHistoryWhereInput | HuntingHistoryWhereInput[]
    playerId?: StringFilter<"HuntingHistory"> | string
    groundId?: StringFilter<"HuntingHistory"> | string
    beastId?: StringNullableFilter<"HuntingHistory"> | string | null
    success?: BoolFilter<"HuntingHistory"> | boolean
    duration?: IntFilter<"HuntingHistory"> | number
    rewards?: StringNullableFilter<"HuntingHistory"> | string | null
    createdAt?: DateTimeFilter<"HuntingHistory"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    ground?: XOR<HuntingGroundRelationFilter, HuntingGroundWhereInput>
    beast?: XOR<SpiritBeastNullableRelationFilter, SpiritBeastWhereInput> | null
  }, "id">

  export type HuntingHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    groundId?: SortOrder
    beastId?: SortOrderInput | SortOrder
    success?: SortOrder
    duration?: SortOrder
    rewards?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: HuntingHistoryCountOrderByAggregateInput
    _avg?: HuntingHistoryAvgOrderByAggregateInput
    _max?: HuntingHistoryMaxOrderByAggregateInput
    _min?: HuntingHistoryMinOrderByAggregateInput
    _sum?: HuntingHistorySumOrderByAggregateInput
  }

  export type HuntingHistoryScalarWhereWithAggregatesInput = {
    AND?: HuntingHistoryScalarWhereWithAggregatesInput | HuntingHistoryScalarWhereWithAggregatesInput[]
    OR?: HuntingHistoryScalarWhereWithAggregatesInput[]
    NOT?: HuntingHistoryScalarWhereWithAggregatesInput | HuntingHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HuntingHistory"> | string
    playerId?: StringWithAggregatesFilter<"HuntingHistory"> | string
    groundId?: StringWithAggregatesFilter<"HuntingHistory"> | string
    beastId?: StringNullableWithAggregatesFilter<"HuntingHistory"> | string | null
    success?: BoolWithAggregatesFilter<"HuntingHistory"> | boolean
    duration?: IntWithAggregatesFilter<"HuntingHistory"> | number
    rewards?: StringNullableWithAggregatesFilter<"HuntingHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HuntingHistory"> | Date | string
  }

  export type PlayerCultivationWhereInput = {
    AND?: PlayerCultivationWhereInput | PlayerCultivationWhereInput[]
    OR?: PlayerCultivationWhereInput[]
    NOT?: PlayerCultivationWhereInput | PlayerCultivationWhereInput[]
    id?: StringFilter<"PlayerCultivation"> | string
    playerId?: StringFilter<"PlayerCultivation"> | string
    currentRealm?: IntFilter<"PlayerCultivation"> | number
    currentFloor?: IntFilter<"PlayerCultivation"> | number
    currentExp?: IntFilter<"PlayerCultivation"> | number
    totalExpGained?: IntFilter<"PlayerCultivation"> | number
    currentQuality?: StringFilter<"PlayerCultivation"> | string
    eternalTitles?: StringFilter<"PlayerCultivation"> | string
    hasAscended?: BoolFilter<"PlayerCultivation"> | boolean
    createdAt?: DateTimeFilter<"PlayerCultivation"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerCultivation"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type PlayerCultivationOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    currentRealm?: SortOrder
    currentFloor?: SortOrder
    currentExp?: SortOrder
    totalExpGained?: SortOrder
    currentQuality?: SortOrder
    eternalTitles?: SortOrder
    hasAscended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type PlayerCultivationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: PlayerCultivationWhereInput | PlayerCultivationWhereInput[]
    OR?: PlayerCultivationWhereInput[]
    NOT?: PlayerCultivationWhereInput | PlayerCultivationWhereInput[]
    currentRealm?: IntFilter<"PlayerCultivation"> | number
    currentFloor?: IntFilter<"PlayerCultivation"> | number
    currentExp?: IntFilter<"PlayerCultivation"> | number
    totalExpGained?: IntFilter<"PlayerCultivation"> | number
    currentQuality?: StringFilter<"PlayerCultivation"> | string
    eternalTitles?: StringFilter<"PlayerCultivation"> | string
    hasAscended?: BoolFilter<"PlayerCultivation"> | boolean
    createdAt?: DateTimeFilter<"PlayerCultivation"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerCultivation"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }, "id" | "playerId">

  export type PlayerCultivationOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    currentRealm?: SortOrder
    currentFloor?: SortOrder
    currentExp?: SortOrder
    totalExpGained?: SortOrder
    currentQuality?: SortOrder
    eternalTitles?: SortOrder
    hasAscended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCultivationCountOrderByAggregateInput
    _avg?: PlayerCultivationAvgOrderByAggregateInput
    _max?: PlayerCultivationMaxOrderByAggregateInput
    _min?: PlayerCultivationMinOrderByAggregateInput
    _sum?: PlayerCultivationSumOrderByAggregateInput
  }

  export type PlayerCultivationScalarWhereWithAggregatesInput = {
    AND?: PlayerCultivationScalarWhereWithAggregatesInput | PlayerCultivationScalarWhereWithAggregatesInput[]
    OR?: PlayerCultivationScalarWhereWithAggregatesInput[]
    NOT?: PlayerCultivationScalarWhereWithAggregatesInput | PlayerCultivationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerCultivation"> | string
    playerId?: StringWithAggregatesFilter<"PlayerCultivation"> | string
    currentRealm?: IntWithAggregatesFilter<"PlayerCultivation"> | number
    currentFloor?: IntWithAggregatesFilter<"PlayerCultivation"> | number
    currentExp?: IntWithAggregatesFilter<"PlayerCultivation"> | number
    totalExpGained?: IntWithAggregatesFilter<"PlayerCultivation"> | number
    currentQuality?: StringWithAggregatesFilter<"PlayerCultivation"> | string
    eternalTitles?: StringWithAggregatesFilter<"PlayerCultivation"> | string
    hasAscended?: BoolWithAggregatesFilter<"PlayerCultivation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlayerCultivation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerCultivation"> | Date | string
  }

  export type CultivationLogWhereInput = {
    AND?: CultivationLogWhereInput | CultivationLogWhereInput[]
    OR?: CultivationLogWhereInput[]
    NOT?: CultivationLogWhereInput | CultivationLogWhereInput[]
    id?: StringFilter<"CultivationLog"> | string
    playerId?: StringFilter<"CultivationLog"> | string
    type?: StringFilter<"CultivationLog"> | string
    description?: StringFilter<"CultivationLog"> | string
    expGained?: IntFilter<"CultivationLog"> | number
    levelGained?: IntFilter<"CultivationLog"> | number
    timestamp?: DateTimeFilter<"CultivationLog"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type CultivationLogOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    expGained?: SortOrder
    levelGained?: SortOrder
    timestamp?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type CultivationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CultivationLogWhereInput | CultivationLogWhereInput[]
    OR?: CultivationLogWhereInput[]
    NOT?: CultivationLogWhereInput | CultivationLogWhereInput[]
    playerId?: StringFilter<"CultivationLog"> | string
    type?: StringFilter<"CultivationLog"> | string
    description?: StringFilter<"CultivationLog"> | string
    expGained?: IntFilter<"CultivationLog"> | number
    levelGained?: IntFilter<"CultivationLog"> | number
    timestamp?: DateTimeFilter<"CultivationLog"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }, "id">

  export type CultivationLogOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    expGained?: SortOrder
    levelGained?: SortOrder
    timestamp?: SortOrder
    _count?: CultivationLogCountOrderByAggregateInput
    _avg?: CultivationLogAvgOrderByAggregateInput
    _max?: CultivationLogMaxOrderByAggregateInput
    _min?: CultivationLogMinOrderByAggregateInput
    _sum?: CultivationLogSumOrderByAggregateInput
  }

  export type CultivationLogScalarWhereWithAggregatesInput = {
    AND?: CultivationLogScalarWhereWithAggregatesInput | CultivationLogScalarWhereWithAggregatesInput[]
    OR?: CultivationLogScalarWhereWithAggregatesInput[]
    NOT?: CultivationLogScalarWhereWithAggregatesInput | CultivationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CultivationLog"> | string
    playerId?: StringWithAggregatesFilter<"CultivationLog"> | string
    type?: StringWithAggregatesFilter<"CultivationLog"> | string
    description?: StringWithAggregatesFilter<"CultivationLog"> | string
    expGained?: IntWithAggregatesFilter<"CultivationLog"> | number
    levelGained?: IntWithAggregatesFilter<"CultivationLog"> | number
    timestamp?: DateTimeWithAggregatesFilter<"CultivationLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCreateInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerResources?: PlayerResourceCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerResources?: PlayerResourceUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerResources?: PlayerResourceUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerResources?: PlayerResourceUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerResourceCreateInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutResourcesInput
    resource: ResourceCreateNestedOneWithoutPlayerResourcesInput
  }

  export type PlayerResourceUncheckedCreateInput = {
    id?: string
    playerId: string
    resourceId: string
    amount?: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutResourcesNestedInput
    resource?: ResourceUpdateOneRequiredWithoutPlayerResourcesNestedInput
  }

  export type PlayerResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerResourceCreateManyInput = {
    id?: string
    playerId: string
    resourceId: string
    amount?: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanionCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    rarity?: string
    basePower?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    playerCompanions?: PlayerCompanionCreateNestedManyWithoutCompanionInput
  }

  export type CompanionUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    rarity?: string
    basePower?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    playerCompanions?: PlayerCompanionUncheckedCreateNestedManyWithoutCompanionInput
  }

  export type CompanionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    basePower?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerCompanions?: PlayerCompanionUpdateManyWithoutCompanionNestedInput
  }

  export type CompanionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    basePower?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerCompanions?: PlayerCompanionUncheckedUpdateManyWithoutCompanionNestedInput
  }

  export type CompanionCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    rarity?: string
    basePower?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    basePower?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    basePower?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCompanionCreateInput = {
    id?: string
    level?: number
    power?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutCompanionsInput
    companion: CompanionCreateNestedOneWithoutPlayerCompanionsInput
  }

  export type PlayerCompanionUncheckedCreateInput = {
    id?: string
    playerId: string
    companionId: string
    level?: number
    power?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCompanionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutCompanionsNestedInput
    companion?: CompanionUpdateOneRequiredWithoutPlayerCompanionsNestedInput
  }

  export type PlayerCompanionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    companionId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCompanionCreateManyInput = {
    id?: string
    playerId: string
    companionId: string
    level?: number
    power?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCompanionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCompanionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    companionId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    category?: string
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    playerAchievements?: PlayerAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    category?: string
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    playerAchievements?: PlayerAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerAchievements?: PlayerAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerAchievements?: PlayerAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    category?: string
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerAchievementCreateInput = {
    id?: string
    unlockedAt?: Date | string
    player: PlayerCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutPlayerAchievementsInput
  }

  export type PlayerAchievementUncheckedCreateInput = {
    id?: string
    playerId: string
    achievementId: string
    unlockedAt?: Date | string
  }

  export type PlayerAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutPlayerAchievementsNestedInput
  }

  export type PlayerAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerAchievementCreateManyInput = {
    id?: string
    playerId: string
    achievementId: string
    unlockedAt?: Date | string
  }

  export type PlayerAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    difficulty?: string
    rewards?: string | null
    requirements?: string | null
    isActive?: boolean
    isRepeatable?: boolean
    repeatInterval?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerQuests?: PlayerQuestCreateNestedManyWithoutQuestInput
  }

  export type QuestUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    difficulty?: string
    rewards?: string | null
    requirements?: string | null
    isActive?: boolean
    isRepeatable?: boolean
    repeatInterval?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerQuests?: PlayerQuestUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRepeatable?: BoolFieldUpdateOperationsInput | boolean
    repeatInterval?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerQuests?: PlayerQuestUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRepeatable?: BoolFieldUpdateOperationsInput | boolean
    repeatInterval?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerQuests?: PlayerQuestUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type QuestCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    difficulty?: string
    rewards?: string | null
    requirements?: string | null
    isActive?: boolean
    isRepeatable?: boolean
    repeatInterval?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRepeatable?: BoolFieldUpdateOperationsInput | boolean
    repeatInterval?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRepeatable?: BoolFieldUpdateOperationsInput | boolean
    repeatInterval?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerQuestCreateInput = {
    id?: string
    status?: string
    progress?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lastCompletedAt?: Date | string | null
    cooldownUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutQuestsInput
    quest: QuestCreateNestedOneWithoutPlayerQuestsInput
  }

  export type PlayerQuestUncheckedCreateInput = {
    id?: string
    playerId: string
    questId: string
    status?: string
    progress?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lastCompletedAt?: Date | string | null
    cooldownUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerQuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooldownUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutQuestsNestedInput
    quest?: QuestUpdateOneRequiredWithoutPlayerQuestsNestedInput
  }

  export type PlayerQuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    questId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooldownUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerQuestCreateManyInput = {
    id?: string
    playerId: string
    questId: string
    status?: string
    progress?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lastCompletedAt?: Date | string | null
    cooldownUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerQuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooldownUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerQuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    questId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooldownUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatsCreateInput = {
    id?: string
    hp?: number
    mp?: number
    attack?: number
    defense?: number
    speed?: number
    luck?: number
    wisdom?: number
    strength?: number
    agility?: number
    vitality?: number
    spirit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutStatsInput
  }

  export type PlayerStatsUncheckedCreateInput = {
    id?: string
    playerId: string
    hp?: number
    mp?: number
    attack?: number
    defense?: number
    speed?: number
    luck?: number
    wisdom?: number
    strength?: number
    agility?: number
    vitality?: number
    spirit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hp?: IntFieldUpdateOperationsInput | number
    mp?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    spirit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutStatsNestedInput
  }

  export type PlayerStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    hp?: IntFieldUpdateOperationsInput | number
    mp?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    spirit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatsCreateManyInput = {
    id?: string
    playerId: string
    hp?: number
    mp?: number
    attack?: number
    defense?: number
    speed?: number
    luck?: number
    wisdom?: number
    strength?: number
    agility?: number
    vitality?: number
    spirit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hp?: IntFieldUpdateOperationsInput | number
    mp?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    spirit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    hp?: IntFieldUpdateOperationsInput | number
    mp?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    spirit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentTypeCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    slot: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipments?: EquipmentCreateNestedManyWithoutTypeInput
  }

  export type EquipmentTypeUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    slot: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipments?: EquipmentUncheckedCreateNestedManyWithoutTypeInput
  }

  export type EquipmentTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipments?: EquipmentUpdateManyWithoutTypeNestedInput
  }

  export type EquipmentTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipments?: EquipmentUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type EquipmentTypeCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    slot: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    rarity?: string
    level?: number
    stats?: string | null
    requirements?: string | null
    price?: number
    isTradeable?: boolean
    isSellable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: EquipmentTypeCreateNestedOneWithoutEquipmentsInput
    playerEquipments?: PlayerEquipmentCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    typeId: string
    rarity?: string
    level?: number
    stats?: string | null
    requirements?: string | null
    price?: number
    isTradeable?: boolean
    isSellable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerEquipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isTradeable?: BoolFieldUpdateOperationsInput | boolean
    isSellable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EquipmentTypeUpdateOneRequiredWithoutEquipmentsNestedInput
    playerEquipments?: PlayerEquipmentUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isTradeable?: BoolFieldUpdateOperationsInput | boolean
    isSellable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerEquipments?: PlayerEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    typeId: string
    rarity?: string
    level?: number
    stats?: string | null
    requirements?: string | null
    price?: number
    isTradeable?: boolean
    isSellable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isTradeable?: BoolFieldUpdateOperationsInput | boolean
    isSellable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isTradeable?: BoolFieldUpdateOperationsInput | boolean
    isSellable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentCreateInput = {
    id?: string
    isEquipped?: boolean
    durability?: number
    enhancement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutEquipmentsInput
    equipment: EquipmentCreateNestedOneWithoutPlayerEquipmentsInput
  }

  export type PlayerEquipmentUncheckedCreateInput = {
    id?: string
    playerId: string
    equipmentId: string
    isEquipped?: boolean
    durability?: number
    enhancement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerEquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEquipped?: BoolFieldUpdateOperationsInput | boolean
    durability?: IntFieldUpdateOperationsInput | number
    enhancement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutEquipmentsNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutPlayerEquipmentsNestedInput
  }

  export type PlayerEquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    isEquipped?: BoolFieldUpdateOperationsInput | boolean
    durability?: IntFieldUpdateOperationsInput | number
    enhancement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentCreateManyInput = {
    id?: string
    playerId: string
    equipmentId: string
    isEquipped?: boolean
    durability?: number
    enhancement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerEquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEquipped?: BoolFieldUpdateOperationsInput | boolean
    durability?: IntFieldUpdateOperationsInput | number
    enhancement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    isEquipped?: BoolFieldUpdateOperationsInput | boolean
    durability?: IntFieldUpdateOperationsInput | number
    enhancement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    type?: string
    level?: number
    maxLevel?: number
    cooldown?: number
    mpCost?: number
    damage?: number
    effects?: string | null
    requirements?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerSkills?: PlayerSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    type?: string
    level?: number
    maxLevel?: number
    cooldown?: number
    mpCost?: number
    damage?: number
    effects?: string | null
    requirements?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerSkills?: PlayerSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    cooldown?: IntFieldUpdateOperationsInput | number
    mpCost?: IntFieldUpdateOperationsInput | number
    damage?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerSkills?: PlayerSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    cooldown?: IntFieldUpdateOperationsInput | number
    mpCost?: IntFieldUpdateOperationsInput | number
    damage?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerSkills?: PlayerSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    type?: string
    level?: number
    maxLevel?: number
    cooldown?: number
    mpCost?: number
    damage?: number
    effects?: string | null
    requirements?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    cooldown?: IntFieldUpdateOperationsInput | number
    mpCost?: IntFieldUpdateOperationsInput | number
    damage?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    cooldown?: IntFieldUpdateOperationsInput | number
    mpCost?: IntFieldUpdateOperationsInput | number
    damage?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillCreateInput = {
    id?: string
    level?: number
    isLearned?: boolean
    learnedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutPlayerSkillsInput
  }

  export type PlayerSkillUncheckedCreateInput = {
    id?: string
    playerId: string
    skillId: string
    level?: number
    isLearned?: boolean
    learnedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isLearned?: BoolFieldUpdateOperationsInput | boolean
    learnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutPlayerSkillsNestedInput
  }

  export type PlayerSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isLearned?: BoolFieldUpdateOperationsInput | boolean
    learnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillCreateManyInput = {
    id?: string
    playerId: string
    skillId: string
    level?: number
    isLearned?: boolean
    learnedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isLearned?: BoolFieldUpdateOperationsInput | boolean
    learnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isLearned?: BoolFieldUpdateOperationsInput | boolean
    learnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TalentTypeCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    talents?: TalentCreateNestedManyWithoutTypeInput
  }

  export type TalentTypeUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    talents?: TalentUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TalentTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    talents?: TalentUpdateManyWithoutTypeNestedInput
  }

  export type TalentTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    talents?: TalentUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type TalentTypeCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TalentTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TalentTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TalentCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    rarity?: string
    level?: number
    maxLevel?: number
    effects?: string | null
    requirements?: string | null
    cost?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: TalentTypeCreateNestedOneWithoutTalentsInput
    playerTalents?: PlayerTalentCreateNestedManyWithoutTalentInput
  }

  export type TalentUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    typeId: string
    rarity?: string
    level?: number
    maxLevel?: number
    effects?: string | null
    requirements?: string | null
    cost?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerTalents?: PlayerTalentUncheckedCreateNestedManyWithoutTalentInput
  }

  export type TalentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: TalentTypeUpdateOneRequiredWithoutTalentsNestedInput
    playerTalents?: PlayerTalentUpdateManyWithoutTalentNestedInput
  }

  export type TalentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerTalents?: PlayerTalentUncheckedUpdateManyWithoutTalentNestedInput
  }

  export type TalentCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    typeId: string
    rarity?: string
    level?: number
    maxLevel?: number
    effects?: string | null
    requirements?: string | null
    cost?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TalentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TalentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerTalentCreateInput = {
    id?: string
    level?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutTalentsInput
    talent: TalentCreateNestedOneWithoutPlayerTalentsInput
  }

  export type PlayerTalentUncheckedCreateInput = {
    id?: string
    playerId: string
    talentId: string
    level?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerTalentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutTalentsNestedInput
    talent?: TalentUpdateOneRequiredWithoutPlayerTalentsNestedInput
  }

  export type PlayerTalentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    talentId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerTalentCreateManyInput = {
    id?: string
    playerId: string
    talentId: string
    level?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerTalentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerTalentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    talentId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuffCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    type?: string
    category?: string
    effects?: string | null
    duration?: number
    stackable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerBuffs?: PlayerBuffCreateNestedManyWithoutBuffInput
  }

  export type BuffUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    type?: string
    category?: string
    effects?: string | null
    duration?: number
    stackable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerBuffs?: PlayerBuffUncheckedCreateNestedManyWithoutBuffInput
  }

  export type BuffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerBuffs?: PlayerBuffUpdateManyWithoutBuffNestedInput
  }

  export type BuffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerBuffs?: PlayerBuffUncheckedUpdateManyWithoutBuffNestedInput
  }

  export type BuffCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    type?: string
    category?: string
    effects?: string | null
    duration?: number
    stackable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBuffCreateInput = {
    id?: string
    level?: number
    stacks?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutBuffsInput
    buff: BuffCreateNestedOneWithoutPlayerBuffsInput
  }

  export type PlayerBuffUncheckedCreateInput = {
    id?: string
    playerId: string
    buffId: string
    level?: number
    stacks?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerBuffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stacks?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutBuffsNestedInput
    buff?: BuffUpdateOneRequiredWithoutPlayerBuffsNestedInput
  }

  export type PlayerBuffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    buffId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stacks?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBuffCreateManyInput = {
    id?: string
    playerId: string
    buffId: string
    level?: number
    stacks?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerBuffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stacks?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBuffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    buffId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stacks?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameConfigCreateInput = {
    id?: string
    key: string
    value: string
    type?: string
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    type?: string
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    type?: string
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ShopItemCreateNestedManyWithoutShopInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ShopItemUncheckedCreateNestedManyWithoutShopInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ShopItemUpdateManyWithoutShopNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ShopItemUncheckedUpdateManyWithoutShopNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemCreateInput = {
    id?: string
    itemType: string
    itemId: string
    name: string
    displayName: string
    description?: string | null
    price: number
    currency?: string
    stock?: number
    isActive?: boolean
    level?: number
    rarity?: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shop: ShopCreateNestedOneWithoutItemsInput
  }

  export type ShopItemUncheckedCreateInput = {
    id?: string
    shopId: string
    itemType: string
    itemId: string
    name: string
    displayName: string
    description?: string | null
    price: number
    currency?: string
    stock?: number
    isActive?: boolean
    level?: number
    rarity?: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    level?: IntFieldUpdateOperationsInput | number
    rarity?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ShopItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    level?: IntFieldUpdateOperationsInput | number
    rarity?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemCreateManyInput = {
    id?: string
    shopId: string
    itemType: string
    itemId: string
    name: string
    displayName: string
    description?: string | null
    price: number
    currency?: string
    stock?: number
    isActive?: boolean
    level?: number
    rarity?: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    level?: IntFieldUpdateOperationsInput | number
    rarity?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    level?: IntFieldUpdateOperationsInput | number
    rarity?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryCreateInput = {
    id?: string
    itemId: string
    itemName: string
    quantity?: number
    price: number
    currency: string
    totalCost: number
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutPurchasesInput
    shop: ShopCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseHistoryUncheckedCreateInput = {
    id?: string
    playerId: string
    shopId: string
    itemId: string
    itemName: string
    quantity?: number
    price: number
    currency: string
    totalCost: number
    createdAt?: Date | string
  }

  export type PurchaseHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    totalCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPurchasesNestedInput
    shop?: ShopUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    totalCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryCreateManyInput = {
    id?: string
    playerId: string
    shopId: string
    itemId: string
    itemName: string
    quantity?: number
    price: number
    currency: string
    totalCost: number
    createdAt?: Date | string
  }

  export type PurchaseHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    totalCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    totalCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    id?: string
    itemType: string
    itemId: string
    name: string
    quantity?: number
    stackable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    playerId: string
    itemType: string
    itemId: string
    name: string
    quantity?: number
    stackable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyInput = {
    id?: string
    playerId: string
    itemType: string
    itemId: string
    name: string
    quantity?: number
    stackable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    level?: number
    successRate?: number
    materials: string
    result: string
    experience?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    level?: number
    successRate?: number
    materials: string
    result: string
    experience?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    craftingHistory?: CraftingHistoryUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    level?: number
    successRate?: number
    materials: string
    result: string
    experience?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CraftingHistoryCreateInput = {
    id?: string
    success: boolean
    quantity?: number
    materials: string
    result: string
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutCraftingHistoryInput
    recipe: RecipeCreateNestedOneWithoutCraftingHistoryInput
  }

  export type CraftingHistoryUncheckedCreateInput = {
    id?: string
    playerId: string
    recipeId: string
    success: boolean
    quantity?: number
    materials: string
    result: string
    createdAt?: Date | string
  }

  export type CraftingHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutCraftingHistoryNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutCraftingHistoryNestedInput
  }

  export type CraftingHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CraftingHistoryCreateManyInput = {
    id?: string
    playerId: string
    recipeId: string
    success: boolean
    quantity?: number
    materials: string
    result: string
    createdAt?: Date | string
  }

  export type CraftingHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CraftingHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DaoFurnaceCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    level?: number
    maxLevel?: number
    efficiency?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerFurnaces?: PlayerFurnaceCreateNestedManyWithoutFurnaceInput
  }

  export type DaoFurnaceUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    level?: number
    maxLevel?: number
    efficiency?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerFurnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutFurnaceInput
  }

  export type DaoFurnaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    efficiency?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerFurnaces?: PlayerFurnaceUpdateManyWithoutFurnaceNestedInput
  }

  export type DaoFurnaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    efficiency?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerFurnaces?: PlayerFurnaceUncheckedUpdateManyWithoutFurnaceNestedInput
  }

  export type DaoFurnaceCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    level?: number
    maxLevel?: number
    efficiency?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DaoFurnaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    efficiency?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DaoFurnaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    efficiency?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFurnaceCreateInput = {
    id?: string
    level?: number
    experience?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutFurnacesInput
    furnace: DaoFurnaceCreateNestedOneWithoutPlayerFurnacesInput
  }

  export type PlayerFurnaceUncheckedCreateInput = {
    id?: string
    playerId: string
    furnaceId: string
    level?: number
    experience?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerFurnaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutFurnacesNestedInput
    furnace?: DaoFurnaceUpdateOneRequiredWithoutPlayerFurnacesNestedInput
  }

  export type PlayerFurnaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    furnaceId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFurnaceCreateManyInput = {
    id?: string
    playerId: string
    furnaceId: string
    level?: number
    experience?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerFurnaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFurnaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    furnaceId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpiritBeastTypeCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    baseStats: string
    growthRate: string
    skills?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    beasts?: SpiritBeastCreateNestedManyWithoutTypeInput
  }

  export type SpiritBeastTypeUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    baseStats: string
    growthRate: string
    skills?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    beasts?: SpiritBeastUncheckedCreateNestedManyWithoutTypeInput
  }

  export type SpiritBeastTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseStats?: StringFieldUpdateOperationsInput | string
    growthRate?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beasts?: SpiritBeastUpdateManyWithoutTypeNestedInput
  }

  export type SpiritBeastTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseStats?: StringFieldUpdateOperationsInput | string
    growthRate?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beasts?: SpiritBeastUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type SpiritBeastTypeCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    baseStats: string
    growthRate: string
    skills?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpiritBeastTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseStats?: StringFieldUpdateOperationsInput | string
    growthRate?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpiritBeastTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseStats?: StringFieldUpdateOperationsInput | string
    growthRate?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpiritBeastCreateInput = {
    id?: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutSpiritBeastsInput
    type: SpiritBeastTypeCreateNestedOneWithoutBeastsInput
    feedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutBeastInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutBeastInput
  }

  export type SpiritBeastUncheckedCreateInput = {
    id?: string
    playerId: string
    typeId: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutBeastInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutBeastInput
  }

  export type SpiritBeastUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutSpiritBeastsNestedInput
    type?: SpiritBeastTypeUpdateOneRequiredWithoutBeastsNestedInput
    feedingHistory?: BeastFeedingHistoryUpdateManyWithoutBeastNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutBeastNestedInput
  }

  export type SpiritBeastUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutBeastNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutBeastNestedInput
  }

  export type SpiritBeastCreateManyInput = {
    id?: string
    playerId: string
    typeId: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpiritBeastUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpiritBeastUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFoodCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    effects: string
    price?: number
    currency?: string
    icon?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    feedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutFoodInput
  }

  export type BeastFoodUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    effects: string
    price?: number
    currency?: string
    icon?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    feedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutFoodInput
  }

  export type BeastFoodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    effects?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedingHistory?: BeastFeedingHistoryUpdateManyWithoutFoodNestedInput
  }

  export type BeastFoodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    effects?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type BeastFoodCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    effects: string
    price?: number
    currency?: string
    icon?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BeastFoodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    effects?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFoodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    effects?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFeedingHistoryCreateInput = {
    id?: string
    quantity?: number
    effects: string
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutBeastFeedingHistoryInput
    beast: SpiritBeastCreateNestedOneWithoutFeedingHistoryInput
    food: BeastFoodCreateNestedOneWithoutFeedingHistoryInput
  }

  export type BeastFeedingHistoryUncheckedCreateInput = {
    id?: string
    playerId: string
    beastId: string
    foodId: string
    quantity?: number
    effects: string
    createdAt?: Date | string
  }

  export type BeastFeedingHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutBeastFeedingHistoryNestedInput
    beast?: SpiritBeastUpdateOneRequiredWithoutFeedingHistoryNestedInput
    food?: BeastFoodUpdateOneRequiredWithoutFeedingHistoryNestedInput
  }

  export type BeastFeedingHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    beastId?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFeedingHistoryCreateManyInput = {
    id?: string
    playerId: string
    beastId: string
    foodId: string
    quantity?: number
    effects: string
    createdAt?: Date | string
  }

  export type BeastFeedingHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFeedingHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    beastId?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingGroundCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    level?: number
    maxLevel?: number
    difficulty?: string
    beastTypes: string
    dropRates: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutGroundInput
  }

  export type HuntingGroundUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    level?: number
    maxLevel?: number
    difficulty?: string
    beastTypes: string
    dropRates: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutGroundInput
  }

  export type HuntingGroundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    beastTypes?: StringFieldUpdateOperationsInput | string
    dropRates?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huntingHistory?: HuntingHistoryUpdateManyWithoutGroundNestedInput
  }

  export type HuntingGroundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    beastTypes?: StringFieldUpdateOperationsInput | string
    dropRates?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutGroundNestedInput
  }

  export type HuntingGroundCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    level?: number
    maxLevel?: number
    difficulty?: string
    beastTypes: string
    dropRates: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HuntingGroundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    beastTypes?: StringFieldUpdateOperationsInput | string
    dropRates?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingGroundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    beastTypes?: StringFieldUpdateOperationsInput | string
    dropRates?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingHistoryCreateInput = {
    id?: string
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutHuntingHistoryInput
    ground: HuntingGroundCreateNestedOneWithoutHuntingHistoryInput
    beast?: SpiritBeastCreateNestedOneWithoutHuntingHistoryInput
  }

  export type HuntingHistoryUncheckedCreateInput = {
    id?: string
    playerId: string
    groundId: string
    beastId?: string | null
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
  }

  export type HuntingHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutHuntingHistoryNestedInput
    ground?: HuntingGroundUpdateOneRequiredWithoutHuntingHistoryNestedInput
    beast?: SpiritBeastUpdateOneWithoutHuntingHistoryNestedInput
  }

  export type HuntingHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    groundId?: StringFieldUpdateOperationsInput | string
    beastId?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingHistoryCreateManyInput = {
    id?: string
    playerId: string
    groundId: string
    beastId?: string | null
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
  }

  export type HuntingHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    groundId?: StringFieldUpdateOperationsInput | string
    beastId?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCultivationCreateInput = {
    id?: string
    currentRealm?: number
    currentFloor?: number
    currentExp?: number
    totalExpGained?: number
    currentQuality?: string
    eternalTitles?: string
    hasAscended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutCultivationInput
  }

  export type PlayerCultivationUncheckedCreateInput = {
    id?: string
    playerId: string
    currentRealm?: number
    currentFloor?: number
    currentExp?: number
    totalExpGained?: number
    currentQuality?: string
    eternalTitles?: string
    hasAscended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCultivationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRealm?: IntFieldUpdateOperationsInput | number
    currentFloor?: IntFieldUpdateOperationsInput | number
    currentExp?: IntFieldUpdateOperationsInput | number
    totalExpGained?: IntFieldUpdateOperationsInput | number
    currentQuality?: StringFieldUpdateOperationsInput | string
    eternalTitles?: StringFieldUpdateOperationsInput | string
    hasAscended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutCultivationNestedInput
  }

  export type PlayerCultivationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    currentRealm?: IntFieldUpdateOperationsInput | number
    currentFloor?: IntFieldUpdateOperationsInput | number
    currentExp?: IntFieldUpdateOperationsInput | number
    totalExpGained?: IntFieldUpdateOperationsInput | number
    currentQuality?: StringFieldUpdateOperationsInput | string
    eternalTitles?: StringFieldUpdateOperationsInput | string
    hasAscended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCultivationCreateManyInput = {
    id?: string
    playerId: string
    currentRealm?: number
    currentFloor?: number
    currentExp?: number
    totalExpGained?: number
    currentQuality?: string
    eternalTitles?: string
    hasAscended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCultivationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRealm?: IntFieldUpdateOperationsInput | number
    currentFloor?: IntFieldUpdateOperationsInput | number
    currentExp?: IntFieldUpdateOperationsInput | number
    totalExpGained?: IntFieldUpdateOperationsInput | number
    currentQuality?: StringFieldUpdateOperationsInput | string
    eternalTitles?: StringFieldUpdateOperationsInput | string
    hasAscended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCultivationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    currentRealm?: IntFieldUpdateOperationsInput | number
    currentFloor?: IntFieldUpdateOperationsInput | number
    currentExp?: IntFieldUpdateOperationsInput | number
    totalExpGained?: IntFieldUpdateOperationsInput | number
    currentQuality?: StringFieldUpdateOperationsInput | string
    eternalTitles?: StringFieldUpdateOperationsInput | string
    hasAscended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationLogCreateInput = {
    id?: string
    type?: string
    description: string
    expGained?: number
    levelGained?: number
    timestamp?: Date | string
    player: PlayerCreateNestedOneWithoutCultivationLogsInput
  }

  export type CultivationLogUncheckedCreateInput = {
    id?: string
    playerId: string
    type?: string
    description: string
    expGained?: number
    levelGained?: number
    timestamp?: Date | string
  }

  export type CultivationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expGained?: IntFieldUpdateOperationsInput | number
    levelGained?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutCultivationLogsNestedInput
  }

  export type CultivationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expGained?: IntFieldUpdateOperationsInput | number
    levelGained?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationLogCreateManyInput = {
    id?: string
    playerId: string
    type?: string
    description: string
    expGained?: number
    levelGained?: number
    timestamp?: Date | string
  }

  export type CultivationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expGained?: IntFieldUpdateOperationsInput | number
    levelGained?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expGained?: IntFieldUpdateOperationsInput | number
    levelGained?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PlayerNullableRelationFilter = {
    is?: PlayerWhereInput | null
    isNot?: PlayerWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type PlayerResourceListRelationFilter = {
    every?: PlayerResourceWhereInput
    some?: PlayerResourceWhereInput
    none?: PlayerResourceWhereInput
  }

  export type PlayerCompanionListRelationFilter = {
    every?: PlayerCompanionWhereInput
    some?: PlayerCompanionWhereInput
    none?: PlayerCompanionWhereInput
  }

  export type PlayerAchievementListRelationFilter = {
    every?: PlayerAchievementWhereInput
    some?: PlayerAchievementWhereInput
    none?: PlayerAchievementWhereInput
  }

  export type PlayerQuestListRelationFilter = {
    every?: PlayerQuestWhereInput
    some?: PlayerQuestWhereInput
    none?: PlayerQuestWhereInput
  }

  export type PlayerStatsNullableRelationFilter = {
    is?: PlayerStatsWhereInput | null
    isNot?: PlayerStatsWhereInput | null
  }

  export type PlayerEquipmentListRelationFilter = {
    every?: PlayerEquipmentWhereInput
    some?: PlayerEquipmentWhereInput
    none?: PlayerEquipmentWhereInput
  }

  export type PlayerSkillListRelationFilter = {
    every?: PlayerSkillWhereInput
    some?: PlayerSkillWhereInput
    none?: PlayerSkillWhereInput
  }

  export type PlayerTalentListRelationFilter = {
    every?: PlayerTalentWhereInput
    some?: PlayerTalentWhereInput
    none?: PlayerTalentWhereInput
  }

  export type PlayerBuffListRelationFilter = {
    every?: PlayerBuffWhereInput
    some?: PlayerBuffWhereInput
    none?: PlayerBuffWhereInput
  }

  export type PurchaseHistoryListRelationFilter = {
    every?: PurchaseHistoryWhereInput
    some?: PurchaseHistoryWhereInput
    none?: PurchaseHistoryWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type CraftingHistoryListRelationFilter = {
    every?: CraftingHistoryWhereInput
    some?: CraftingHistoryWhereInput
    none?: CraftingHistoryWhereInput
  }

  export type PlayerFurnaceListRelationFilter = {
    every?: PlayerFurnaceWhereInput
    some?: PlayerFurnaceWhereInput
    none?: PlayerFurnaceWhereInput
  }

  export type SpiritBeastListRelationFilter = {
    every?: SpiritBeastWhereInput
    some?: SpiritBeastWhereInput
    none?: SpiritBeastWhereInput
  }

  export type BeastFeedingHistoryListRelationFilter = {
    every?: BeastFeedingHistoryWhereInput
    some?: BeastFeedingHistoryWhereInput
    none?: BeastFeedingHistoryWhereInput
  }

  export type HuntingHistoryListRelationFilter = {
    every?: HuntingHistoryWhereInput
    some?: HuntingHistoryWhereInput
    none?: HuntingHistoryWhereInput
  }

  export type CultivationLogListRelationFilter = {
    every?: CultivationLogWhereInput
    some?: CultivationLogWhereInput
    none?: CultivationLogWhereInput
  }

  export type PlayerCultivationNullableRelationFilter = {
    is?: PlayerCultivationWhereInput | null
    isNot?: PlayerCultivationWhereInput | null
  }

  export type PlayerResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCompanionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerQuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerEquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerTalentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerBuffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CraftingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerFurnaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpiritBeastOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BeastFeedingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HuntingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CultivationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    realm?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    realm?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    realm?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PlayerRelationFilter = {
    is?: PlayerWhereInput
    isNot?: PlayerWhereInput
  }

  export type ResourceRelationFilter = {
    is?: ResourceWhereInput
    isNot?: ResourceWhereInput
  }

  export type PlayerResourcePlayerIdResourceIdCompoundUniqueInput = {
    playerId: string
    resourceId: string
  }

  export type PlayerResourceCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    resourceId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerResourceAvgOrderByAggregateInput = {
    amount?: SortOrder
    locked?: SortOrder
  }

  export type PlayerResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    resourceId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerResourceMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    resourceId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerResourceSumOrderByAggregateInput = {
    amount?: SortOrder
    locked?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CompanionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    rarity?: SortOrder
    basePower?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanionAvgOrderByAggregateInput = {
    basePower?: SortOrder
  }

  export type CompanionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    rarity?: SortOrder
    basePower?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    rarity?: SortOrder
    basePower?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanionSumOrderByAggregateInput = {
    basePower?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CompanionRelationFilter = {
    is?: CompanionWhereInput
    isNot?: CompanionWhereInput
  }

  export type PlayerCompanionPlayerIdCompanionIdCompoundUniqueInput = {
    playerId: string
    companionId: string
  }

  export type PlayerCompanionCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    companionId?: SortOrder
    level?: SortOrder
    power?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerCompanionAvgOrderByAggregateInput = {
    level?: SortOrder
    power?: SortOrder
  }

  export type PlayerCompanionMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    companionId?: SortOrder
    level?: SortOrder
    power?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerCompanionMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    companionId?: SortOrder
    level?: SortOrder
    power?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerCompanionSumOrderByAggregateInput = {
    level?: SortOrder
    power?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AchievementRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type PlayerAchievementPlayerIdAchievementIdCompoundUniqueInput = {
    playerId: string
    achievementId: string
  }

  export type PlayerAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type PlayerAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type PlayerAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type QuestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    rewards?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    isRepeatable?: SortOrder
    repeatInterval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestAvgOrderByAggregateInput = {
    repeatInterval?: SortOrder
  }

  export type QuestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    rewards?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    isRepeatable?: SortOrder
    repeatInterval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    rewards?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    isRepeatable?: SortOrder
    repeatInterval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestSumOrderByAggregateInput = {
    repeatInterval?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type QuestRelationFilter = {
    is?: QuestWhereInput
    isNot?: QuestWhereInput
  }

  export type PlayerQuestPlayerIdQuestIdCompoundUniqueInput = {
    playerId: string
    questId: string
  }

  export type PlayerQuestCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    questId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lastCompletedAt?: SortOrder
    cooldownUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerQuestMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    questId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lastCompletedAt?: SortOrder
    cooldownUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerQuestMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    questId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lastCompletedAt?: SortOrder
    cooldownUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PlayerStatsCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    hp?: SortOrder
    mp?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    luck?: SortOrder
    wisdom?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    vitality?: SortOrder
    spirit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerStatsAvgOrderByAggregateInput = {
    hp?: SortOrder
    mp?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    luck?: SortOrder
    wisdom?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    vitality?: SortOrder
    spirit?: SortOrder
  }

  export type PlayerStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    hp?: SortOrder
    mp?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    luck?: SortOrder
    wisdom?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    vitality?: SortOrder
    spirit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerStatsMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    hp?: SortOrder
    mp?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    luck?: SortOrder
    wisdom?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    vitality?: SortOrder
    spirit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerStatsSumOrderByAggregateInput = {
    hp?: SortOrder
    mp?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    luck?: SortOrder
    wisdom?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    vitality?: SortOrder
    spirit?: SortOrder
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    slot?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    slot?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    slot?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentTypeRelationFilter = {
    is?: EquipmentTypeWhereInput
    isNot?: EquipmentTypeWhereInput
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    typeId?: SortOrder
    rarity?: SortOrder
    level?: SortOrder
    stats?: SortOrder
    requirements?: SortOrder
    price?: SortOrder
    isTradeable?: SortOrder
    isSellable?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    level?: SortOrder
    price?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    typeId?: SortOrder
    rarity?: SortOrder
    level?: SortOrder
    stats?: SortOrder
    requirements?: SortOrder
    price?: SortOrder
    isTradeable?: SortOrder
    isSellable?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    typeId?: SortOrder
    rarity?: SortOrder
    level?: SortOrder
    stats?: SortOrder
    requirements?: SortOrder
    price?: SortOrder
    isTradeable?: SortOrder
    isSellable?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    level?: SortOrder
    price?: SortOrder
  }

  export type EquipmentRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type PlayerEquipmentPlayerIdEquipmentIdCompoundUniqueInput = {
    playerId: string
    equipmentId: string
  }

  export type PlayerEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    equipmentId?: SortOrder
    isEquipped?: SortOrder
    durability?: SortOrder
    enhancement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerEquipmentAvgOrderByAggregateInput = {
    durability?: SortOrder
    enhancement?: SortOrder
  }

  export type PlayerEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    equipmentId?: SortOrder
    isEquipped?: SortOrder
    durability?: SortOrder
    enhancement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    equipmentId?: SortOrder
    isEquipped?: SortOrder
    durability?: SortOrder
    enhancement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerEquipmentSumOrderByAggregateInput = {
    durability?: SortOrder
    enhancement?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    cooldown?: SortOrder
    mpCost?: SortOrder
    damage?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillAvgOrderByAggregateInput = {
    level?: SortOrder
    maxLevel?: SortOrder
    cooldown?: SortOrder
    mpCost?: SortOrder
    damage?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    cooldown?: SortOrder
    mpCost?: SortOrder
    damage?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    cooldown?: SortOrder
    mpCost?: SortOrder
    damage?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillSumOrderByAggregateInput = {
    level?: SortOrder
    maxLevel?: SortOrder
    cooldown?: SortOrder
    mpCost?: SortOrder
    damage?: SortOrder
  }

  export type SkillRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type PlayerSkillPlayerIdSkillIdCompoundUniqueInput = {
    playerId: string
    skillId: string
  }

  export type PlayerSkillCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    isLearned?: SortOrder
    learnedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSkillAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type PlayerSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    isLearned?: SortOrder
    learnedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSkillMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    isLearned?: SortOrder
    learnedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSkillSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type TalentListRelationFilter = {
    every?: TalentWhereInput
    some?: TalentWhereInput
    none?: TalentWhereInput
  }

  export type TalentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TalentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TalentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TalentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TalentTypeRelationFilter = {
    is?: TalentTypeWhereInput
    isNot?: TalentTypeWhereInput
  }

  export type TalentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    typeId?: SortOrder
    rarity?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    cost?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TalentAvgOrderByAggregateInput = {
    level?: SortOrder
    maxLevel?: SortOrder
    cost?: SortOrder
  }

  export type TalentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    typeId?: SortOrder
    rarity?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    cost?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TalentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    typeId?: SortOrder
    rarity?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    cost?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TalentSumOrderByAggregateInput = {
    level?: SortOrder
    maxLevel?: SortOrder
    cost?: SortOrder
  }

  export type TalentRelationFilter = {
    is?: TalentWhereInput
    isNot?: TalentWhereInput
  }

  export type PlayerTalentPlayerIdTalentIdCompoundUniqueInput = {
    playerId: string
    talentId: string
  }

  export type PlayerTalentCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    talentId?: SortOrder
    level?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerTalentAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type PlayerTalentMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    talentId?: SortOrder
    level?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerTalentMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    talentId?: SortOrder
    level?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerTalentSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type BuffCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    effects?: SortOrder
    duration?: SortOrder
    stackable?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuffAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type BuffMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    effects?: SortOrder
    duration?: SortOrder
    stackable?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuffMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    effects?: SortOrder
    duration?: SortOrder
    stackable?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuffSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type BuffRelationFilter = {
    is?: BuffWhereInput
    isNot?: BuffWhereInput
  }

  export type PlayerBuffPlayerIdBuffIdCompoundUniqueInput = {
    playerId: string
    buffId: string
  }

  export type PlayerBuffCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    buffId?: SortOrder
    level?: SortOrder
    stacks?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerBuffAvgOrderByAggregateInput = {
    level?: SortOrder
    stacks?: SortOrder
  }

  export type PlayerBuffMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    buffId?: SortOrder
    level?: SortOrder
    stacks?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerBuffMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    buffId?: SortOrder
    level?: SortOrder
    stacks?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerBuffSumOrderByAggregateInput = {
    level?: SortOrder
    stacks?: SortOrder
  }

  export type GameConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemListRelationFilter = {
    every?: ShopItemWhereInput
    some?: ShopItemWhereInput
    none?: ShopItemWhereInput
  }

  export type ShopItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopRelationFilter = {
    is?: ShopWhereInput
    isNot?: ShopWhereInput
  }

  export type ShopItemShopIdItemIdCompoundUniqueInput = {
    shopId: string
    itemId: string
  }

  export type ShopItemCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    level?: SortOrder
    rarity?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
    level?: SortOrder
  }

  export type ShopItemMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    level?: SortOrder
    rarity?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    level?: SortOrder
    rarity?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
    level?: SortOrder
  }

  export type PurchaseHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    shopId?: SortOrder
    itemId?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseHistoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    totalCost?: SortOrder
  }

  export type PurchaseHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    shopId?: SortOrder
    itemId?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    shopId?: SortOrder
    itemId?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseHistorySumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    totalCost?: SortOrder
  }

  export type InventoryPlayerIdItemIdCompoundUniqueInput = {
    playerId: string
    itemId: string
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    stackable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    stackable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    stackable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    level?: SortOrder
    successRate?: SortOrder
    materials?: SortOrder
    result?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    level?: SortOrder
    successRate?: SortOrder
    experience?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    level?: SortOrder
    successRate?: SortOrder
    materials?: SortOrder
    result?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    level?: SortOrder
    successRate?: SortOrder
    materials?: SortOrder
    result?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    level?: SortOrder
    successRate?: SortOrder
    experience?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RecipeRelationFilter = {
    is?: RecipeWhereInput
    isNot?: RecipeWhereInput
  }

  export type CraftingHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    recipeId?: SortOrder
    success?: SortOrder
    quantity?: SortOrder
    materials?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type CraftingHistoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CraftingHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    recipeId?: SortOrder
    success?: SortOrder
    quantity?: SortOrder
    materials?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type CraftingHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    recipeId?: SortOrder
    success?: SortOrder
    quantity?: SortOrder
    materials?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type CraftingHistorySumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type DaoFurnaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    efficiency?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DaoFurnaceAvgOrderByAggregateInput = {
    level?: SortOrder
    maxLevel?: SortOrder
    efficiency?: SortOrder
  }

  export type DaoFurnaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    efficiency?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DaoFurnaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    efficiency?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DaoFurnaceSumOrderByAggregateInput = {
    level?: SortOrder
    maxLevel?: SortOrder
    efficiency?: SortOrder
  }

  export type DaoFurnaceRelationFilter = {
    is?: DaoFurnaceWhereInput
    isNot?: DaoFurnaceWhereInput
  }

  export type PlayerFurnacePlayerIdFurnaceIdCompoundUniqueInput = {
    playerId: string
    furnaceId: string
  }

  export type PlayerFurnaceCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    furnaceId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerFurnaceAvgOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
  }

  export type PlayerFurnaceMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    furnaceId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerFurnaceMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    furnaceId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerFurnaceSumOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
  }

  export type SpiritBeastTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    baseStats?: SortOrder
    growthRate?: SortOrder
    skills?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpiritBeastTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    baseStats?: SortOrder
    growthRate?: SortOrder
    skills?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpiritBeastTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    baseStats?: SortOrder
    growthRate?: SortOrder
    skills?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpiritBeastTypeRelationFilter = {
    is?: SpiritBeastTypeWhereInput
    isNot?: SpiritBeastTypeWhereInput
  }

  export type SpiritBeastCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    typeId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    stats?: SortOrder
    skills?: SortOrder
    happiness?: SortOrder
    hunger?: SortOrder
    health?: SortOrder
    isActive?: SortOrder
    isFighting?: SortOrder
    capturedAt?: SortOrder
    lastFedAt?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpiritBeastAvgOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
    happiness?: SortOrder
    hunger?: SortOrder
    health?: SortOrder
  }

  export type SpiritBeastMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    typeId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    stats?: SortOrder
    skills?: SortOrder
    happiness?: SortOrder
    hunger?: SortOrder
    health?: SortOrder
    isActive?: SortOrder
    isFighting?: SortOrder
    capturedAt?: SortOrder
    lastFedAt?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpiritBeastMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    typeId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    stats?: SortOrder
    skills?: SortOrder
    happiness?: SortOrder
    hunger?: SortOrder
    health?: SortOrder
    isActive?: SortOrder
    isFighting?: SortOrder
    capturedAt?: SortOrder
    lastFedAt?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpiritBeastSumOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
    happiness?: SortOrder
    hunger?: SortOrder
    health?: SortOrder
  }

  export type BeastFoodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    effects?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BeastFoodAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BeastFoodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    effects?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BeastFoodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    effects?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BeastFoodSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SpiritBeastRelationFilter = {
    is?: SpiritBeastWhereInput
    isNot?: SpiritBeastWhereInput
  }

  export type BeastFoodRelationFilter = {
    is?: BeastFoodWhereInput
    isNot?: BeastFoodWhereInput
  }

  export type BeastFeedingHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    beastId?: SortOrder
    foodId?: SortOrder
    quantity?: SortOrder
    effects?: SortOrder
    createdAt?: SortOrder
  }

  export type BeastFeedingHistoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type BeastFeedingHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    beastId?: SortOrder
    foodId?: SortOrder
    quantity?: SortOrder
    effects?: SortOrder
    createdAt?: SortOrder
  }

  export type BeastFeedingHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    beastId?: SortOrder
    foodId?: SortOrder
    quantity?: SortOrder
    effects?: SortOrder
    createdAt?: SortOrder
  }

  export type BeastFeedingHistorySumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type HuntingGroundCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    difficulty?: SortOrder
    beastTypes?: SortOrder
    dropRates?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HuntingGroundAvgOrderByAggregateInput = {
    level?: SortOrder
    maxLevel?: SortOrder
  }

  export type HuntingGroundMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    difficulty?: SortOrder
    beastTypes?: SortOrder
    dropRates?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HuntingGroundMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    difficulty?: SortOrder
    beastTypes?: SortOrder
    dropRates?: SortOrder
    isActive?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HuntingGroundSumOrderByAggregateInput = {
    level?: SortOrder
    maxLevel?: SortOrder
  }

  export type HuntingGroundRelationFilter = {
    is?: HuntingGroundWhereInput
    isNot?: HuntingGroundWhereInput
  }

  export type SpiritBeastNullableRelationFilter = {
    is?: SpiritBeastWhereInput | null
    isNot?: SpiritBeastWhereInput | null
  }

  export type HuntingHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    groundId?: SortOrder
    beastId?: SortOrder
    success?: SortOrder
    duration?: SortOrder
    rewards?: SortOrder
    createdAt?: SortOrder
  }

  export type HuntingHistoryAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type HuntingHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    groundId?: SortOrder
    beastId?: SortOrder
    success?: SortOrder
    duration?: SortOrder
    rewards?: SortOrder
    createdAt?: SortOrder
  }

  export type HuntingHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    groundId?: SortOrder
    beastId?: SortOrder
    success?: SortOrder
    duration?: SortOrder
    rewards?: SortOrder
    createdAt?: SortOrder
  }

  export type HuntingHistorySumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type PlayerCultivationCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    currentRealm?: SortOrder
    currentFloor?: SortOrder
    currentExp?: SortOrder
    totalExpGained?: SortOrder
    currentQuality?: SortOrder
    eternalTitles?: SortOrder
    hasAscended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerCultivationAvgOrderByAggregateInput = {
    currentRealm?: SortOrder
    currentFloor?: SortOrder
    currentExp?: SortOrder
    totalExpGained?: SortOrder
  }

  export type PlayerCultivationMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    currentRealm?: SortOrder
    currentFloor?: SortOrder
    currentExp?: SortOrder
    totalExpGained?: SortOrder
    currentQuality?: SortOrder
    eternalTitles?: SortOrder
    hasAscended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerCultivationMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    currentRealm?: SortOrder
    currentFloor?: SortOrder
    currentExp?: SortOrder
    totalExpGained?: SortOrder
    currentQuality?: SortOrder
    eternalTitles?: SortOrder
    hasAscended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerCultivationSumOrderByAggregateInput = {
    currentRealm?: SortOrder
    currentFloor?: SortOrder
    currentExp?: SortOrder
    totalExpGained?: SortOrder
  }

  export type CultivationLogCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    expGained?: SortOrder
    levelGained?: SortOrder
    timestamp?: SortOrder
  }

  export type CultivationLogAvgOrderByAggregateInput = {
    expGained?: SortOrder
    levelGained?: SortOrder
  }

  export type CultivationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    expGained?: SortOrder
    levelGained?: SortOrder
    timestamp?: SortOrder
  }

  export type CultivationLogMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    expGained?: SortOrder
    levelGained?: SortOrder
    timestamp?: SortOrder
  }

  export type CultivationLogSumOrderByAggregateInput = {
    expGained?: SortOrder
    levelGained?: SortOrder
  }

  export type PlayerCreateNestedOneWithoutUserInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput
    connect?: PlayerWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput
    connect?: PlayerWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PlayerUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput
    upsert?: PlayerUpsertWithoutUserInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutUserInput, PlayerUpdateWithoutUserInput>, PlayerUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput
    upsert?: PlayerUpsertWithoutUserInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutUserInput, PlayerUpdateWithoutUserInput>, PlayerUncheckedUpdateWithoutUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutPlayerInput = {
    create?: XOR<UserCreateWithoutPlayerInput, UserUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerInput
    connect?: UserWhereUniqueInput
  }

  export type PlayerResourceCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerResourceCreateWithoutPlayerInput, PlayerResourceUncheckedCreateWithoutPlayerInput> | PlayerResourceCreateWithoutPlayerInput[] | PlayerResourceUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerResourceCreateOrConnectWithoutPlayerInput | PlayerResourceCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerResourceCreateManyPlayerInputEnvelope
    connect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
  }

  export type PlayerCompanionCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerCompanionCreateWithoutPlayerInput, PlayerCompanionUncheckedCreateWithoutPlayerInput> | PlayerCompanionCreateWithoutPlayerInput[] | PlayerCompanionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerCompanionCreateOrConnectWithoutPlayerInput | PlayerCompanionCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerCompanionCreateManyPlayerInputEnvelope
    connect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
  }

  export type PlayerAchievementCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerAchievementCreateWithoutPlayerInput, PlayerAchievementUncheckedCreateWithoutPlayerInput> | PlayerAchievementCreateWithoutPlayerInput[] | PlayerAchievementUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerAchievementCreateOrConnectWithoutPlayerInput | PlayerAchievementCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerAchievementCreateManyPlayerInputEnvelope
    connect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
  }

  export type PlayerQuestCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerQuestCreateWithoutPlayerInput, PlayerQuestUncheckedCreateWithoutPlayerInput> | PlayerQuestCreateWithoutPlayerInput[] | PlayerQuestUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerQuestCreateOrConnectWithoutPlayerInput | PlayerQuestCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerQuestCreateManyPlayerInputEnvelope
    connect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
  }

  export type PlayerStatsCreateNestedOneWithoutPlayerInput = {
    create?: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerStatsCreateOrConnectWithoutPlayerInput
    connect?: PlayerStatsWhereUniqueInput
  }

  export type PlayerEquipmentCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput> | PlayerEquipmentCreateWithoutPlayerInput[] | PlayerEquipmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutPlayerInput | PlayerEquipmentCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerEquipmentCreateManyPlayerInputEnvelope
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
  }

  export type PlayerSkillCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput> | PlayerSkillCreateWithoutPlayerInput[] | PlayerSkillUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutPlayerInput | PlayerSkillCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerSkillCreateManyPlayerInputEnvelope
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
  }

  export type PlayerTalentCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerTalentCreateWithoutPlayerInput, PlayerTalentUncheckedCreateWithoutPlayerInput> | PlayerTalentCreateWithoutPlayerInput[] | PlayerTalentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerTalentCreateOrConnectWithoutPlayerInput | PlayerTalentCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerTalentCreateManyPlayerInputEnvelope
    connect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
  }

  export type PlayerBuffCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerBuffCreateWithoutPlayerInput, PlayerBuffUncheckedCreateWithoutPlayerInput> | PlayerBuffCreateWithoutPlayerInput[] | PlayerBuffUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerBuffCreateOrConnectWithoutPlayerInput | PlayerBuffCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerBuffCreateManyPlayerInputEnvelope
    connect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
  }

  export type PurchaseHistoryCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PurchaseHistoryCreateWithoutPlayerInput, PurchaseHistoryUncheckedCreateWithoutPlayerInput> | PurchaseHistoryCreateWithoutPlayerInput[] | PurchaseHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutPlayerInput | PurchaseHistoryCreateOrConnectWithoutPlayerInput[]
    createMany?: PurchaseHistoryCreateManyPlayerInputEnvelope
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutPlayerInput = {
    create?: XOR<InventoryCreateWithoutPlayerInput, InventoryUncheckedCreateWithoutPlayerInput> | InventoryCreateWithoutPlayerInput[] | InventoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutPlayerInput | InventoryCreateOrConnectWithoutPlayerInput[]
    createMany?: InventoryCreateManyPlayerInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type CraftingHistoryCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CraftingHistoryCreateWithoutPlayerInput, CraftingHistoryUncheckedCreateWithoutPlayerInput> | CraftingHistoryCreateWithoutPlayerInput[] | CraftingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CraftingHistoryCreateOrConnectWithoutPlayerInput | CraftingHistoryCreateOrConnectWithoutPlayerInput[]
    createMany?: CraftingHistoryCreateManyPlayerInputEnvelope
    connect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
  }

  export type PlayerFurnaceCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerFurnaceCreateWithoutPlayerInput, PlayerFurnaceUncheckedCreateWithoutPlayerInput> | PlayerFurnaceCreateWithoutPlayerInput[] | PlayerFurnaceUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerFurnaceCreateOrConnectWithoutPlayerInput | PlayerFurnaceCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerFurnaceCreateManyPlayerInputEnvelope
    connect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
  }

  export type SpiritBeastCreateNestedManyWithoutPlayerInput = {
    create?: XOR<SpiritBeastCreateWithoutPlayerInput, SpiritBeastUncheckedCreateWithoutPlayerInput> | SpiritBeastCreateWithoutPlayerInput[] | SpiritBeastUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutPlayerInput | SpiritBeastCreateOrConnectWithoutPlayerInput[]
    createMany?: SpiritBeastCreateManyPlayerInputEnvelope
    connect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
  }

  export type BeastFeedingHistoryCreateNestedManyWithoutPlayerInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutPlayerInput, BeastFeedingHistoryUncheckedCreateWithoutPlayerInput> | BeastFeedingHistoryCreateWithoutPlayerInput[] | BeastFeedingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutPlayerInput | BeastFeedingHistoryCreateOrConnectWithoutPlayerInput[]
    createMany?: BeastFeedingHistoryCreateManyPlayerInputEnvelope
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
  }

  export type HuntingHistoryCreateNestedManyWithoutPlayerInput = {
    create?: XOR<HuntingHistoryCreateWithoutPlayerInput, HuntingHistoryUncheckedCreateWithoutPlayerInput> | HuntingHistoryCreateWithoutPlayerInput[] | HuntingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutPlayerInput | HuntingHistoryCreateOrConnectWithoutPlayerInput[]
    createMany?: HuntingHistoryCreateManyPlayerInputEnvelope
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
  }

  export type CultivationLogCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CultivationLogCreateWithoutPlayerInput, CultivationLogUncheckedCreateWithoutPlayerInput> | CultivationLogCreateWithoutPlayerInput[] | CultivationLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CultivationLogCreateOrConnectWithoutPlayerInput | CultivationLogCreateOrConnectWithoutPlayerInput[]
    createMany?: CultivationLogCreateManyPlayerInputEnvelope
    connect?: CultivationLogWhereUniqueInput | CultivationLogWhereUniqueInput[]
  }

  export type PlayerCultivationCreateNestedOneWithoutPlayerInput = {
    create?: XOR<PlayerCultivationCreateWithoutPlayerInput, PlayerCultivationUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerCultivationCreateOrConnectWithoutPlayerInput
    connect?: PlayerCultivationWhereUniqueInput
  }

  export type PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerResourceCreateWithoutPlayerInput, PlayerResourceUncheckedCreateWithoutPlayerInput> | PlayerResourceCreateWithoutPlayerInput[] | PlayerResourceUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerResourceCreateOrConnectWithoutPlayerInput | PlayerResourceCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerResourceCreateManyPlayerInputEnvelope
    connect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
  }

  export type PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerCompanionCreateWithoutPlayerInput, PlayerCompanionUncheckedCreateWithoutPlayerInput> | PlayerCompanionCreateWithoutPlayerInput[] | PlayerCompanionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerCompanionCreateOrConnectWithoutPlayerInput | PlayerCompanionCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerCompanionCreateManyPlayerInputEnvelope
    connect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
  }

  export type PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerAchievementCreateWithoutPlayerInput, PlayerAchievementUncheckedCreateWithoutPlayerInput> | PlayerAchievementCreateWithoutPlayerInput[] | PlayerAchievementUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerAchievementCreateOrConnectWithoutPlayerInput | PlayerAchievementCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerAchievementCreateManyPlayerInputEnvelope
    connect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
  }

  export type PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerQuestCreateWithoutPlayerInput, PlayerQuestUncheckedCreateWithoutPlayerInput> | PlayerQuestCreateWithoutPlayerInput[] | PlayerQuestUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerQuestCreateOrConnectWithoutPlayerInput | PlayerQuestCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerQuestCreateManyPlayerInputEnvelope
    connect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
  }

  export type PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerStatsCreateOrConnectWithoutPlayerInput
    connect?: PlayerStatsWhereUniqueInput
  }

  export type PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput> | PlayerEquipmentCreateWithoutPlayerInput[] | PlayerEquipmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutPlayerInput | PlayerEquipmentCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerEquipmentCreateManyPlayerInputEnvelope
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
  }

  export type PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput> | PlayerSkillCreateWithoutPlayerInput[] | PlayerSkillUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutPlayerInput | PlayerSkillCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerSkillCreateManyPlayerInputEnvelope
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
  }

  export type PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerTalentCreateWithoutPlayerInput, PlayerTalentUncheckedCreateWithoutPlayerInput> | PlayerTalentCreateWithoutPlayerInput[] | PlayerTalentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerTalentCreateOrConnectWithoutPlayerInput | PlayerTalentCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerTalentCreateManyPlayerInputEnvelope
    connect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
  }

  export type PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerBuffCreateWithoutPlayerInput, PlayerBuffUncheckedCreateWithoutPlayerInput> | PlayerBuffCreateWithoutPlayerInput[] | PlayerBuffUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerBuffCreateOrConnectWithoutPlayerInput | PlayerBuffCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerBuffCreateManyPlayerInputEnvelope
    connect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
  }

  export type PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PurchaseHistoryCreateWithoutPlayerInput, PurchaseHistoryUncheckedCreateWithoutPlayerInput> | PurchaseHistoryCreateWithoutPlayerInput[] | PurchaseHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutPlayerInput | PurchaseHistoryCreateOrConnectWithoutPlayerInput[]
    createMany?: PurchaseHistoryCreateManyPlayerInputEnvelope
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<InventoryCreateWithoutPlayerInput, InventoryUncheckedCreateWithoutPlayerInput> | InventoryCreateWithoutPlayerInput[] | InventoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutPlayerInput | InventoryCreateOrConnectWithoutPlayerInput[]
    createMany?: InventoryCreateManyPlayerInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CraftingHistoryCreateWithoutPlayerInput, CraftingHistoryUncheckedCreateWithoutPlayerInput> | CraftingHistoryCreateWithoutPlayerInput[] | CraftingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CraftingHistoryCreateOrConnectWithoutPlayerInput | CraftingHistoryCreateOrConnectWithoutPlayerInput[]
    createMany?: CraftingHistoryCreateManyPlayerInputEnvelope
    connect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
  }

  export type PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerFurnaceCreateWithoutPlayerInput, PlayerFurnaceUncheckedCreateWithoutPlayerInput> | PlayerFurnaceCreateWithoutPlayerInput[] | PlayerFurnaceUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerFurnaceCreateOrConnectWithoutPlayerInput | PlayerFurnaceCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerFurnaceCreateManyPlayerInputEnvelope
    connect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
  }

  export type SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<SpiritBeastCreateWithoutPlayerInput, SpiritBeastUncheckedCreateWithoutPlayerInput> | SpiritBeastCreateWithoutPlayerInput[] | SpiritBeastUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutPlayerInput | SpiritBeastCreateOrConnectWithoutPlayerInput[]
    createMany?: SpiritBeastCreateManyPlayerInputEnvelope
    connect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
  }

  export type BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutPlayerInput, BeastFeedingHistoryUncheckedCreateWithoutPlayerInput> | BeastFeedingHistoryCreateWithoutPlayerInput[] | BeastFeedingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutPlayerInput | BeastFeedingHistoryCreateOrConnectWithoutPlayerInput[]
    createMany?: BeastFeedingHistoryCreateManyPlayerInputEnvelope
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
  }

  export type HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<HuntingHistoryCreateWithoutPlayerInput, HuntingHistoryUncheckedCreateWithoutPlayerInput> | HuntingHistoryCreateWithoutPlayerInput[] | HuntingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutPlayerInput | HuntingHistoryCreateOrConnectWithoutPlayerInput[]
    createMany?: HuntingHistoryCreateManyPlayerInputEnvelope
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
  }

  export type CultivationLogUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CultivationLogCreateWithoutPlayerInput, CultivationLogUncheckedCreateWithoutPlayerInput> | CultivationLogCreateWithoutPlayerInput[] | CultivationLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CultivationLogCreateOrConnectWithoutPlayerInput | CultivationLogCreateOrConnectWithoutPlayerInput[]
    createMany?: CultivationLogCreateManyPlayerInputEnvelope
    connect?: CultivationLogWhereUniqueInput | CultivationLogWhereUniqueInput[]
  }

  export type PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<PlayerCultivationCreateWithoutPlayerInput, PlayerCultivationUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerCultivationCreateOrConnectWithoutPlayerInput
    connect?: PlayerCultivationWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneRequiredWithoutPlayerNestedInput = {
    create?: XOR<UserCreateWithoutPlayerInput, UserUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerInput
    upsert?: UserUpsertWithoutPlayerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayerInput, UserUpdateWithoutPlayerInput>, UserUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerResourceUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerResourceCreateWithoutPlayerInput, PlayerResourceUncheckedCreateWithoutPlayerInput> | PlayerResourceCreateWithoutPlayerInput[] | PlayerResourceUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerResourceCreateOrConnectWithoutPlayerInput | PlayerResourceCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerResourceUpsertWithWhereUniqueWithoutPlayerInput | PlayerResourceUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerResourceCreateManyPlayerInputEnvelope
    set?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    disconnect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    delete?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    connect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    update?: PlayerResourceUpdateWithWhereUniqueWithoutPlayerInput | PlayerResourceUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerResourceUpdateManyWithWhereWithoutPlayerInput | PlayerResourceUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerResourceScalarWhereInput | PlayerResourceScalarWhereInput[]
  }

  export type PlayerCompanionUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerCompanionCreateWithoutPlayerInput, PlayerCompanionUncheckedCreateWithoutPlayerInput> | PlayerCompanionCreateWithoutPlayerInput[] | PlayerCompanionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerCompanionCreateOrConnectWithoutPlayerInput | PlayerCompanionCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerCompanionUpsertWithWhereUniqueWithoutPlayerInput | PlayerCompanionUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerCompanionCreateManyPlayerInputEnvelope
    set?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    disconnect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    delete?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    connect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    update?: PlayerCompanionUpdateWithWhereUniqueWithoutPlayerInput | PlayerCompanionUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerCompanionUpdateManyWithWhereWithoutPlayerInput | PlayerCompanionUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerCompanionScalarWhereInput | PlayerCompanionScalarWhereInput[]
  }

  export type PlayerAchievementUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerAchievementCreateWithoutPlayerInput, PlayerAchievementUncheckedCreateWithoutPlayerInput> | PlayerAchievementCreateWithoutPlayerInput[] | PlayerAchievementUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerAchievementCreateOrConnectWithoutPlayerInput | PlayerAchievementCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerAchievementUpsertWithWhereUniqueWithoutPlayerInput | PlayerAchievementUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerAchievementCreateManyPlayerInputEnvelope
    set?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    disconnect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    delete?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    connect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    update?: PlayerAchievementUpdateWithWhereUniqueWithoutPlayerInput | PlayerAchievementUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerAchievementUpdateManyWithWhereWithoutPlayerInput | PlayerAchievementUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerAchievementScalarWhereInput | PlayerAchievementScalarWhereInput[]
  }

  export type PlayerQuestUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerQuestCreateWithoutPlayerInput, PlayerQuestUncheckedCreateWithoutPlayerInput> | PlayerQuestCreateWithoutPlayerInput[] | PlayerQuestUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerQuestCreateOrConnectWithoutPlayerInput | PlayerQuestCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerQuestUpsertWithWhereUniqueWithoutPlayerInput | PlayerQuestUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerQuestCreateManyPlayerInputEnvelope
    set?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    disconnect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    delete?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    connect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    update?: PlayerQuestUpdateWithWhereUniqueWithoutPlayerInput | PlayerQuestUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerQuestUpdateManyWithWhereWithoutPlayerInput | PlayerQuestUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerQuestScalarWhereInput | PlayerQuestScalarWhereInput[]
  }

  export type PlayerStatsUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerStatsCreateOrConnectWithoutPlayerInput
    upsert?: PlayerStatsUpsertWithoutPlayerInput
    disconnect?: PlayerStatsWhereInput | boolean
    delete?: PlayerStatsWhereInput | boolean
    connect?: PlayerStatsWhereUniqueInput
    update?: XOR<XOR<PlayerStatsUpdateToOneWithWhereWithoutPlayerInput, PlayerStatsUpdateWithoutPlayerInput>, PlayerStatsUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerEquipmentUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput> | PlayerEquipmentCreateWithoutPlayerInput[] | PlayerEquipmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutPlayerInput | PlayerEquipmentCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerEquipmentUpsertWithWhereUniqueWithoutPlayerInput | PlayerEquipmentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerEquipmentCreateManyPlayerInputEnvelope
    set?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    disconnect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    delete?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    update?: PlayerEquipmentUpdateWithWhereUniqueWithoutPlayerInput | PlayerEquipmentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerEquipmentUpdateManyWithWhereWithoutPlayerInput | PlayerEquipmentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
  }

  export type PlayerSkillUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput> | PlayerSkillCreateWithoutPlayerInput[] | PlayerSkillUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutPlayerInput | PlayerSkillCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerSkillUpsertWithWhereUniqueWithoutPlayerInput | PlayerSkillUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerSkillCreateManyPlayerInputEnvelope
    set?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    disconnect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    delete?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    update?: PlayerSkillUpdateWithWhereUniqueWithoutPlayerInput | PlayerSkillUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerSkillUpdateManyWithWhereWithoutPlayerInput | PlayerSkillUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerSkillScalarWhereInput | PlayerSkillScalarWhereInput[]
  }

  export type PlayerTalentUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerTalentCreateWithoutPlayerInput, PlayerTalentUncheckedCreateWithoutPlayerInput> | PlayerTalentCreateWithoutPlayerInput[] | PlayerTalentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerTalentCreateOrConnectWithoutPlayerInput | PlayerTalentCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerTalentUpsertWithWhereUniqueWithoutPlayerInput | PlayerTalentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerTalentCreateManyPlayerInputEnvelope
    set?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    disconnect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    delete?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    connect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    update?: PlayerTalentUpdateWithWhereUniqueWithoutPlayerInput | PlayerTalentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerTalentUpdateManyWithWhereWithoutPlayerInput | PlayerTalentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerTalentScalarWhereInput | PlayerTalentScalarWhereInput[]
  }

  export type PlayerBuffUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerBuffCreateWithoutPlayerInput, PlayerBuffUncheckedCreateWithoutPlayerInput> | PlayerBuffCreateWithoutPlayerInput[] | PlayerBuffUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerBuffCreateOrConnectWithoutPlayerInput | PlayerBuffCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerBuffUpsertWithWhereUniqueWithoutPlayerInput | PlayerBuffUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerBuffCreateManyPlayerInputEnvelope
    set?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    disconnect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    delete?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    connect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    update?: PlayerBuffUpdateWithWhereUniqueWithoutPlayerInput | PlayerBuffUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerBuffUpdateManyWithWhereWithoutPlayerInput | PlayerBuffUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerBuffScalarWhereInput | PlayerBuffScalarWhereInput[]
  }

  export type PurchaseHistoryUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PurchaseHistoryCreateWithoutPlayerInput, PurchaseHistoryUncheckedCreateWithoutPlayerInput> | PurchaseHistoryCreateWithoutPlayerInput[] | PurchaseHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutPlayerInput | PurchaseHistoryCreateOrConnectWithoutPlayerInput[]
    upsert?: PurchaseHistoryUpsertWithWhereUniqueWithoutPlayerInput | PurchaseHistoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PurchaseHistoryCreateManyPlayerInputEnvelope
    set?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    disconnect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    delete?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    update?: PurchaseHistoryUpdateWithWhereUniqueWithoutPlayerInput | PurchaseHistoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PurchaseHistoryUpdateManyWithWhereWithoutPlayerInput | PurchaseHistoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<InventoryCreateWithoutPlayerInput, InventoryUncheckedCreateWithoutPlayerInput> | InventoryCreateWithoutPlayerInput[] | InventoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutPlayerInput | InventoryCreateOrConnectWithoutPlayerInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutPlayerInput | InventoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: InventoryCreateManyPlayerInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutPlayerInput | InventoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutPlayerInput | InventoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type CraftingHistoryUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CraftingHistoryCreateWithoutPlayerInput, CraftingHistoryUncheckedCreateWithoutPlayerInput> | CraftingHistoryCreateWithoutPlayerInput[] | CraftingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CraftingHistoryCreateOrConnectWithoutPlayerInput | CraftingHistoryCreateOrConnectWithoutPlayerInput[]
    upsert?: CraftingHistoryUpsertWithWhereUniqueWithoutPlayerInput | CraftingHistoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CraftingHistoryCreateManyPlayerInputEnvelope
    set?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    disconnect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    delete?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    connect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    update?: CraftingHistoryUpdateWithWhereUniqueWithoutPlayerInput | CraftingHistoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CraftingHistoryUpdateManyWithWhereWithoutPlayerInput | CraftingHistoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CraftingHistoryScalarWhereInput | CraftingHistoryScalarWhereInput[]
  }

  export type PlayerFurnaceUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerFurnaceCreateWithoutPlayerInput, PlayerFurnaceUncheckedCreateWithoutPlayerInput> | PlayerFurnaceCreateWithoutPlayerInput[] | PlayerFurnaceUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerFurnaceCreateOrConnectWithoutPlayerInput | PlayerFurnaceCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerFurnaceUpsertWithWhereUniqueWithoutPlayerInput | PlayerFurnaceUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerFurnaceCreateManyPlayerInputEnvelope
    set?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    disconnect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    delete?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    connect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    update?: PlayerFurnaceUpdateWithWhereUniqueWithoutPlayerInput | PlayerFurnaceUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerFurnaceUpdateManyWithWhereWithoutPlayerInput | PlayerFurnaceUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerFurnaceScalarWhereInput | PlayerFurnaceScalarWhereInput[]
  }

  export type SpiritBeastUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<SpiritBeastCreateWithoutPlayerInput, SpiritBeastUncheckedCreateWithoutPlayerInput> | SpiritBeastCreateWithoutPlayerInput[] | SpiritBeastUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutPlayerInput | SpiritBeastCreateOrConnectWithoutPlayerInput[]
    upsert?: SpiritBeastUpsertWithWhereUniqueWithoutPlayerInput | SpiritBeastUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: SpiritBeastCreateManyPlayerInputEnvelope
    set?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    disconnect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    delete?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    connect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    update?: SpiritBeastUpdateWithWhereUniqueWithoutPlayerInput | SpiritBeastUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: SpiritBeastUpdateManyWithWhereWithoutPlayerInput | SpiritBeastUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: SpiritBeastScalarWhereInput | SpiritBeastScalarWhereInput[]
  }

  export type BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutPlayerInput, BeastFeedingHistoryUncheckedCreateWithoutPlayerInput> | BeastFeedingHistoryCreateWithoutPlayerInput[] | BeastFeedingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutPlayerInput | BeastFeedingHistoryCreateOrConnectWithoutPlayerInput[]
    upsert?: BeastFeedingHistoryUpsertWithWhereUniqueWithoutPlayerInput | BeastFeedingHistoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: BeastFeedingHistoryCreateManyPlayerInputEnvelope
    set?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    disconnect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    delete?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    update?: BeastFeedingHistoryUpdateWithWhereUniqueWithoutPlayerInput | BeastFeedingHistoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: BeastFeedingHistoryUpdateManyWithWhereWithoutPlayerInput | BeastFeedingHistoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: BeastFeedingHistoryScalarWhereInput | BeastFeedingHistoryScalarWhereInput[]
  }

  export type HuntingHistoryUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<HuntingHistoryCreateWithoutPlayerInput, HuntingHistoryUncheckedCreateWithoutPlayerInput> | HuntingHistoryCreateWithoutPlayerInput[] | HuntingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutPlayerInput | HuntingHistoryCreateOrConnectWithoutPlayerInput[]
    upsert?: HuntingHistoryUpsertWithWhereUniqueWithoutPlayerInput | HuntingHistoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: HuntingHistoryCreateManyPlayerInputEnvelope
    set?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    disconnect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    delete?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    update?: HuntingHistoryUpdateWithWhereUniqueWithoutPlayerInput | HuntingHistoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: HuntingHistoryUpdateManyWithWhereWithoutPlayerInput | HuntingHistoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: HuntingHistoryScalarWhereInput | HuntingHistoryScalarWhereInput[]
  }

  export type CultivationLogUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CultivationLogCreateWithoutPlayerInput, CultivationLogUncheckedCreateWithoutPlayerInput> | CultivationLogCreateWithoutPlayerInput[] | CultivationLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CultivationLogCreateOrConnectWithoutPlayerInput | CultivationLogCreateOrConnectWithoutPlayerInput[]
    upsert?: CultivationLogUpsertWithWhereUniqueWithoutPlayerInput | CultivationLogUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CultivationLogCreateManyPlayerInputEnvelope
    set?: CultivationLogWhereUniqueInput | CultivationLogWhereUniqueInput[]
    disconnect?: CultivationLogWhereUniqueInput | CultivationLogWhereUniqueInput[]
    delete?: CultivationLogWhereUniqueInput | CultivationLogWhereUniqueInput[]
    connect?: CultivationLogWhereUniqueInput | CultivationLogWhereUniqueInput[]
    update?: CultivationLogUpdateWithWhereUniqueWithoutPlayerInput | CultivationLogUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CultivationLogUpdateManyWithWhereWithoutPlayerInput | CultivationLogUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CultivationLogScalarWhereInput | CultivationLogScalarWhereInput[]
  }

  export type PlayerCultivationUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<PlayerCultivationCreateWithoutPlayerInput, PlayerCultivationUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerCultivationCreateOrConnectWithoutPlayerInput
    upsert?: PlayerCultivationUpsertWithoutPlayerInput
    disconnect?: PlayerCultivationWhereInput | boolean
    delete?: PlayerCultivationWhereInput | boolean
    connect?: PlayerCultivationWhereUniqueInput
    update?: XOR<XOR<PlayerCultivationUpdateToOneWithWhereWithoutPlayerInput, PlayerCultivationUpdateWithoutPlayerInput>, PlayerCultivationUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerResourceCreateWithoutPlayerInput, PlayerResourceUncheckedCreateWithoutPlayerInput> | PlayerResourceCreateWithoutPlayerInput[] | PlayerResourceUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerResourceCreateOrConnectWithoutPlayerInput | PlayerResourceCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerResourceUpsertWithWhereUniqueWithoutPlayerInput | PlayerResourceUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerResourceCreateManyPlayerInputEnvelope
    set?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    disconnect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    delete?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    connect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    update?: PlayerResourceUpdateWithWhereUniqueWithoutPlayerInput | PlayerResourceUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerResourceUpdateManyWithWhereWithoutPlayerInput | PlayerResourceUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerResourceScalarWhereInput | PlayerResourceScalarWhereInput[]
  }

  export type PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerCompanionCreateWithoutPlayerInput, PlayerCompanionUncheckedCreateWithoutPlayerInput> | PlayerCompanionCreateWithoutPlayerInput[] | PlayerCompanionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerCompanionCreateOrConnectWithoutPlayerInput | PlayerCompanionCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerCompanionUpsertWithWhereUniqueWithoutPlayerInput | PlayerCompanionUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerCompanionCreateManyPlayerInputEnvelope
    set?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    disconnect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    delete?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    connect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    update?: PlayerCompanionUpdateWithWhereUniqueWithoutPlayerInput | PlayerCompanionUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerCompanionUpdateManyWithWhereWithoutPlayerInput | PlayerCompanionUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerCompanionScalarWhereInput | PlayerCompanionScalarWhereInput[]
  }

  export type PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerAchievementCreateWithoutPlayerInput, PlayerAchievementUncheckedCreateWithoutPlayerInput> | PlayerAchievementCreateWithoutPlayerInput[] | PlayerAchievementUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerAchievementCreateOrConnectWithoutPlayerInput | PlayerAchievementCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerAchievementUpsertWithWhereUniqueWithoutPlayerInput | PlayerAchievementUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerAchievementCreateManyPlayerInputEnvelope
    set?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    disconnect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    delete?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    connect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    update?: PlayerAchievementUpdateWithWhereUniqueWithoutPlayerInput | PlayerAchievementUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerAchievementUpdateManyWithWhereWithoutPlayerInput | PlayerAchievementUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerAchievementScalarWhereInput | PlayerAchievementScalarWhereInput[]
  }

  export type PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerQuestCreateWithoutPlayerInput, PlayerQuestUncheckedCreateWithoutPlayerInput> | PlayerQuestCreateWithoutPlayerInput[] | PlayerQuestUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerQuestCreateOrConnectWithoutPlayerInput | PlayerQuestCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerQuestUpsertWithWhereUniqueWithoutPlayerInput | PlayerQuestUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerQuestCreateManyPlayerInputEnvelope
    set?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    disconnect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    delete?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    connect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    update?: PlayerQuestUpdateWithWhereUniqueWithoutPlayerInput | PlayerQuestUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerQuestUpdateManyWithWhereWithoutPlayerInput | PlayerQuestUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerQuestScalarWhereInput | PlayerQuestScalarWhereInput[]
  }

  export type PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerStatsCreateOrConnectWithoutPlayerInput
    upsert?: PlayerStatsUpsertWithoutPlayerInput
    disconnect?: PlayerStatsWhereInput | boolean
    delete?: PlayerStatsWhereInput | boolean
    connect?: PlayerStatsWhereUniqueInput
    update?: XOR<XOR<PlayerStatsUpdateToOneWithWhereWithoutPlayerInput, PlayerStatsUpdateWithoutPlayerInput>, PlayerStatsUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput> | PlayerEquipmentCreateWithoutPlayerInput[] | PlayerEquipmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutPlayerInput | PlayerEquipmentCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerEquipmentUpsertWithWhereUniqueWithoutPlayerInput | PlayerEquipmentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerEquipmentCreateManyPlayerInputEnvelope
    set?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    disconnect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    delete?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    update?: PlayerEquipmentUpdateWithWhereUniqueWithoutPlayerInput | PlayerEquipmentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerEquipmentUpdateManyWithWhereWithoutPlayerInput | PlayerEquipmentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
  }

  export type PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput> | PlayerSkillCreateWithoutPlayerInput[] | PlayerSkillUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutPlayerInput | PlayerSkillCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerSkillUpsertWithWhereUniqueWithoutPlayerInput | PlayerSkillUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerSkillCreateManyPlayerInputEnvelope
    set?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    disconnect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    delete?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    update?: PlayerSkillUpdateWithWhereUniqueWithoutPlayerInput | PlayerSkillUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerSkillUpdateManyWithWhereWithoutPlayerInput | PlayerSkillUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerSkillScalarWhereInput | PlayerSkillScalarWhereInput[]
  }

  export type PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerTalentCreateWithoutPlayerInput, PlayerTalentUncheckedCreateWithoutPlayerInput> | PlayerTalentCreateWithoutPlayerInput[] | PlayerTalentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerTalentCreateOrConnectWithoutPlayerInput | PlayerTalentCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerTalentUpsertWithWhereUniqueWithoutPlayerInput | PlayerTalentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerTalentCreateManyPlayerInputEnvelope
    set?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    disconnect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    delete?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    connect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    update?: PlayerTalentUpdateWithWhereUniqueWithoutPlayerInput | PlayerTalentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerTalentUpdateManyWithWhereWithoutPlayerInput | PlayerTalentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerTalentScalarWhereInput | PlayerTalentScalarWhereInput[]
  }

  export type PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerBuffCreateWithoutPlayerInput, PlayerBuffUncheckedCreateWithoutPlayerInput> | PlayerBuffCreateWithoutPlayerInput[] | PlayerBuffUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerBuffCreateOrConnectWithoutPlayerInput | PlayerBuffCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerBuffUpsertWithWhereUniqueWithoutPlayerInput | PlayerBuffUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerBuffCreateManyPlayerInputEnvelope
    set?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    disconnect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    delete?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    connect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    update?: PlayerBuffUpdateWithWhereUniqueWithoutPlayerInput | PlayerBuffUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerBuffUpdateManyWithWhereWithoutPlayerInput | PlayerBuffUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerBuffScalarWhereInput | PlayerBuffScalarWhereInput[]
  }

  export type PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PurchaseHistoryCreateWithoutPlayerInput, PurchaseHistoryUncheckedCreateWithoutPlayerInput> | PurchaseHistoryCreateWithoutPlayerInput[] | PurchaseHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutPlayerInput | PurchaseHistoryCreateOrConnectWithoutPlayerInput[]
    upsert?: PurchaseHistoryUpsertWithWhereUniqueWithoutPlayerInput | PurchaseHistoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PurchaseHistoryCreateManyPlayerInputEnvelope
    set?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    disconnect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    delete?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    update?: PurchaseHistoryUpdateWithWhereUniqueWithoutPlayerInput | PurchaseHistoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PurchaseHistoryUpdateManyWithWhereWithoutPlayerInput | PurchaseHistoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<InventoryCreateWithoutPlayerInput, InventoryUncheckedCreateWithoutPlayerInput> | InventoryCreateWithoutPlayerInput[] | InventoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutPlayerInput | InventoryCreateOrConnectWithoutPlayerInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutPlayerInput | InventoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: InventoryCreateManyPlayerInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutPlayerInput | InventoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutPlayerInput | InventoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CraftingHistoryCreateWithoutPlayerInput, CraftingHistoryUncheckedCreateWithoutPlayerInput> | CraftingHistoryCreateWithoutPlayerInput[] | CraftingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CraftingHistoryCreateOrConnectWithoutPlayerInput | CraftingHistoryCreateOrConnectWithoutPlayerInput[]
    upsert?: CraftingHistoryUpsertWithWhereUniqueWithoutPlayerInput | CraftingHistoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CraftingHistoryCreateManyPlayerInputEnvelope
    set?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    disconnect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    delete?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    connect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    update?: CraftingHistoryUpdateWithWhereUniqueWithoutPlayerInput | CraftingHistoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CraftingHistoryUpdateManyWithWhereWithoutPlayerInput | CraftingHistoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CraftingHistoryScalarWhereInput | CraftingHistoryScalarWhereInput[]
  }

  export type PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerFurnaceCreateWithoutPlayerInput, PlayerFurnaceUncheckedCreateWithoutPlayerInput> | PlayerFurnaceCreateWithoutPlayerInput[] | PlayerFurnaceUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerFurnaceCreateOrConnectWithoutPlayerInput | PlayerFurnaceCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerFurnaceUpsertWithWhereUniqueWithoutPlayerInput | PlayerFurnaceUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerFurnaceCreateManyPlayerInputEnvelope
    set?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    disconnect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    delete?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    connect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    update?: PlayerFurnaceUpdateWithWhereUniqueWithoutPlayerInput | PlayerFurnaceUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerFurnaceUpdateManyWithWhereWithoutPlayerInput | PlayerFurnaceUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerFurnaceScalarWhereInput | PlayerFurnaceScalarWhereInput[]
  }

  export type SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<SpiritBeastCreateWithoutPlayerInput, SpiritBeastUncheckedCreateWithoutPlayerInput> | SpiritBeastCreateWithoutPlayerInput[] | SpiritBeastUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutPlayerInput | SpiritBeastCreateOrConnectWithoutPlayerInput[]
    upsert?: SpiritBeastUpsertWithWhereUniqueWithoutPlayerInput | SpiritBeastUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: SpiritBeastCreateManyPlayerInputEnvelope
    set?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    disconnect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    delete?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    connect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    update?: SpiritBeastUpdateWithWhereUniqueWithoutPlayerInput | SpiritBeastUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: SpiritBeastUpdateManyWithWhereWithoutPlayerInput | SpiritBeastUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: SpiritBeastScalarWhereInput | SpiritBeastScalarWhereInput[]
  }

  export type BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutPlayerInput, BeastFeedingHistoryUncheckedCreateWithoutPlayerInput> | BeastFeedingHistoryCreateWithoutPlayerInput[] | BeastFeedingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutPlayerInput | BeastFeedingHistoryCreateOrConnectWithoutPlayerInput[]
    upsert?: BeastFeedingHistoryUpsertWithWhereUniqueWithoutPlayerInput | BeastFeedingHistoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: BeastFeedingHistoryCreateManyPlayerInputEnvelope
    set?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    disconnect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    delete?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    update?: BeastFeedingHistoryUpdateWithWhereUniqueWithoutPlayerInput | BeastFeedingHistoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: BeastFeedingHistoryUpdateManyWithWhereWithoutPlayerInput | BeastFeedingHistoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: BeastFeedingHistoryScalarWhereInput | BeastFeedingHistoryScalarWhereInput[]
  }

  export type HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<HuntingHistoryCreateWithoutPlayerInput, HuntingHistoryUncheckedCreateWithoutPlayerInput> | HuntingHistoryCreateWithoutPlayerInput[] | HuntingHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutPlayerInput | HuntingHistoryCreateOrConnectWithoutPlayerInput[]
    upsert?: HuntingHistoryUpsertWithWhereUniqueWithoutPlayerInput | HuntingHistoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: HuntingHistoryCreateManyPlayerInputEnvelope
    set?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    disconnect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    delete?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    update?: HuntingHistoryUpdateWithWhereUniqueWithoutPlayerInput | HuntingHistoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: HuntingHistoryUpdateManyWithWhereWithoutPlayerInput | HuntingHistoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: HuntingHistoryScalarWhereInput | HuntingHistoryScalarWhereInput[]
  }

  export type CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CultivationLogCreateWithoutPlayerInput, CultivationLogUncheckedCreateWithoutPlayerInput> | CultivationLogCreateWithoutPlayerInput[] | CultivationLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CultivationLogCreateOrConnectWithoutPlayerInput | CultivationLogCreateOrConnectWithoutPlayerInput[]
    upsert?: CultivationLogUpsertWithWhereUniqueWithoutPlayerInput | CultivationLogUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CultivationLogCreateManyPlayerInputEnvelope
    set?: CultivationLogWhereUniqueInput | CultivationLogWhereUniqueInput[]
    disconnect?: CultivationLogWhereUniqueInput | CultivationLogWhereUniqueInput[]
    delete?: CultivationLogWhereUniqueInput | CultivationLogWhereUniqueInput[]
    connect?: CultivationLogWhereUniqueInput | CultivationLogWhereUniqueInput[]
    update?: CultivationLogUpdateWithWhereUniqueWithoutPlayerInput | CultivationLogUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CultivationLogUpdateManyWithWhereWithoutPlayerInput | CultivationLogUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CultivationLogScalarWhereInput | CultivationLogScalarWhereInput[]
  }

  export type PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<PlayerCultivationCreateWithoutPlayerInput, PlayerCultivationUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerCultivationCreateOrConnectWithoutPlayerInput
    upsert?: PlayerCultivationUpsertWithoutPlayerInput
    disconnect?: PlayerCultivationWhereInput | boolean
    delete?: PlayerCultivationWhereInput | boolean
    connect?: PlayerCultivationWhereUniqueInput
    update?: XOR<XOR<PlayerCultivationUpdateToOneWithWhereWithoutPlayerInput, PlayerCultivationUpdateWithoutPlayerInput>, PlayerCultivationUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerResourceCreateNestedManyWithoutResourceInput = {
    create?: XOR<PlayerResourceCreateWithoutResourceInput, PlayerResourceUncheckedCreateWithoutResourceInput> | PlayerResourceCreateWithoutResourceInput[] | PlayerResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PlayerResourceCreateOrConnectWithoutResourceInput | PlayerResourceCreateOrConnectWithoutResourceInput[]
    createMany?: PlayerResourceCreateManyResourceInputEnvelope
    connect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
  }

  export type PlayerResourceUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<PlayerResourceCreateWithoutResourceInput, PlayerResourceUncheckedCreateWithoutResourceInput> | PlayerResourceCreateWithoutResourceInput[] | PlayerResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PlayerResourceCreateOrConnectWithoutResourceInput | PlayerResourceCreateOrConnectWithoutResourceInput[]
    createMany?: PlayerResourceCreateManyResourceInputEnvelope
    connect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PlayerResourceUpdateManyWithoutResourceNestedInput = {
    create?: XOR<PlayerResourceCreateWithoutResourceInput, PlayerResourceUncheckedCreateWithoutResourceInput> | PlayerResourceCreateWithoutResourceInput[] | PlayerResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PlayerResourceCreateOrConnectWithoutResourceInput | PlayerResourceCreateOrConnectWithoutResourceInput[]
    upsert?: PlayerResourceUpsertWithWhereUniqueWithoutResourceInput | PlayerResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: PlayerResourceCreateManyResourceInputEnvelope
    set?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    disconnect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    delete?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    connect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    update?: PlayerResourceUpdateWithWhereUniqueWithoutResourceInput | PlayerResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: PlayerResourceUpdateManyWithWhereWithoutResourceInput | PlayerResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: PlayerResourceScalarWhereInput | PlayerResourceScalarWhereInput[]
  }

  export type PlayerResourceUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<PlayerResourceCreateWithoutResourceInput, PlayerResourceUncheckedCreateWithoutResourceInput> | PlayerResourceCreateWithoutResourceInput[] | PlayerResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PlayerResourceCreateOrConnectWithoutResourceInput | PlayerResourceCreateOrConnectWithoutResourceInput[]
    upsert?: PlayerResourceUpsertWithWhereUniqueWithoutResourceInput | PlayerResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: PlayerResourceCreateManyResourceInputEnvelope
    set?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    disconnect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    delete?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    connect?: PlayerResourceWhereUniqueInput | PlayerResourceWhereUniqueInput[]
    update?: PlayerResourceUpdateWithWhereUniqueWithoutResourceInput | PlayerResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: PlayerResourceUpdateManyWithWhereWithoutResourceInput | PlayerResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: PlayerResourceScalarWhereInput | PlayerResourceScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutResourcesInput = {
    create?: XOR<PlayerCreateWithoutResourcesInput, PlayerUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutResourcesInput
    connect?: PlayerWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutPlayerResourcesInput = {
    create?: XOR<ResourceCreateWithoutPlayerResourcesInput, ResourceUncheckedCreateWithoutPlayerResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutPlayerResourcesInput
    connect?: ResourceWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PlayerUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<PlayerCreateWithoutResourcesInput, PlayerUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutResourcesInput
    upsert?: PlayerUpsertWithoutResourcesInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutResourcesInput, PlayerUpdateWithoutResourcesInput>, PlayerUncheckedUpdateWithoutResourcesInput>
  }

  export type ResourceUpdateOneRequiredWithoutPlayerResourcesNestedInput = {
    create?: XOR<ResourceCreateWithoutPlayerResourcesInput, ResourceUncheckedCreateWithoutPlayerResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutPlayerResourcesInput
    upsert?: ResourceUpsertWithoutPlayerResourcesInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutPlayerResourcesInput, ResourceUpdateWithoutPlayerResourcesInput>, ResourceUncheckedUpdateWithoutPlayerResourcesInput>
  }

  export type PlayerCompanionCreateNestedManyWithoutCompanionInput = {
    create?: XOR<PlayerCompanionCreateWithoutCompanionInput, PlayerCompanionUncheckedCreateWithoutCompanionInput> | PlayerCompanionCreateWithoutCompanionInput[] | PlayerCompanionUncheckedCreateWithoutCompanionInput[]
    connectOrCreate?: PlayerCompanionCreateOrConnectWithoutCompanionInput | PlayerCompanionCreateOrConnectWithoutCompanionInput[]
    createMany?: PlayerCompanionCreateManyCompanionInputEnvelope
    connect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
  }

  export type PlayerCompanionUncheckedCreateNestedManyWithoutCompanionInput = {
    create?: XOR<PlayerCompanionCreateWithoutCompanionInput, PlayerCompanionUncheckedCreateWithoutCompanionInput> | PlayerCompanionCreateWithoutCompanionInput[] | PlayerCompanionUncheckedCreateWithoutCompanionInput[]
    connectOrCreate?: PlayerCompanionCreateOrConnectWithoutCompanionInput | PlayerCompanionCreateOrConnectWithoutCompanionInput[]
    createMany?: PlayerCompanionCreateManyCompanionInputEnvelope
    connect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
  }

  export type PlayerCompanionUpdateManyWithoutCompanionNestedInput = {
    create?: XOR<PlayerCompanionCreateWithoutCompanionInput, PlayerCompanionUncheckedCreateWithoutCompanionInput> | PlayerCompanionCreateWithoutCompanionInput[] | PlayerCompanionUncheckedCreateWithoutCompanionInput[]
    connectOrCreate?: PlayerCompanionCreateOrConnectWithoutCompanionInput | PlayerCompanionCreateOrConnectWithoutCompanionInput[]
    upsert?: PlayerCompanionUpsertWithWhereUniqueWithoutCompanionInput | PlayerCompanionUpsertWithWhereUniqueWithoutCompanionInput[]
    createMany?: PlayerCompanionCreateManyCompanionInputEnvelope
    set?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    disconnect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    delete?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    connect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    update?: PlayerCompanionUpdateWithWhereUniqueWithoutCompanionInput | PlayerCompanionUpdateWithWhereUniqueWithoutCompanionInput[]
    updateMany?: PlayerCompanionUpdateManyWithWhereWithoutCompanionInput | PlayerCompanionUpdateManyWithWhereWithoutCompanionInput[]
    deleteMany?: PlayerCompanionScalarWhereInput | PlayerCompanionScalarWhereInput[]
  }

  export type PlayerCompanionUncheckedUpdateManyWithoutCompanionNestedInput = {
    create?: XOR<PlayerCompanionCreateWithoutCompanionInput, PlayerCompanionUncheckedCreateWithoutCompanionInput> | PlayerCompanionCreateWithoutCompanionInput[] | PlayerCompanionUncheckedCreateWithoutCompanionInput[]
    connectOrCreate?: PlayerCompanionCreateOrConnectWithoutCompanionInput | PlayerCompanionCreateOrConnectWithoutCompanionInput[]
    upsert?: PlayerCompanionUpsertWithWhereUniqueWithoutCompanionInput | PlayerCompanionUpsertWithWhereUniqueWithoutCompanionInput[]
    createMany?: PlayerCompanionCreateManyCompanionInputEnvelope
    set?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    disconnect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    delete?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    connect?: PlayerCompanionWhereUniqueInput | PlayerCompanionWhereUniqueInput[]
    update?: PlayerCompanionUpdateWithWhereUniqueWithoutCompanionInput | PlayerCompanionUpdateWithWhereUniqueWithoutCompanionInput[]
    updateMany?: PlayerCompanionUpdateManyWithWhereWithoutCompanionInput | PlayerCompanionUpdateManyWithWhereWithoutCompanionInput[]
    deleteMany?: PlayerCompanionScalarWhereInput | PlayerCompanionScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutCompanionsInput = {
    create?: XOR<PlayerCreateWithoutCompanionsInput, PlayerUncheckedCreateWithoutCompanionsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCompanionsInput
    connect?: PlayerWhereUniqueInput
  }

  export type CompanionCreateNestedOneWithoutPlayerCompanionsInput = {
    create?: XOR<CompanionCreateWithoutPlayerCompanionsInput, CompanionUncheckedCreateWithoutPlayerCompanionsInput>
    connectOrCreate?: CompanionCreateOrConnectWithoutPlayerCompanionsInput
    connect?: CompanionWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PlayerUpdateOneRequiredWithoutCompanionsNestedInput = {
    create?: XOR<PlayerCreateWithoutCompanionsInput, PlayerUncheckedCreateWithoutCompanionsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCompanionsInput
    upsert?: PlayerUpsertWithoutCompanionsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutCompanionsInput, PlayerUpdateWithoutCompanionsInput>, PlayerUncheckedUpdateWithoutCompanionsInput>
  }

  export type CompanionUpdateOneRequiredWithoutPlayerCompanionsNestedInput = {
    create?: XOR<CompanionCreateWithoutPlayerCompanionsInput, CompanionUncheckedCreateWithoutPlayerCompanionsInput>
    connectOrCreate?: CompanionCreateOrConnectWithoutPlayerCompanionsInput
    upsert?: CompanionUpsertWithoutPlayerCompanionsInput
    connect?: CompanionWhereUniqueInput
    update?: XOR<XOR<CompanionUpdateToOneWithWhereWithoutPlayerCompanionsInput, CompanionUpdateWithoutPlayerCompanionsInput>, CompanionUncheckedUpdateWithoutPlayerCompanionsInput>
  }

  export type PlayerAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<PlayerAchievementCreateWithoutAchievementInput, PlayerAchievementUncheckedCreateWithoutAchievementInput> | PlayerAchievementCreateWithoutAchievementInput[] | PlayerAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: PlayerAchievementCreateOrConnectWithoutAchievementInput | PlayerAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: PlayerAchievementCreateManyAchievementInputEnvelope
    connect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
  }

  export type PlayerAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<PlayerAchievementCreateWithoutAchievementInput, PlayerAchievementUncheckedCreateWithoutAchievementInput> | PlayerAchievementCreateWithoutAchievementInput[] | PlayerAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: PlayerAchievementCreateOrConnectWithoutAchievementInput | PlayerAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: PlayerAchievementCreateManyAchievementInputEnvelope
    connect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
  }

  export type PlayerAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<PlayerAchievementCreateWithoutAchievementInput, PlayerAchievementUncheckedCreateWithoutAchievementInput> | PlayerAchievementCreateWithoutAchievementInput[] | PlayerAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: PlayerAchievementCreateOrConnectWithoutAchievementInput | PlayerAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: PlayerAchievementUpsertWithWhereUniqueWithoutAchievementInput | PlayerAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: PlayerAchievementCreateManyAchievementInputEnvelope
    set?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    disconnect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    delete?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    connect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    update?: PlayerAchievementUpdateWithWhereUniqueWithoutAchievementInput | PlayerAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: PlayerAchievementUpdateManyWithWhereWithoutAchievementInput | PlayerAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: PlayerAchievementScalarWhereInput | PlayerAchievementScalarWhereInput[]
  }

  export type PlayerAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<PlayerAchievementCreateWithoutAchievementInput, PlayerAchievementUncheckedCreateWithoutAchievementInput> | PlayerAchievementCreateWithoutAchievementInput[] | PlayerAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: PlayerAchievementCreateOrConnectWithoutAchievementInput | PlayerAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: PlayerAchievementUpsertWithWhereUniqueWithoutAchievementInput | PlayerAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: PlayerAchievementCreateManyAchievementInputEnvelope
    set?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    disconnect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    delete?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    connect?: PlayerAchievementWhereUniqueInput | PlayerAchievementWhereUniqueInput[]
    update?: PlayerAchievementUpdateWithWhereUniqueWithoutAchievementInput | PlayerAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: PlayerAchievementUpdateManyWithWhereWithoutAchievementInput | PlayerAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: PlayerAchievementScalarWhereInput | PlayerAchievementScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<PlayerCreateWithoutAchievementsInput, PlayerUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutAchievementsInput
    connect?: PlayerWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutPlayerAchievementsInput = {
    create?: XOR<AchievementCreateWithoutPlayerAchievementsInput, AchievementUncheckedCreateWithoutPlayerAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutPlayerAchievementsInput
    connect?: AchievementWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<PlayerCreateWithoutAchievementsInput, PlayerUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutAchievementsInput
    upsert?: PlayerUpsertWithoutAchievementsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutAchievementsInput, PlayerUpdateWithoutAchievementsInput>, PlayerUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutPlayerAchievementsNestedInput = {
    create?: XOR<AchievementCreateWithoutPlayerAchievementsInput, AchievementUncheckedCreateWithoutPlayerAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutPlayerAchievementsInput
    upsert?: AchievementUpsertWithoutPlayerAchievementsInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutPlayerAchievementsInput, AchievementUpdateWithoutPlayerAchievementsInput>, AchievementUncheckedUpdateWithoutPlayerAchievementsInput>
  }

  export type PlayerQuestCreateNestedManyWithoutQuestInput = {
    create?: XOR<PlayerQuestCreateWithoutQuestInput, PlayerQuestUncheckedCreateWithoutQuestInput> | PlayerQuestCreateWithoutQuestInput[] | PlayerQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: PlayerQuestCreateOrConnectWithoutQuestInput | PlayerQuestCreateOrConnectWithoutQuestInput[]
    createMany?: PlayerQuestCreateManyQuestInputEnvelope
    connect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
  }

  export type PlayerQuestUncheckedCreateNestedManyWithoutQuestInput = {
    create?: XOR<PlayerQuestCreateWithoutQuestInput, PlayerQuestUncheckedCreateWithoutQuestInput> | PlayerQuestCreateWithoutQuestInput[] | PlayerQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: PlayerQuestCreateOrConnectWithoutQuestInput | PlayerQuestCreateOrConnectWithoutQuestInput[]
    createMany?: PlayerQuestCreateManyQuestInputEnvelope
    connect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlayerQuestUpdateManyWithoutQuestNestedInput = {
    create?: XOR<PlayerQuestCreateWithoutQuestInput, PlayerQuestUncheckedCreateWithoutQuestInput> | PlayerQuestCreateWithoutQuestInput[] | PlayerQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: PlayerQuestCreateOrConnectWithoutQuestInput | PlayerQuestCreateOrConnectWithoutQuestInput[]
    upsert?: PlayerQuestUpsertWithWhereUniqueWithoutQuestInput | PlayerQuestUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: PlayerQuestCreateManyQuestInputEnvelope
    set?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    disconnect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    delete?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    connect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    update?: PlayerQuestUpdateWithWhereUniqueWithoutQuestInput | PlayerQuestUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: PlayerQuestUpdateManyWithWhereWithoutQuestInput | PlayerQuestUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: PlayerQuestScalarWhereInput | PlayerQuestScalarWhereInput[]
  }

  export type PlayerQuestUncheckedUpdateManyWithoutQuestNestedInput = {
    create?: XOR<PlayerQuestCreateWithoutQuestInput, PlayerQuestUncheckedCreateWithoutQuestInput> | PlayerQuestCreateWithoutQuestInput[] | PlayerQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: PlayerQuestCreateOrConnectWithoutQuestInput | PlayerQuestCreateOrConnectWithoutQuestInput[]
    upsert?: PlayerQuestUpsertWithWhereUniqueWithoutQuestInput | PlayerQuestUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: PlayerQuestCreateManyQuestInputEnvelope
    set?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    disconnect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    delete?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    connect?: PlayerQuestWhereUniqueInput | PlayerQuestWhereUniqueInput[]
    update?: PlayerQuestUpdateWithWhereUniqueWithoutQuestInput | PlayerQuestUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: PlayerQuestUpdateManyWithWhereWithoutQuestInput | PlayerQuestUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: PlayerQuestScalarWhereInput | PlayerQuestScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutQuestsInput = {
    create?: XOR<PlayerCreateWithoutQuestsInput, PlayerUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutQuestsInput
    connect?: PlayerWhereUniqueInput
  }

  export type QuestCreateNestedOneWithoutPlayerQuestsInput = {
    create?: XOR<QuestCreateWithoutPlayerQuestsInput, QuestUncheckedCreateWithoutPlayerQuestsInput>
    connectOrCreate?: QuestCreateOrConnectWithoutPlayerQuestsInput
    connect?: QuestWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PlayerUpdateOneRequiredWithoutQuestsNestedInput = {
    create?: XOR<PlayerCreateWithoutQuestsInput, PlayerUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutQuestsInput
    upsert?: PlayerUpsertWithoutQuestsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutQuestsInput, PlayerUpdateWithoutQuestsInput>, PlayerUncheckedUpdateWithoutQuestsInput>
  }

  export type QuestUpdateOneRequiredWithoutPlayerQuestsNestedInput = {
    create?: XOR<QuestCreateWithoutPlayerQuestsInput, QuestUncheckedCreateWithoutPlayerQuestsInput>
    connectOrCreate?: QuestCreateOrConnectWithoutPlayerQuestsInput
    upsert?: QuestUpsertWithoutPlayerQuestsInput
    connect?: QuestWhereUniqueInput
    update?: XOR<XOR<QuestUpdateToOneWithWhereWithoutPlayerQuestsInput, QuestUpdateWithoutPlayerQuestsInput>, QuestUncheckedUpdateWithoutPlayerQuestsInput>
  }

  export type PlayerCreateNestedOneWithoutStatsInput = {
    create?: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutStatsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutStatsInput
    upsert?: PlayerUpsertWithoutStatsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutStatsInput, PlayerUpdateWithoutStatsInput>, PlayerUncheckedUpdateWithoutStatsInput>
  }

  export type EquipmentCreateNestedManyWithoutTypeInput = {
    create?: XOR<EquipmentCreateWithoutTypeInput, EquipmentUncheckedCreateWithoutTypeInput> | EquipmentCreateWithoutTypeInput[] | EquipmentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutTypeInput | EquipmentCreateOrConnectWithoutTypeInput[]
    createMany?: EquipmentCreateManyTypeInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<EquipmentCreateWithoutTypeInput, EquipmentUncheckedCreateWithoutTypeInput> | EquipmentCreateWithoutTypeInput[] | EquipmentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutTypeInput | EquipmentCreateOrConnectWithoutTypeInput[]
    createMany?: EquipmentCreateManyTypeInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentUpdateManyWithoutTypeNestedInput = {
    create?: XOR<EquipmentCreateWithoutTypeInput, EquipmentUncheckedCreateWithoutTypeInput> | EquipmentCreateWithoutTypeInput[] | EquipmentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutTypeInput | EquipmentCreateOrConnectWithoutTypeInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutTypeInput | EquipmentUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: EquipmentCreateManyTypeInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutTypeInput | EquipmentUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutTypeInput | EquipmentUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<EquipmentCreateWithoutTypeInput, EquipmentUncheckedCreateWithoutTypeInput> | EquipmentCreateWithoutTypeInput[] | EquipmentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutTypeInput | EquipmentCreateOrConnectWithoutTypeInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutTypeInput | EquipmentUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: EquipmentCreateManyTypeInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutTypeInput | EquipmentUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutTypeInput | EquipmentUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentTypeCreateNestedOneWithoutEquipmentsInput = {
    create?: XOR<EquipmentTypeCreateWithoutEquipmentsInput, EquipmentTypeUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: EquipmentTypeCreateOrConnectWithoutEquipmentsInput
    connect?: EquipmentTypeWhereUniqueInput
  }

  export type PlayerEquipmentCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<PlayerEquipmentCreateWithoutEquipmentInput, PlayerEquipmentUncheckedCreateWithoutEquipmentInput> | PlayerEquipmentCreateWithoutEquipmentInput[] | PlayerEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutEquipmentInput | PlayerEquipmentCreateOrConnectWithoutEquipmentInput[]
    createMany?: PlayerEquipmentCreateManyEquipmentInputEnvelope
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
  }

  export type PlayerEquipmentUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<PlayerEquipmentCreateWithoutEquipmentInput, PlayerEquipmentUncheckedCreateWithoutEquipmentInput> | PlayerEquipmentCreateWithoutEquipmentInput[] | PlayerEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutEquipmentInput | PlayerEquipmentCreateOrConnectWithoutEquipmentInput[]
    createMany?: PlayerEquipmentCreateManyEquipmentInputEnvelope
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
  }

  export type EquipmentTypeUpdateOneRequiredWithoutEquipmentsNestedInput = {
    create?: XOR<EquipmentTypeCreateWithoutEquipmentsInput, EquipmentTypeUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: EquipmentTypeCreateOrConnectWithoutEquipmentsInput
    upsert?: EquipmentTypeUpsertWithoutEquipmentsInput
    connect?: EquipmentTypeWhereUniqueInput
    update?: XOR<XOR<EquipmentTypeUpdateToOneWithWhereWithoutEquipmentsInput, EquipmentTypeUpdateWithoutEquipmentsInput>, EquipmentTypeUncheckedUpdateWithoutEquipmentsInput>
  }

  export type PlayerEquipmentUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<PlayerEquipmentCreateWithoutEquipmentInput, PlayerEquipmentUncheckedCreateWithoutEquipmentInput> | PlayerEquipmentCreateWithoutEquipmentInput[] | PlayerEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutEquipmentInput | PlayerEquipmentCreateOrConnectWithoutEquipmentInput[]
    upsert?: PlayerEquipmentUpsertWithWhereUniqueWithoutEquipmentInput | PlayerEquipmentUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: PlayerEquipmentCreateManyEquipmentInputEnvelope
    set?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    disconnect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    delete?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    update?: PlayerEquipmentUpdateWithWhereUniqueWithoutEquipmentInput | PlayerEquipmentUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: PlayerEquipmentUpdateManyWithWhereWithoutEquipmentInput | PlayerEquipmentUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
  }

  export type PlayerEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<PlayerEquipmentCreateWithoutEquipmentInput, PlayerEquipmentUncheckedCreateWithoutEquipmentInput> | PlayerEquipmentCreateWithoutEquipmentInput[] | PlayerEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutEquipmentInput | PlayerEquipmentCreateOrConnectWithoutEquipmentInput[]
    upsert?: PlayerEquipmentUpsertWithWhereUniqueWithoutEquipmentInput | PlayerEquipmentUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: PlayerEquipmentCreateManyEquipmentInputEnvelope
    set?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    disconnect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    delete?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    update?: PlayerEquipmentUpdateWithWhereUniqueWithoutEquipmentInput | PlayerEquipmentUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: PlayerEquipmentUpdateManyWithWhereWithoutEquipmentInput | PlayerEquipmentUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutEquipmentsInput = {
    create?: XOR<PlayerCreateWithoutEquipmentsInput, PlayerUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutEquipmentsInput
    connect?: PlayerWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutPlayerEquipmentsInput = {
    create?: XOR<EquipmentCreateWithoutPlayerEquipmentsInput, EquipmentUncheckedCreateWithoutPlayerEquipmentsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutPlayerEquipmentsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutEquipmentsNestedInput = {
    create?: XOR<PlayerCreateWithoutEquipmentsInput, PlayerUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutEquipmentsInput
    upsert?: PlayerUpsertWithoutEquipmentsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutEquipmentsInput, PlayerUpdateWithoutEquipmentsInput>, PlayerUncheckedUpdateWithoutEquipmentsInput>
  }

  export type EquipmentUpdateOneRequiredWithoutPlayerEquipmentsNestedInput = {
    create?: XOR<EquipmentCreateWithoutPlayerEquipmentsInput, EquipmentUncheckedCreateWithoutPlayerEquipmentsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutPlayerEquipmentsInput
    upsert?: EquipmentUpsertWithoutPlayerEquipmentsInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutPlayerEquipmentsInput, EquipmentUpdateWithoutPlayerEquipmentsInput>, EquipmentUncheckedUpdateWithoutPlayerEquipmentsInput>
  }

  export type PlayerSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<PlayerSkillCreateWithoutSkillInput, PlayerSkillUncheckedCreateWithoutSkillInput> | PlayerSkillCreateWithoutSkillInput[] | PlayerSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutSkillInput | PlayerSkillCreateOrConnectWithoutSkillInput[]
    createMany?: PlayerSkillCreateManySkillInputEnvelope
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
  }

  export type PlayerSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<PlayerSkillCreateWithoutSkillInput, PlayerSkillUncheckedCreateWithoutSkillInput> | PlayerSkillCreateWithoutSkillInput[] | PlayerSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutSkillInput | PlayerSkillCreateOrConnectWithoutSkillInput[]
    createMany?: PlayerSkillCreateManySkillInputEnvelope
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
  }

  export type PlayerSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<PlayerSkillCreateWithoutSkillInput, PlayerSkillUncheckedCreateWithoutSkillInput> | PlayerSkillCreateWithoutSkillInput[] | PlayerSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutSkillInput | PlayerSkillCreateOrConnectWithoutSkillInput[]
    upsert?: PlayerSkillUpsertWithWhereUniqueWithoutSkillInput | PlayerSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: PlayerSkillCreateManySkillInputEnvelope
    set?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    disconnect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    delete?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    update?: PlayerSkillUpdateWithWhereUniqueWithoutSkillInput | PlayerSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: PlayerSkillUpdateManyWithWhereWithoutSkillInput | PlayerSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: PlayerSkillScalarWhereInput | PlayerSkillScalarWhereInput[]
  }

  export type PlayerSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<PlayerSkillCreateWithoutSkillInput, PlayerSkillUncheckedCreateWithoutSkillInput> | PlayerSkillCreateWithoutSkillInput[] | PlayerSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutSkillInput | PlayerSkillCreateOrConnectWithoutSkillInput[]
    upsert?: PlayerSkillUpsertWithWhereUniqueWithoutSkillInput | PlayerSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: PlayerSkillCreateManySkillInputEnvelope
    set?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    disconnect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    delete?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    update?: PlayerSkillUpdateWithWhereUniqueWithoutSkillInput | PlayerSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: PlayerSkillUpdateManyWithWhereWithoutSkillInput | PlayerSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: PlayerSkillScalarWhereInput | PlayerSkillScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutSkillsInput = {
    create?: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSkillsInput
    connect?: PlayerWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutPlayerSkillsInput = {
    create?: XOR<SkillCreateWithoutPlayerSkillsInput, SkillUncheckedCreateWithoutPlayerSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutPlayerSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSkillsInput
    upsert?: PlayerUpsertWithoutSkillsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutSkillsInput, PlayerUpdateWithoutSkillsInput>, PlayerUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutPlayerSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutPlayerSkillsInput, SkillUncheckedCreateWithoutPlayerSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutPlayerSkillsInput
    upsert?: SkillUpsertWithoutPlayerSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutPlayerSkillsInput, SkillUpdateWithoutPlayerSkillsInput>, SkillUncheckedUpdateWithoutPlayerSkillsInput>
  }

  export type TalentCreateNestedManyWithoutTypeInput = {
    create?: XOR<TalentCreateWithoutTypeInput, TalentUncheckedCreateWithoutTypeInput> | TalentCreateWithoutTypeInput[] | TalentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: TalentCreateOrConnectWithoutTypeInput | TalentCreateOrConnectWithoutTypeInput[]
    createMany?: TalentCreateManyTypeInputEnvelope
    connect?: TalentWhereUniqueInput | TalentWhereUniqueInput[]
  }

  export type TalentUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<TalentCreateWithoutTypeInput, TalentUncheckedCreateWithoutTypeInput> | TalentCreateWithoutTypeInput[] | TalentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: TalentCreateOrConnectWithoutTypeInput | TalentCreateOrConnectWithoutTypeInput[]
    createMany?: TalentCreateManyTypeInputEnvelope
    connect?: TalentWhereUniqueInput | TalentWhereUniqueInput[]
  }

  export type TalentUpdateManyWithoutTypeNestedInput = {
    create?: XOR<TalentCreateWithoutTypeInput, TalentUncheckedCreateWithoutTypeInput> | TalentCreateWithoutTypeInput[] | TalentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: TalentCreateOrConnectWithoutTypeInput | TalentCreateOrConnectWithoutTypeInput[]
    upsert?: TalentUpsertWithWhereUniqueWithoutTypeInput | TalentUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: TalentCreateManyTypeInputEnvelope
    set?: TalentWhereUniqueInput | TalentWhereUniqueInput[]
    disconnect?: TalentWhereUniqueInput | TalentWhereUniqueInput[]
    delete?: TalentWhereUniqueInput | TalentWhereUniqueInput[]
    connect?: TalentWhereUniqueInput | TalentWhereUniqueInput[]
    update?: TalentUpdateWithWhereUniqueWithoutTypeInput | TalentUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: TalentUpdateManyWithWhereWithoutTypeInput | TalentUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: TalentScalarWhereInput | TalentScalarWhereInput[]
  }

  export type TalentUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<TalentCreateWithoutTypeInput, TalentUncheckedCreateWithoutTypeInput> | TalentCreateWithoutTypeInput[] | TalentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: TalentCreateOrConnectWithoutTypeInput | TalentCreateOrConnectWithoutTypeInput[]
    upsert?: TalentUpsertWithWhereUniqueWithoutTypeInput | TalentUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: TalentCreateManyTypeInputEnvelope
    set?: TalentWhereUniqueInput | TalentWhereUniqueInput[]
    disconnect?: TalentWhereUniqueInput | TalentWhereUniqueInput[]
    delete?: TalentWhereUniqueInput | TalentWhereUniqueInput[]
    connect?: TalentWhereUniqueInput | TalentWhereUniqueInput[]
    update?: TalentUpdateWithWhereUniqueWithoutTypeInput | TalentUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: TalentUpdateManyWithWhereWithoutTypeInput | TalentUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: TalentScalarWhereInput | TalentScalarWhereInput[]
  }

  export type TalentTypeCreateNestedOneWithoutTalentsInput = {
    create?: XOR<TalentTypeCreateWithoutTalentsInput, TalentTypeUncheckedCreateWithoutTalentsInput>
    connectOrCreate?: TalentTypeCreateOrConnectWithoutTalentsInput
    connect?: TalentTypeWhereUniqueInput
  }

  export type PlayerTalentCreateNestedManyWithoutTalentInput = {
    create?: XOR<PlayerTalentCreateWithoutTalentInput, PlayerTalentUncheckedCreateWithoutTalentInput> | PlayerTalentCreateWithoutTalentInput[] | PlayerTalentUncheckedCreateWithoutTalentInput[]
    connectOrCreate?: PlayerTalentCreateOrConnectWithoutTalentInput | PlayerTalentCreateOrConnectWithoutTalentInput[]
    createMany?: PlayerTalentCreateManyTalentInputEnvelope
    connect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
  }

  export type PlayerTalentUncheckedCreateNestedManyWithoutTalentInput = {
    create?: XOR<PlayerTalentCreateWithoutTalentInput, PlayerTalentUncheckedCreateWithoutTalentInput> | PlayerTalentCreateWithoutTalentInput[] | PlayerTalentUncheckedCreateWithoutTalentInput[]
    connectOrCreate?: PlayerTalentCreateOrConnectWithoutTalentInput | PlayerTalentCreateOrConnectWithoutTalentInput[]
    createMany?: PlayerTalentCreateManyTalentInputEnvelope
    connect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
  }

  export type TalentTypeUpdateOneRequiredWithoutTalentsNestedInput = {
    create?: XOR<TalentTypeCreateWithoutTalentsInput, TalentTypeUncheckedCreateWithoutTalentsInput>
    connectOrCreate?: TalentTypeCreateOrConnectWithoutTalentsInput
    upsert?: TalentTypeUpsertWithoutTalentsInput
    connect?: TalentTypeWhereUniqueInput
    update?: XOR<XOR<TalentTypeUpdateToOneWithWhereWithoutTalentsInput, TalentTypeUpdateWithoutTalentsInput>, TalentTypeUncheckedUpdateWithoutTalentsInput>
  }

  export type PlayerTalentUpdateManyWithoutTalentNestedInput = {
    create?: XOR<PlayerTalentCreateWithoutTalentInput, PlayerTalentUncheckedCreateWithoutTalentInput> | PlayerTalentCreateWithoutTalentInput[] | PlayerTalentUncheckedCreateWithoutTalentInput[]
    connectOrCreate?: PlayerTalentCreateOrConnectWithoutTalentInput | PlayerTalentCreateOrConnectWithoutTalentInput[]
    upsert?: PlayerTalentUpsertWithWhereUniqueWithoutTalentInput | PlayerTalentUpsertWithWhereUniqueWithoutTalentInput[]
    createMany?: PlayerTalentCreateManyTalentInputEnvelope
    set?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    disconnect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    delete?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    connect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    update?: PlayerTalentUpdateWithWhereUniqueWithoutTalentInput | PlayerTalentUpdateWithWhereUniqueWithoutTalentInput[]
    updateMany?: PlayerTalentUpdateManyWithWhereWithoutTalentInput | PlayerTalentUpdateManyWithWhereWithoutTalentInput[]
    deleteMany?: PlayerTalentScalarWhereInput | PlayerTalentScalarWhereInput[]
  }

  export type PlayerTalentUncheckedUpdateManyWithoutTalentNestedInput = {
    create?: XOR<PlayerTalentCreateWithoutTalentInput, PlayerTalentUncheckedCreateWithoutTalentInput> | PlayerTalentCreateWithoutTalentInput[] | PlayerTalentUncheckedCreateWithoutTalentInput[]
    connectOrCreate?: PlayerTalentCreateOrConnectWithoutTalentInput | PlayerTalentCreateOrConnectWithoutTalentInput[]
    upsert?: PlayerTalentUpsertWithWhereUniqueWithoutTalentInput | PlayerTalentUpsertWithWhereUniqueWithoutTalentInput[]
    createMany?: PlayerTalentCreateManyTalentInputEnvelope
    set?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    disconnect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    delete?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    connect?: PlayerTalentWhereUniqueInput | PlayerTalentWhereUniqueInput[]
    update?: PlayerTalentUpdateWithWhereUniqueWithoutTalentInput | PlayerTalentUpdateWithWhereUniqueWithoutTalentInput[]
    updateMany?: PlayerTalentUpdateManyWithWhereWithoutTalentInput | PlayerTalentUpdateManyWithWhereWithoutTalentInput[]
    deleteMany?: PlayerTalentScalarWhereInput | PlayerTalentScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutTalentsInput = {
    create?: XOR<PlayerCreateWithoutTalentsInput, PlayerUncheckedCreateWithoutTalentsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutTalentsInput
    connect?: PlayerWhereUniqueInput
  }

  export type TalentCreateNestedOneWithoutPlayerTalentsInput = {
    create?: XOR<TalentCreateWithoutPlayerTalentsInput, TalentUncheckedCreateWithoutPlayerTalentsInput>
    connectOrCreate?: TalentCreateOrConnectWithoutPlayerTalentsInput
    connect?: TalentWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutTalentsNestedInput = {
    create?: XOR<PlayerCreateWithoutTalentsInput, PlayerUncheckedCreateWithoutTalentsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutTalentsInput
    upsert?: PlayerUpsertWithoutTalentsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutTalentsInput, PlayerUpdateWithoutTalentsInput>, PlayerUncheckedUpdateWithoutTalentsInput>
  }

  export type TalentUpdateOneRequiredWithoutPlayerTalentsNestedInput = {
    create?: XOR<TalentCreateWithoutPlayerTalentsInput, TalentUncheckedCreateWithoutPlayerTalentsInput>
    connectOrCreate?: TalentCreateOrConnectWithoutPlayerTalentsInput
    upsert?: TalentUpsertWithoutPlayerTalentsInput
    connect?: TalentWhereUniqueInput
    update?: XOR<XOR<TalentUpdateToOneWithWhereWithoutPlayerTalentsInput, TalentUpdateWithoutPlayerTalentsInput>, TalentUncheckedUpdateWithoutPlayerTalentsInput>
  }

  export type PlayerBuffCreateNestedManyWithoutBuffInput = {
    create?: XOR<PlayerBuffCreateWithoutBuffInput, PlayerBuffUncheckedCreateWithoutBuffInput> | PlayerBuffCreateWithoutBuffInput[] | PlayerBuffUncheckedCreateWithoutBuffInput[]
    connectOrCreate?: PlayerBuffCreateOrConnectWithoutBuffInput | PlayerBuffCreateOrConnectWithoutBuffInput[]
    createMany?: PlayerBuffCreateManyBuffInputEnvelope
    connect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
  }

  export type PlayerBuffUncheckedCreateNestedManyWithoutBuffInput = {
    create?: XOR<PlayerBuffCreateWithoutBuffInput, PlayerBuffUncheckedCreateWithoutBuffInput> | PlayerBuffCreateWithoutBuffInput[] | PlayerBuffUncheckedCreateWithoutBuffInput[]
    connectOrCreate?: PlayerBuffCreateOrConnectWithoutBuffInput | PlayerBuffCreateOrConnectWithoutBuffInput[]
    createMany?: PlayerBuffCreateManyBuffInputEnvelope
    connect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
  }

  export type PlayerBuffUpdateManyWithoutBuffNestedInput = {
    create?: XOR<PlayerBuffCreateWithoutBuffInput, PlayerBuffUncheckedCreateWithoutBuffInput> | PlayerBuffCreateWithoutBuffInput[] | PlayerBuffUncheckedCreateWithoutBuffInput[]
    connectOrCreate?: PlayerBuffCreateOrConnectWithoutBuffInput | PlayerBuffCreateOrConnectWithoutBuffInput[]
    upsert?: PlayerBuffUpsertWithWhereUniqueWithoutBuffInput | PlayerBuffUpsertWithWhereUniqueWithoutBuffInput[]
    createMany?: PlayerBuffCreateManyBuffInputEnvelope
    set?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    disconnect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    delete?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    connect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    update?: PlayerBuffUpdateWithWhereUniqueWithoutBuffInput | PlayerBuffUpdateWithWhereUniqueWithoutBuffInput[]
    updateMany?: PlayerBuffUpdateManyWithWhereWithoutBuffInput | PlayerBuffUpdateManyWithWhereWithoutBuffInput[]
    deleteMany?: PlayerBuffScalarWhereInput | PlayerBuffScalarWhereInput[]
  }

  export type PlayerBuffUncheckedUpdateManyWithoutBuffNestedInput = {
    create?: XOR<PlayerBuffCreateWithoutBuffInput, PlayerBuffUncheckedCreateWithoutBuffInput> | PlayerBuffCreateWithoutBuffInput[] | PlayerBuffUncheckedCreateWithoutBuffInput[]
    connectOrCreate?: PlayerBuffCreateOrConnectWithoutBuffInput | PlayerBuffCreateOrConnectWithoutBuffInput[]
    upsert?: PlayerBuffUpsertWithWhereUniqueWithoutBuffInput | PlayerBuffUpsertWithWhereUniqueWithoutBuffInput[]
    createMany?: PlayerBuffCreateManyBuffInputEnvelope
    set?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    disconnect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    delete?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    connect?: PlayerBuffWhereUniqueInput | PlayerBuffWhereUniqueInput[]
    update?: PlayerBuffUpdateWithWhereUniqueWithoutBuffInput | PlayerBuffUpdateWithWhereUniqueWithoutBuffInput[]
    updateMany?: PlayerBuffUpdateManyWithWhereWithoutBuffInput | PlayerBuffUpdateManyWithWhereWithoutBuffInput[]
    deleteMany?: PlayerBuffScalarWhereInput | PlayerBuffScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutBuffsInput = {
    create?: XOR<PlayerCreateWithoutBuffsInput, PlayerUncheckedCreateWithoutBuffsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutBuffsInput
    connect?: PlayerWhereUniqueInput
  }

  export type BuffCreateNestedOneWithoutPlayerBuffsInput = {
    create?: XOR<BuffCreateWithoutPlayerBuffsInput, BuffUncheckedCreateWithoutPlayerBuffsInput>
    connectOrCreate?: BuffCreateOrConnectWithoutPlayerBuffsInput
    connect?: BuffWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutBuffsNestedInput = {
    create?: XOR<PlayerCreateWithoutBuffsInput, PlayerUncheckedCreateWithoutBuffsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutBuffsInput
    upsert?: PlayerUpsertWithoutBuffsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutBuffsInput, PlayerUpdateWithoutBuffsInput>, PlayerUncheckedUpdateWithoutBuffsInput>
  }

  export type BuffUpdateOneRequiredWithoutPlayerBuffsNestedInput = {
    create?: XOR<BuffCreateWithoutPlayerBuffsInput, BuffUncheckedCreateWithoutPlayerBuffsInput>
    connectOrCreate?: BuffCreateOrConnectWithoutPlayerBuffsInput
    upsert?: BuffUpsertWithoutPlayerBuffsInput
    connect?: BuffWhereUniqueInput
    update?: XOR<XOR<BuffUpdateToOneWithWhereWithoutPlayerBuffsInput, BuffUpdateWithoutPlayerBuffsInput>, BuffUncheckedUpdateWithoutPlayerBuffsInput>
  }

  export type ShopItemCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput> | ShopItemCreateWithoutShopInput[] | ShopItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutShopInput | ShopItemCreateOrConnectWithoutShopInput[]
    createMany?: ShopItemCreateManyShopInputEnvelope
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
  }

  export type PurchaseHistoryCreateNestedManyWithoutShopInput = {
    create?: XOR<PurchaseHistoryCreateWithoutShopInput, PurchaseHistoryUncheckedCreateWithoutShopInput> | PurchaseHistoryCreateWithoutShopInput[] | PurchaseHistoryUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutShopInput | PurchaseHistoryCreateOrConnectWithoutShopInput[]
    createMany?: PurchaseHistoryCreateManyShopInputEnvelope
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
  }

  export type ShopItemUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput> | ShopItemCreateWithoutShopInput[] | ShopItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutShopInput | ShopItemCreateOrConnectWithoutShopInput[]
    createMany?: ShopItemCreateManyShopInputEnvelope
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
  }

  export type PurchaseHistoryUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<PurchaseHistoryCreateWithoutShopInput, PurchaseHistoryUncheckedCreateWithoutShopInput> | PurchaseHistoryCreateWithoutShopInput[] | PurchaseHistoryUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutShopInput | PurchaseHistoryCreateOrConnectWithoutShopInput[]
    createMany?: PurchaseHistoryCreateManyShopInputEnvelope
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
  }

  export type ShopItemUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput> | ShopItemCreateWithoutShopInput[] | ShopItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutShopInput | ShopItemCreateOrConnectWithoutShopInput[]
    upsert?: ShopItemUpsertWithWhereUniqueWithoutShopInput | ShopItemUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopItemCreateManyShopInputEnvelope
    set?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    disconnect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    delete?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    update?: ShopItemUpdateWithWhereUniqueWithoutShopInput | ShopItemUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopItemUpdateManyWithWhereWithoutShopInput | ShopItemUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
  }

  export type PurchaseHistoryUpdateManyWithoutShopNestedInput = {
    create?: XOR<PurchaseHistoryCreateWithoutShopInput, PurchaseHistoryUncheckedCreateWithoutShopInput> | PurchaseHistoryCreateWithoutShopInput[] | PurchaseHistoryUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutShopInput | PurchaseHistoryCreateOrConnectWithoutShopInput[]
    upsert?: PurchaseHistoryUpsertWithWhereUniqueWithoutShopInput | PurchaseHistoryUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: PurchaseHistoryCreateManyShopInputEnvelope
    set?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    disconnect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    delete?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    update?: PurchaseHistoryUpdateWithWhereUniqueWithoutShopInput | PurchaseHistoryUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: PurchaseHistoryUpdateManyWithWhereWithoutShopInput | PurchaseHistoryUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
  }

  export type ShopItemUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput> | ShopItemCreateWithoutShopInput[] | ShopItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutShopInput | ShopItemCreateOrConnectWithoutShopInput[]
    upsert?: ShopItemUpsertWithWhereUniqueWithoutShopInput | ShopItemUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopItemCreateManyShopInputEnvelope
    set?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    disconnect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    delete?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    update?: ShopItemUpdateWithWhereUniqueWithoutShopInput | ShopItemUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopItemUpdateManyWithWhereWithoutShopInput | ShopItemUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
  }

  export type PurchaseHistoryUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<PurchaseHistoryCreateWithoutShopInput, PurchaseHistoryUncheckedCreateWithoutShopInput> | PurchaseHistoryCreateWithoutShopInput[] | PurchaseHistoryUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutShopInput | PurchaseHistoryCreateOrConnectWithoutShopInput[]
    upsert?: PurchaseHistoryUpsertWithWhereUniqueWithoutShopInput | PurchaseHistoryUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: PurchaseHistoryCreateManyShopInputEnvelope
    set?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    disconnect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    delete?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    update?: PurchaseHistoryUpdateWithWhereUniqueWithoutShopInput | PurchaseHistoryUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: PurchaseHistoryUpdateManyWithWhereWithoutShopInput | PurchaseHistoryUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
  }

  export type ShopCreateNestedOneWithoutItemsInput = {
    create?: XOR<ShopCreateWithoutItemsInput, ShopUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutItemsInput
    connect?: ShopWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ShopCreateWithoutItemsInput, ShopUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutItemsInput
    upsert?: ShopUpsertWithoutItemsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutItemsInput, ShopUpdateWithoutItemsInput>, ShopUncheckedUpdateWithoutItemsInput>
  }

  export type PlayerCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<PlayerCreateWithoutPurchasesInput, PlayerUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPurchasesInput
    connect?: PlayerWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<ShopCreateWithoutPurchasesInput, ShopUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutPurchasesInput
    connect?: ShopWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<PlayerCreateWithoutPurchasesInput, PlayerUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPurchasesInput
    upsert?: PlayerUpsertWithoutPurchasesInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutPurchasesInput, PlayerUpdateWithoutPurchasesInput>, PlayerUncheckedUpdateWithoutPurchasesInput>
  }

  export type ShopUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<ShopCreateWithoutPurchasesInput, ShopUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutPurchasesInput
    upsert?: ShopUpsertWithoutPurchasesInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutPurchasesInput, ShopUpdateWithoutPurchasesInput>, ShopUncheckedUpdateWithoutPurchasesInput>
  }

  export type PlayerCreateNestedOneWithoutInventoryInput = {
    create?: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutInventoryInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutInventoryInput
    upsert?: PlayerUpsertWithoutInventoryInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutInventoryInput, PlayerUpdateWithoutInventoryInput>, PlayerUncheckedUpdateWithoutInventoryInput>
  }

  export type CraftingHistoryCreateNestedManyWithoutRecipeInput = {
    create?: XOR<CraftingHistoryCreateWithoutRecipeInput, CraftingHistoryUncheckedCreateWithoutRecipeInput> | CraftingHistoryCreateWithoutRecipeInput[] | CraftingHistoryUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: CraftingHistoryCreateOrConnectWithoutRecipeInput | CraftingHistoryCreateOrConnectWithoutRecipeInput[]
    createMany?: CraftingHistoryCreateManyRecipeInputEnvelope
    connect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
  }

  export type CraftingHistoryUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<CraftingHistoryCreateWithoutRecipeInput, CraftingHistoryUncheckedCreateWithoutRecipeInput> | CraftingHistoryCreateWithoutRecipeInput[] | CraftingHistoryUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: CraftingHistoryCreateOrConnectWithoutRecipeInput | CraftingHistoryCreateOrConnectWithoutRecipeInput[]
    createMany?: CraftingHistoryCreateManyRecipeInputEnvelope
    connect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CraftingHistoryUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<CraftingHistoryCreateWithoutRecipeInput, CraftingHistoryUncheckedCreateWithoutRecipeInput> | CraftingHistoryCreateWithoutRecipeInput[] | CraftingHistoryUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: CraftingHistoryCreateOrConnectWithoutRecipeInput | CraftingHistoryCreateOrConnectWithoutRecipeInput[]
    upsert?: CraftingHistoryUpsertWithWhereUniqueWithoutRecipeInput | CraftingHistoryUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: CraftingHistoryCreateManyRecipeInputEnvelope
    set?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    disconnect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    delete?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    connect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    update?: CraftingHistoryUpdateWithWhereUniqueWithoutRecipeInput | CraftingHistoryUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: CraftingHistoryUpdateManyWithWhereWithoutRecipeInput | CraftingHistoryUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: CraftingHistoryScalarWhereInput | CraftingHistoryScalarWhereInput[]
  }

  export type CraftingHistoryUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<CraftingHistoryCreateWithoutRecipeInput, CraftingHistoryUncheckedCreateWithoutRecipeInput> | CraftingHistoryCreateWithoutRecipeInput[] | CraftingHistoryUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: CraftingHistoryCreateOrConnectWithoutRecipeInput | CraftingHistoryCreateOrConnectWithoutRecipeInput[]
    upsert?: CraftingHistoryUpsertWithWhereUniqueWithoutRecipeInput | CraftingHistoryUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: CraftingHistoryCreateManyRecipeInputEnvelope
    set?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    disconnect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    delete?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    connect?: CraftingHistoryWhereUniqueInput | CraftingHistoryWhereUniqueInput[]
    update?: CraftingHistoryUpdateWithWhereUniqueWithoutRecipeInput | CraftingHistoryUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: CraftingHistoryUpdateManyWithWhereWithoutRecipeInput | CraftingHistoryUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: CraftingHistoryScalarWhereInput | CraftingHistoryScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutCraftingHistoryInput = {
    create?: XOR<PlayerCreateWithoutCraftingHistoryInput, PlayerUncheckedCreateWithoutCraftingHistoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCraftingHistoryInput
    connect?: PlayerWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutCraftingHistoryInput = {
    create?: XOR<RecipeCreateWithoutCraftingHistoryInput, RecipeUncheckedCreateWithoutCraftingHistoryInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutCraftingHistoryInput
    connect?: RecipeWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutCraftingHistoryNestedInput = {
    create?: XOR<PlayerCreateWithoutCraftingHistoryInput, PlayerUncheckedCreateWithoutCraftingHistoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCraftingHistoryInput
    upsert?: PlayerUpsertWithoutCraftingHistoryInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutCraftingHistoryInput, PlayerUpdateWithoutCraftingHistoryInput>, PlayerUncheckedUpdateWithoutCraftingHistoryInput>
  }

  export type RecipeUpdateOneRequiredWithoutCraftingHistoryNestedInput = {
    create?: XOR<RecipeCreateWithoutCraftingHistoryInput, RecipeUncheckedCreateWithoutCraftingHistoryInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutCraftingHistoryInput
    upsert?: RecipeUpsertWithoutCraftingHistoryInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutCraftingHistoryInput, RecipeUpdateWithoutCraftingHistoryInput>, RecipeUncheckedUpdateWithoutCraftingHistoryInput>
  }

  export type PlayerFurnaceCreateNestedManyWithoutFurnaceInput = {
    create?: XOR<PlayerFurnaceCreateWithoutFurnaceInput, PlayerFurnaceUncheckedCreateWithoutFurnaceInput> | PlayerFurnaceCreateWithoutFurnaceInput[] | PlayerFurnaceUncheckedCreateWithoutFurnaceInput[]
    connectOrCreate?: PlayerFurnaceCreateOrConnectWithoutFurnaceInput | PlayerFurnaceCreateOrConnectWithoutFurnaceInput[]
    createMany?: PlayerFurnaceCreateManyFurnaceInputEnvelope
    connect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
  }

  export type PlayerFurnaceUncheckedCreateNestedManyWithoutFurnaceInput = {
    create?: XOR<PlayerFurnaceCreateWithoutFurnaceInput, PlayerFurnaceUncheckedCreateWithoutFurnaceInput> | PlayerFurnaceCreateWithoutFurnaceInput[] | PlayerFurnaceUncheckedCreateWithoutFurnaceInput[]
    connectOrCreate?: PlayerFurnaceCreateOrConnectWithoutFurnaceInput | PlayerFurnaceCreateOrConnectWithoutFurnaceInput[]
    createMany?: PlayerFurnaceCreateManyFurnaceInputEnvelope
    connect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
  }

  export type PlayerFurnaceUpdateManyWithoutFurnaceNestedInput = {
    create?: XOR<PlayerFurnaceCreateWithoutFurnaceInput, PlayerFurnaceUncheckedCreateWithoutFurnaceInput> | PlayerFurnaceCreateWithoutFurnaceInput[] | PlayerFurnaceUncheckedCreateWithoutFurnaceInput[]
    connectOrCreate?: PlayerFurnaceCreateOrConnectWithoutFurnaceInput | PlayerFurnaceCreateOrConnectWithoutFurnaceInput[]
    upsert?: PlayerFurnaceUpsertWithWhereUniqueWithoutFurnaceInput | PlayerFurnaceUpsertWithWhereUniqueWithoutFurnaceInput[]
    createMany?: PlayerFurnaceCreateManyFurnaceInputEnvelope
    set?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    disconnect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    delete?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    connect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    update?: PlayerFurnaceUpdateWithWhereUniqueWithoutFurnaceInput | PlayerFurnaceUpdateWithWhereUniqueWithoutFurnaceInput[]
    updateMany?: PlayerFurnaceUpdateManyWithWhereWithoutFurnaceInput | PlayerFurnaceUpdateManyWithWhereWithoutFurnaceInput[]
    deleteMany?: PlayerFurnaceScalarWhereInput | PlayerFurnaceScalarWhereInput[]
  }

  export type PlayerFurnaceUncheckedUpdateManyWithoutFurnaceNestedInput = {
    create?: XOR<PlayerFurnaceCreateWithoutFurnaceInput, PlayerFurnaceUncheckedCreateWithoutFurnaceInput> | PlayerFurnaceCreateWithoutFurnaceInput[] | PlayerFurnaceUncheckedCreateWithoutFurnaceInput[]
    connectOrCreate?: PlayerFurnaceCreateOrConnectWithoutFurnaceInput | PlayerFurnaceCreateOrConnectWithoutFurnaceInput[]
    upsert?: PlayerFurnaceUpsertWithWhereUniqueWithoutFurnaceInput | PlayerFurnaceUpsertWithWhereUniqueWithoutFurnaceInput[]
    createMany?: PlayerFurnaceCreateManyFurnaceInputEnvelope
    set?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    disconnect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    delete?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    connect?: PlayerFurnaceWhereUniqueInput | PlayerFurnaceWhereUniqueInput[]
    update?: PlayerFurnaceUpdateWithWhereUniqueWithoutFurnaceInput | PlayerFurnaceUpdateWithWhereUniqueWithoutFurnaceInput[]
    updateMany?: PlayerFurnaceUpdateManyWithWhereWithoutFurnaceInput | PlayerFurnaceUpdateManyWithWhereWithoutFurnaceInput[]
    deleteMany?: PlayerFurnaceScalarWhereInput | PlayerFurnaceScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutFurnacesInput = {
    create?: XOR<PlayerCreateWithoutFurnacesInput, PlayerUncheckedCreateWithoutFurnacesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutFurnacesInput
    connect?: PlayerWhereUniqueInput
  }

  export type DaoFurnaceCreateNestedOneWithoutPlayerFurnacesInput = {
    create?: XOR<DaoFurnaceCreateWithoutPlayerFurnacesInput, DaoFurnaceUncheckedCreateWithoutPlayerFurnacesInput>
    connectOrCreate?: DaoFurnaceCreateOrConnectWithoutPlayerFurnacesInput
    connect?: DaoFurnaceWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutFurnacesNestedInput = {
    create?: XOR<PlayerCreateWithoutFurnacesInput, PlayerUncheckedCreateWithoutFurnacesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutFurnacesInput
    upsert?: PlayerUpsertWithoutFurnacesInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutFurnacesInput, PlayerUpdateWithoutFurnacesInput>, PlayerUncheckedUpdateWithoutFurnacesInput>
  }

  export type DaoFurnaceUpdateOneRequiredWithoutPlayerFurnacesNestedInput = {
    create?: XOR<DaoFurnaceCreateWithoutPlayerFurnacesInput, DaoFurnaceUncheckedCreateWithoutPlayerFurnacesInput>
    connectOrCreate?: DaoFurnaceCreateOrConnectWithoutPlayerFurnacesInput
    upsert?: DaoFurnaceUpsertWithoutPlayerFurnacesInput
    connect?: DaoFurnaceWhereUniqueInput
    update?: XOR<XOR<DaoFurnaceUpdateToOneWithWhereWithoutPlayerFurnacesInput, DaoFurnaceUpdateWithoutPlayerFurnacesInput>, DaoFurnaceUncheckedUpdateWithoutPlayerFurnacesInput>
  }

  export type SpiritBeastCreateNestedManyWithoutTypeInput = {
    create?: XOR<SpiritBeastCreateWithoutTypeInput, SpiritBeastUncheckedCreateWithoutTypeInput> | SpiritBeastCreateWithoutTypeInput[] | SpiritBeastUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutTypeInput | SpiritBeastCreateOrConnectWithoutTypeInput[]
    createMany?: SpiritBeastCreateManyTypeInputEnvelope
    connect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
  }

  export type SpiritBeastUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<SpiritBeastCreateWithoutTypeInput, SpiritBeastUncheckedCreateWithoutTypeInput> | SpiritBeastCreateWithoutTypeInput[] | SpiritBeastUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutTypeInput | SpiritBeastCreateOrConnectWithoutTypeInput[]
    createMany?: SpiritBeastCreateManyTypeInputEnvelope
    connect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
  }

  export type SpiritBeastUpdateManyWithoutTypeNestedInput = {
    create?: XOR<SpiritBeastCreateWithoutTypeInput, SpiritBeastUncheckedCreateWithoutTypeInput> | SpiritBeastCreateWithoutTypeInput[] | SpiritBeastUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutTypeInput | SpiritBeastCreateOrConnectWithoutTypeInput[]
    upsert?: SpiritBeastUpsertWithWhereUniqueWithoutTypeInput | SpiritBeastUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: SpiritBeastCreateManyTypeInputEnvelope
    set?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    disconnect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    delete?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    connect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    update?: SpiritBeastUpdateWithWhereUniqueWithoutTypeInput | SpiritBeastUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: SpiritBeastUpdateManyWithWhereWithoutTypeInput | SpiritBeastUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: SpiritBeastScalarWhereInput | SpiritBeastScalarWhereInput[]
  }

  export type SpiritBeastUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<SpiritBeastCreateWithoutTypeInput, SpiritBeastUncheckedCreateWithoutTypeInput> | SpiritBeastCreateWithoutTypeInput[] | SpiritBeastUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutTypeInput | SpiritBeastCreateOrConnectWithoutTypeInput[]
    upsert?: SpiritBeastUpsertWithWhereUniqueWithoutTypeInput | SpiritBeastUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: SpiritBeastCreateManyTypeInputEnvelope
    set?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    disconnect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    delete?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    connect?: SpiritBeastWhereUniqueInput | SpiritBeastWhereUniqueInput[]
    update?: SpiritBeastUpdateWithWhereUniqueWithoutTypeInput | SpiritBeastUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: SpiritBeastUpdateManyWithWhereWithoutTypeInput | SpiritBeastUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: SpiritBeastScalarWhereInput | SpiritBeastScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutSpiritBeastsInput = {
    create?: XOR<PlayerCreateWithoutSpiritBeastsInput, PlayerUncheckedCreateWithoutSpiritBeastsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSpiritBeastsInput
    connect?: PlayerWhereUniqueInput
  }

  export type SpiritBeastTypeCreateNestedOneWithoutBeastsInput = {
    create?: XOR<SpiritBeastTypeCreateWithoutBeastsInput, SpiritBeastTypeUncheckedCreateWithoutBeastsInput>
    connectOrCreate?: SpiritBeastTypeCreateOrConnectWithoutBeastsInput
    connect?: SpiritBeastTypeWhereUniqueInput
  }

  export type BeastFeedingHistoryCreateNestedManyWithoutBeastInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutBeastInput, BeastFeedingHistoryUncheckedCreateWithoutBeastInput> | BeastFeedingHistoryCreateWithoutBeastInput[] | BeastFeedingHistoryUncheckedCreateWithoutBeastInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutBeastInput | BeastFeedingHistoryCreateOrConnectWithoutBeastInput[]
    createMany?: BeastFeedingHistoryCreateManyBeastInputEnvelope
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
  }

  export type HuntingHistoryCreateNestedManyWithoutBeastInput = {
    create?: XOR<HuntingHistoryCreateWithoutBeastInput, HuntingHistoryUncheckedCreateWithoutBeastInput> | HuntingHistoryCreateWithoutBeastInput[] | HuntingHistoryUncheckedCreateWithoutBeastInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutBeastInput | HuntingHistoryCreateOrConnectWithoutBeastInput[]
    createMany?: HuntingHistoryCreateManyBeastInputEnvelope
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
  }

  export type BeastFeedingHistoryUncheckedCreateNestedManyWithoutBeastInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutBeastInput, BeastFeedingHistoryUncheckedCreateWithoutBeastInput> | BeastFeedingHistoryCreateWithoutBeastInput[] | BeastFeedingHistoryUncheckedCreateWithoutBeastInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutBeastInput | BeastFeedingHistoryCreateOrConnectWithoutBeastInput[]
    createMany?: BeastFeedingHistoryCreateManyBeastInputEnvelope
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
  }

  export type HuntingHistoryUncheckedCreateNestedManyWithoutBeastInput = {
    create?: XOR<HuntingHistoryCreateWithoutBeastInput, HuntingHistoryUncheckedCreateWithoutBeastInput> | HuntingHistoryCreateWithoutBeastInput[] | HuntingHistoryUncheckedCreateWithoutBeastInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutBeastInput | HuntingHistoryCreateOrConnectWithoutBeastInput[]
    createMany?: HuntingHistoryCreateManyBeastInputEnvelope
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
  }

  export type PlayerUpdateOneRequiredWithoutSpiritBeastsNestedInput = {
    create?: XOR<PlayerCreateWithoutSpiritBeastsInput, PlayerUncheckedCreateWithoutSpiritBeastsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSpiritBeastsInput
    upsert?: PlayerUpsertWithoutSpiritBeastsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutSpiritBeastsInput, PlayerUpdateWithoutSpiritBeastsInput>, PlayerUncheckedUpdateWithoutSpiritBeastsInput>
  }

  export type SpiritBeastTypeUpdateOneRequiredWithoutBeastsNestedInput = {
    create?: XOR<SpiritBeastTypeCreateWithoutBeastsInput, SpiritBeastTypeUncheckedCreateWithoutBeastsInput>
    connectOrCreate?: SpiritBeastTypeCreateOrConnectWithoutBeastsInput
    upsert?: SpiritBeastTypeUpsertWithoutBeastsInput
    connect?: SpiritBeastTypeWhereUniqueInput
    update?: XOR<XOR<SpiritBeastTypeUpdateToOneWithWhereWithoutBeastsInput, SpiritBeastTypeUpdateWithoutBeastsInput>, SpiritBeastTypeUncheckedUpdateWithoutBeastsInput>
  }

  export type BeastFeedingHistoryUpdateManyWithoutBeastNestedInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutBeastInput, BeastFeedingHistoryUncheckedCreateWithoutBeastInput> | BeastFeedingHistoryCreateWithoutBeastInput[] | BeastFeedingHistoryUncheckedCreateWithoutBeastInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutBeastInput | BeastFeedingHistoryCreateOrConnectWithoutBeastInput[]
    upsert?: BeastFeedingHistoryUpsertWithWhereUniqueWithoutBeastInput | BeastFeedingHistoryUpsertWithWhereUniqueWithoutBeastInput[]
    createMany?: BeastFeedingHistoryCreateManyBeastInputEnvelope
    set?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    disconnect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    delete?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    update?: BeastFeedingHistoryUpdateWithWhereUniqueWithoutBeastInput | BeastFeedingHistoryUpdateWithWhereUniqueWithoutBeastInput[]
    updateMany?: BeastFeedingHistoryUpdateManyWithWhereWithoutBeastInput | BeastFeedingHistoryUpdateManyWithWhereWithoutBeastInput[]
    deleteMany?: BeastFeedingHistoryScalarWhereInput | BeastFeedingHistoryScalarWhereInput[]
  }

  export type HuntingHistoryUpdateManyWithoutBeastNestedInput = {
    create?: XOR<HuntingHistoryCreateWithoutBeastInput, HuntingHistoryUncheckedCreateWithoutBeastInput> | HuntingHistoryCreateWithoutBeastInput[] | HuntingHistoryUncheckedCreateWithoutBeastInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutBeastInput | HuntingHistoryCreateOrConnectWithoutBeastInput[]
    upsert?: HuntingHistoryUpsertWithWhereUniqueWithoutBeastInput | HuntingHistoryUpsertWithWhereUniqueWithoutBeastInput[]
    createMany?: HuntingHistoryCreateManyBeastInputEnvelope
    set?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    disconnect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    delete?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    update?: HuntingHistoryUpdateWithWhereUniqueWithoutBeastInput | HuntingHistoryUpdateWithWhereUniqueWithoutBeastInput[]
    updateMany?: HuntingHistoryUpdateManyWithWhereWithoutBeastInput | HuntingHistoryUpdateManyWithWhereWithoutBeastInput[]
    deleteMany?: HuntingHistoryScalarWhereInput | HuntingHistoryScalarWhereInput[]
  }

  export type BeastFeedingHistoryUncheckedUpdateManyWithoutBeastNestedInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutBeastInput, BeastFeedingHistoryUncheckedCreateWithoutBeastInput> | BeastFeedingHistoryCreateWithoutBeastInput[] | BeastFeedingHistoryUncheckedCreateWithoutBeastInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutBeastInput | BeastFeedingHistoryCreateOrConnectWithoutBeastInput[]
    upsert?: BeastFeedingHistoryUpsertWithWhereUniqueWithoutBeastInput | BeastFeedingHistoryUpsertWithWhereUniqueWithoutBeastInput[]
    createMany?: BeastFeedingHistoryCreateManyBeastInputEnvelope
    set?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    disconnect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    delete?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    update?: BeastFeedingHistoryUpdateWithWhereUniqueWithoutBeastInput | BeastFeedingHistoryUpdateWithWhereUniqueWithoutBeastInput[]
    updateMany?: BeastFeedingHistoryUpdateManyWithWhereWithoutBeastInput | BeastFeedingHistoryUpdateManyWithWhereWithoutBeastInput[]
    deleteMany?: BeastFeedingHistoryScalarWhereInput | BeastFeedingHistoryScalarWhereInput[]
  }

  export type HuntingHistoryUncheckedUpdateManyWithoutBeastNestedInput = {
    create?: XOR<HuntingHistoryCreateWithoutBeastInput, HuntingHistoryUncheckedCreateWithoutBeastInput> | HuntingHistoryCreateWithoutBeastInput[] | HuntingHistoryUncheckedCreateWithoutBeastInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutBeastInput | HuntingHistoryCreateOrConnectWithoutBeastInput[]
    upsert?: HuntingHistoryUpsertWithWhereUniqueWithoutBeastInput | HuntingHistoryUpsertWithWhereUniqueWithoutBeastInput[]
    createMany?: HuntingHistoryCreateManyBeastInputEnvelope
    set?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    disconnect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    delete?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    update?: HuntingHistoryUpdateWithWhereUniqueWithoutBeastInput | HuntingHistoryUpdateWithWhereUniqueWithoutBeastInput[]
    updateMany?: HuntingHistoryUpdateManyWithWhereWithoutBeastInput | HuntingHistoryUpdateManyWithWhereWithoutBeastInput[]
    deleteMany?: HuntingHistoryScalarWhereInput | HuntingHistoryScalarWhereInput[]
  }

  export type BeastFeedingHistoryCreateNestedManyWithoutFoodInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutFoodInput, BeastFeedingHistoryUncheckedCreateWithoutFoodInput> | BeastFeedingHistoryCreateWithoutFoodInput[] | BeastFeedingHistoryUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutFoodInput | BeastFeedingHistoryCreateOrConnectWithoutFoodInput[]
    createMany?: BeastFeedingHistoryCreateManyFoodInputEnvelope
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
  }

  export type BeastFeedingHistoryUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutFoodInput, BeastFeedingHistoryUncheckedCreateWithoutFoodInput> | BeastFeedingHistoryCreateWithoutFoodInput[] | BeastFeedingHistoryUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutFoodInput | BeastFeedingHistoryCreateOrConnectWithoutFoodInput[]
    createMany?: BeastFeedingHistoryCreateManyFoodInputEnvelope
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
  }

  export type BeastFeedingHistoryUpdateManyWithoutFoodNestedInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutFoodInput, BeastFeedingHistoryUncheckedCreateWithoutFoodInput> | BeastFeedingHistoryCreateWithoutFoodInput[] | BeastFeedingHistoryUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutFoodInput | BeastFeedingHistoryCreateOrConnectWithoutFoodInput[]
    upsert?: BeastFeedingHistoryUpsertWithWhereUniqueWithoutFoodInput | BeastFeedingHistoryUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: BeastFeedingHistoryCreateManyFoodInputEnvelope
    set?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    disconnect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    delete?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    update?: BeastFeedingHistoryUpdateWithWhereUniqueWithoutFoodInput | BeastFeedingHistoryUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: BeastFeedingHistoryUpdateManyWithWhereWithoutFoodInput | BeastFeedingHistoryUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: BeastFeedingHistoryScalarWhereInput | BeastFeedingHistoryScalarWhereInput[]
  }

  export type BeastFeedingHistoryUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<BeastFeedingHistoryCreateWithoutFoodInput, BeastFeedingHistoryUncheckedCreateWithoutFoodInput> | BeastFeedingHistoryCreateWithoutFoodInput[] | BeastFeedingHistoryUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: BeastFeedingHistoryCreateOrConnectWithoutFoodInput | BeastFeedingHistoryCreateOrConnectWithoutFoodInput[]
    upsert?: BeastFeedingHistoryUpsertWithWhereUniqueWithoutFoodInput | BeastFeedingHistoryUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: BeastFeedingHistoryCreateManyFoodInputEnvelope
    set?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    disconnect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    delete?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    connect?: BeastFeedingHistoryWhereUniqueInput | BeastFeedingHistoryWhereUniqueInput[]
    update?: BeastFeedingHistoryUpdateWithWhereUniqueWithoutFoodInput | BeastFeedingHistoryUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: BeastFeedingHistoryUpdateManyWithWhereWithoutFoodInput | BeastFeedingHistoryUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: BeastFeedingHistoryScalarWhereInput | BeastFeedingHistoryScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutBeastFeedingHistoryInput = {
    create?: XOR<PlayerCreateWithoutBeastFeedingHistoryInput, PlayerUncheckedCreateWithoutBeastFeedingHistoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutBeastFeedingHistoryInput
    connect?: PlayerWhereUniqueInput
  }

  export type SpiritBeastCreateNestedOneWithoutFeedingHistoryInput = {
    create?: XOR<SpiritBeastCreateWithoutFeedingHistoryInput, SpiritBeastUncheckedCreateWithoutFeedingHistoryInput>
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutFeedingHistoryInput
    connect?: SpiritBeastWhereUniqueInput
  }

  export type BeastFoodCreateNestedOneWithoutFeedingHistoryInput = {
    create?: XOR<BeastFoodCreateWithoutFeedingHistoryInput, BeastFoodUncheckedCreateWithoutFeedingHistoryInput>
    connectOrCreate?: BeastFoodCreateOrConnectWithoutFeedingHistoryInput
    connect?: BeastFoodWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutBeastFeedingHistoryNestedInput = {
    create?: XOR<PlayerCreateWithoutBeastFeedingHistoryInput, PlayerUncheckedCreateWithoutBeastFeedingHistoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutBeastFeedingHistoryInput
    upsert?: PlayerUpsertWithoutBeastFeedingHistoryInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutBeastFeedingHistoryInput, PlayerUpdateWithoutBeastFeedingHistoryInput>, PlayerUncheckedUpdateWithoutBeastFeedingHistoryInput>
  }

  export type SpiritBeastUpdateOneRequiredWithoutFeedingHistoryNestedInput = {
    create?: XOR<SpiritBeastCreateWithoutFeedingHistoryInput, SpiritBeastUncheckedCreateWithoutFeedingHistoryInput>
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutFeedingHistoryInput
    upsert?: SpiritBeastUpsertWithoutFeedingHistoryInput
    connect?: SpiritBeastWhereUniqueInput
    update?: XOR<XOR<SpiritBeastUpdateToOneWithWhereWithoutFeedingHistoryInput, SpiritBeastUpdateWithoutFeedingHistoryInput>, SpiritBeastUncheckedUpdateWithoutFeedingHistoryInput>
  }

  export type BeastFoodUpdateOneRequiredWithoutFeedingHistoryNestedInput = {
    create?: XOR<BeastFoodCreateWithoutFeedingHistoryInput, BeastFoodUncheckedCreateWithoutFeedingHistoryInput>
    connectOrCreate?: BeastFoodCreateOrConnectWithoutFeedingHistoryInput
    upsert?: BeastFoodUpsertWithoutFeedingHistoryInput
    connect?: BeastFoodWhereUniqueInput
    update?: XOR<XOR<BeastFoodUpdateToOneWithWhereWithoutFeedingHistoryInput, BeastFoodUpdateWithoutFeedingHistoryInput>, BeastFoodUncheckedUpdateWithoutFeedingHistoryInput>
  }

  export type HuntingHistoryCreateNestedManyWithoutGroundInput = {
    create?: XOR<HuntingHistoryCreateWithoutGroundInput, HuntingHistoryUncheckedCreateWithoutGroundInput> | HuntingHistoryCreateWithoutGroundInput[] | HuntingHistoryUncheckedCreateWithoutGroundInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutGroundInput | HuntingHistoryCreateOrConnectWithoutGroundInput[]
    createMany?: HuntingHistoryCreateManyGroundInputEnvelope
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
  }

  export type HuntingHistoryUncheckedCreateNestedManyWithoutGroundInput = {
    create?: XOR<HuntingHistoryCreateWithoutGroundInput, HuntingHistoryUncheckedCreateWithoutGroundInput> | HuntingHistoryCreateWithoutGroundInput[] | HuntingHistoryUncheckedCreateWithoutGroundInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutGroundInput | HuntingHistoryCreateOrConnectWithoutGroundInput[]
    createMany?: HuntingHistoryCreateManyGroundInputEnvelope
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
  }

  export type HuntingHistoryUpdateManyWithoutGroundNestedInput = {
    create?: XOR<HuntingHistoryCreateWithoutGroundInput, HuntingHistoryUncheckedCreateWithoutGroundInput> | HuntingHistoryCreateWithoutGroundInput[] | HuntingHistoryUncheckedCreateWithoutGroundInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutGroundInput | HuntingHistoryCreateOrConnectWithoutGroundInput[]
    upsert?: HuntingHistoryUpsertWithWhereUniqueWithoutGroundInput | HuntingHistoryUpsertWithWhereUniqueWithoutGroundInput[]
    createMany?: HuntingHistoryCreateManyGroundInputEnvelope
    set?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    disconnect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    delete?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    update?: HuntingHistoryUpdateWithWhereUniqueWithoutGroundInput | HuntingHistoryUpdateWithWhereUniqueWithoutGroundInput[]
    updateMany?: HuntingHistoryUpdateManyWithWhereWithoutGroundInput | HuntingHistoryUpdateManyWithWhereWithoutGroundInput[]
    deleteMany?: HuntingHistoryScalarWhereInput | HuntingHistoryScalarWhereInput[]
  }

  export type HuntingHistoryUncheckedUpdateManyWithoutGroundNestedInput = {
    create?: XOR<HuntingHistoryCreateWithoutGroundInput, HuntingHistoryUncheckedCreateWithoutGroundInput> | HuntingHistoryCreateWithoutGroundInput[] | HuntingHistoryUncheckedCreateWithoutGroundInput[]
    connectOrCreate?: HuntingHistoryCreateOrConnectWithoutGroundInput | HuntingHistoryCreateOrConnectWithoutGroundInput[]
    upsert?: HuntingHistoryUpsertWithWhereUniqueWithoutGroundInput | HuntingHistoryUpsertWithWhereUniqueWithoutGroundInput[]
    createMany?: HuntingHistoryCreateManyGroundInputEnvelope
    set?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    disconnect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    delete?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    connect?: HuntingHistoryWhereUniqueInput | HuntingHistoryWhereUniqueInput[]
    update?: HuntingHistoryUpdateWithWhereUniqueWithoutGroundInput | HuntingHistoryUpdateWithWhereUniqueWithoutGroundInput[]
    updateMany?: HuntingHistoryUpdateManyWithWhereWithoutGroundInput | HuntingHistoryUpdateManyWithWhereWithoutGroundInput[]
    deleteMany?: HuntingHistoryScalarWhereInput | HuntingHistoryScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutHuntingHistoryInput = {
    create?: XOR<PlayerCreateWithoutHuntingHistoryInput, PlayerUncheckedCreateWithoutHuntingHistoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutHuntingHistoryInput
    connect?: PlayerWhereUniqueInput
  }

  export type HuntingGroundCreateNestedOneWithoutHuntingHistoryInput = {
    create?: XOR<HuntingGroundCreateWithoutHuntingHistoryInput, HuntingGroundUncheckedCreateWithoutHuntingHistoryInput>
    connectOrCreate?: HuntingGroundCreateOrConnectWithoutHuntingHistoryInput
    connect?: HuntingGroundWhereUniqueInput
  }

  export type SpiritBeastCreateNestedOneWithoutHuntingHistoryInput = {
    create?: XOR<SpiritBeastCreateWithoutHuntingHistoryInput, SpiritBeastUncheckedCreateWithoutHuntingHistoryInput>
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutHuntingHistoryInput
    connect?: SpiritBeastWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutHuntingHistoryNestedInput = {
    create?: XOR<PlayerCreateWithoutHuntingHistoryInput, PlayerUncheckedCreateWithoutHuntingHistoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutHuntingHistoryInput
    upsert?: PlayerUpsertWithoutHuntingHistoryInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutHuntingHistoryInput, PlayerUpdateWithoutHuntingHistoryInput>, PlayerUncheckedUpdateWithoutHuntingHistoryInput>
  }

  export type HuntingGroundUpdateOneRequiredWithoutHuntingHistoryNestedInput = {
    create?: XOR<HuntingGroundCreateWithoutHuntingHistoryInput, HuntingGroundUncheckedCreateWithoutHuntingHistoryInput>
    connectOrCreate?: HuntingGroundCreateOrConnectWithoutHuntingHistoryInput
    upsert?: HuntingGroundUpsertWithoutHuntingHistoryInput
    connect?: HuntingGroundWhereUniqueInput
    update?: XOR<XOR<HuntingGroundUpdateToOneWithWhereWithoutHuntingHistoryInput, HuntingGroundUpdateWithoutHuntingHistoryInput>, HuntingGroundUncheckedUpdateWithoutHuntingHistoryInput>
  }

  export type SpiritBeastUpdateOneWithoutHuntingHistoryNestedInput = {
    create?: XOR<SpiritBeastCreateWithoutHuntingHistoryInput, SpiritBeastUncheckedCreateWithoutHuntingHistoryInput>
    connectOrCreate?: SpiritBeastCreateOrConnectWithoutHuntingHistoryInput
    upsert?: SpiritBeastUpsertWithoutHuntingHistoryInput
    disconnect?: SpiritBeastWhereInput | boolean
    delete?: SpiritBeastWhereInput | boolean
    connect?: SpiritBeastWhereUniqueInput
    update?: XOR<XOR<SpiritBeastUpdateToOneWithWhereWithoutHuntingHistoryInput, SpiritBeastUpdateWithoutHuntingHistoryInput>, SpiritBeastUncheckedUpdateWithoutHuntingHistoryInput>
  }

  export type PlayerCreateNestedOneWithoutCultivationInput = {
    create?: XOR<PlayerCreateWithoutCultivationInput, PlayerUncheckedCreateWithoutCultivationInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCultivationInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutCultivationNestedInput = {
    create?: XOR<PlayerCreateWithoutCultivationInput, PlayerUncheckedCreateWithoutCultivationInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCultivationInput
    upsert?: PlayerUpsertWithoutCultivationInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutCultivationInput, PlayerUpdateWithoutCultivationInput>, PlayerUncheckedUpdateWithoutCultivationInput>
  }

  export type PlayerCreateNestedOneWithoutCultivationLogsInput = {
    create?: XOR<PlayerCreateWithoutCultivationLogsInput, PlayerUncheckedCreateWithoutCultivationLogsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCultivationLogsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutCultivationLogsNestedInput = {
    create?: XOR<PlayerCreateWithoutCultivationLogsInput, PlayerUncheckedCreateWithoutCultivationLogsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCultivationLogsInput
    upsert?: PlayerUpsertWithoutCultivationLogsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutCultivationLogsInput, PlayerUpdateWithoutCultivationLogsInput>, PlayerUncheckedUpdateWithoutCultivationLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PlayerCreateWithoutUserInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutUserInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithoutUserInput = {
    update: XOR<PlayerUpdateWithoutUserInput, PlayerUncheckedUpdateWithoutUserInput>
    create: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutUserInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutUserInput, PlayerUncheckedUpdateWithoutUserInput>
  }

  export type PlayerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutPlayerInput = {
    id?: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlayerInput = {
    id?: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlayerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayerInput, UserUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerResourceCreateWithoutPlayerInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    resource: ResourceCreateNestedOneWithoutPlayerResourcesInput
  }

  export type PlayerResourceUncheckedCreateWithoutPlayerInput = {
    id?: string
    resourceId: string
    amount?: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerResourceCreateOrConnectWithoutPlayerInput = {
    where: PlayerResourceWhereUniqueInput
    create: XOR<PlayerResourceCreateWithoutPlayerInput, PlayerResourceUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerResourceCreateManyPlayerInputEnvelope = {
    data: PlayerResourceCreateManyPlayerInput | PlayerResourceCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCompanionCreateWithoutPlayerInput = {
    id?: string
    level?: number
    power?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companion: CompanionCreateNestedOneWithoutPlayerCompanionsInput
  }

  export type PlayerCompanionUncheckedCreateWithoutPlayerInput = {
    id?: string
    companionId: string
    level?: number
    power?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCompanionCreateOrConnectWithoutPlayerInput = {
    where: PlayerCompanionWhereUniqueInput
    create: XOR<PlayerCompanionCreateWithoutPlayerInput, PlayerCompanionUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerCompanionCreateManyPlayerInputEnvelope = {
    data: PlayerCompanionCreateManyPlayerInput | PlayerCompanionCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerAchievementCreateWithoutPlayerInput = {
    id?: string
    unlockedAt?: Date | string
    achievement: AchievementCreateNestedOneWithoutPlayerAchievementsInput
  }

  export type PlayerAchievementUncheckedCreateWithoutPlayerInput = {
    id?: string
    achievementId: string
    unlockedAt?: Date | string
  }

  export type PlayerAchievementCreateOrConnectWithoutPlayerInput = {
    where: PlayerAchievementWhereUniqueInput
    create: XOR<PlayerAchievementCreateWithoutPlayerInput, PlayerAchievementUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerAchievementCreateManyPlayerInputEnvelope = {
    data: PlayerAchievementCreateManyPlayerInput | PlayerAchievementCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerQuestCreateWithoutPlayerInput = {
    id?: string
    status?: string
    progress?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lastCompletedAt?: Date | string | null
    cooldownUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quest: QuestCreateNestedOneWithoutPlayerQuestsInput
  }

  export type PlayerQuestUncheckedCreateWithoutPlayerInput = {
    id?: string
    questId: string
    status?: string
    progress?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lastCompletedAt?: Date | string | null
    cooldownUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerQuestCreateOrConnectWithoutPlayerInput = {
    where: PlayerQuestWhereUniqueInput
    create: XOR<PlayerQuestCreateWithoutPlayerInput, PlayerQuestUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerQuestCreateManyPlayerInputEnvelope = {
    data: PlayerQuestCreateManyPlayerInput | PlayerQuestCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerStatsCreateWithoutPlayerInput = {
    id?: string
    hp?: number
    mp?: number
    attack?: number
    defense?: number
    speed?: number
    luck?: number
    wisdom?: number
    strength?: number
    agility?: number
    vitality?: number
    spirit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerStatsUncheckedCreateWithoutPlayerInput = {
    id?: string
    hp?: number
    mp?: number
    attack?: number
    defense?: number
    speed?: number
    luck?: number
    wisdom?: number
    strength?: number
    agility?: number
    vitality?: number
    spirit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerStatsCreateOrConnectWithoutPlayerInput = {
    where: PlayerStatsWhereUniqueInput
    create: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerEquipmentCreateWithoutPlayerInput = {
    id?: string
    isEquipped?: boolean
    durability?: number
    enhancement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    equipment: EquipmentCreateNestedOneWithoutPlayerEquipmentsInput
  }

  export type PlayerEquipmentUncheckedCreateWithoutPlayerInput = {
    id?: string
    equipmentId: string
    isEquipped?: boolean
    durability?: number
    enhancement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerEquipmentCreateOrConnectWithoutPlayerInput = {
    where: PlayerEquipmentWhereUniqueInput
    create: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerEquipmentCreateManyPlayerInputEnvelope = {
    data: PlayerEquipmentCreateManyPlayerInput | PlayerEquipmentCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerSkillCreateWithoutPlayerInput = {
    id?: string
    level?: number
    isLearned?: boolean
    learnedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutPlayerSkillsInput
  }

  export type PlayerSkillUncheckedCreateWithoutPlayerInput = {
    id?: string
    skillId: string
    level?: number
    isLearned?: boolean
    learnedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerSkillCreateOrConnectWithoutPlayerInput = {
    where: PlayerSkillWhereUniqueInput
    create: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerSkillCreateManyPlayerInputEnvelope = {
    data: PlayerSkillCreateManyPlayerInput | PlayerSkillCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerTalentCreateWithoutPlayerInput = {
    id?: string
    level?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    talent: TalentCreateNestedOneWithoutPlayerTalentsInput
  }

  export type PlayerTalentUncheckedCreateWithoutPlayerInput = {
    id?: string
    talentId: string
    level?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerTalentCreateOrConnectWithoutPlayerInput = {
    where: PlayerTalentWhereUniqueInput
    create: XOR<PlayerTalentCreateWithoutPlayerInput, PlayerTalentUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerTalentCreateManyPlayerInputEnvelope = {
    data: PlayerTalentCreateManyPlayerInput | PlayerTalentCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerBuffCreateWithoutPlayerInput = {
    id?: string
    level?: number
    stacks?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buff: BuffCreateNestedOneWithoutPlayerBuffsInput
  }

  export type PlayerBuffUncheckedCreateWithoutPlayerInput = {
    id?: string
    buffId: string
    level?: number
    stacks?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerBuffCreateOrConnectWithoutPlayerInput = {
    where: PlayerBuffWhereUniqueInput
    create: XOR<PlayerBuffCreateWithoutPlayerInput, PlayerBuffUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerBuffCreateManyPlayerInputEnvelope = {
    data: PlayerBuffCreateManyPlayerInput | PlayerBuffCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseHistoryCreateWithoutPlayerInput = {
    id?: string
    itemId: string
    itemName: string
    quantity?: number
    price: number
    currency: string
    totalCost: number
    createdAt?: Date | string
    shop: ShopCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseHistoryUncheckedCreateWithoutPlayerInput = {
    id?: string
    shopId: string
    itemId: string
    itemName: string
    quantity?: number
    price: number
    currency: string
    totalCost: number
    createdAt?: Date | string
  }

  export type PurchaseHistoryCreateOrConnectWithoutPlayerInput = {
    where: PurchaseHistoryWhereUniqueInput
    create: XOR<PurchaseHistoryCreateWithoutPlayerInput, PurchaseHistoryUncheckedCreateWithoutPlayerInput>
  }

  export type PurchaseHistoryCreateManyPlayerInputEnvelope = {
    data: PurchaseHistoryCreateManyPlayerInput | PurchaseHistoryCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutPlayerInput = {
    id?: string
    itemType: string
    itemId: string
    name: string
    quantity?: number
    stackable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUncheckedCreateWithoutPlayerInput = {
    id?: string
    itemType: string
    itemId: string
    name: string
    quantity?: number
    stackable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutPlayerInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutPlayerInput, InventoryUncheckedCreateWithoutPlayerInput>
  }

  export type InventoryCreateManyPlayerInputEnvelope = {
    data: InventoryCreateManyPlayerInput | InventoryCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type CraftingHistoryCreateWithoutPlayerInput = {
    id?: string
    success: boolean
    quantity?: number
    materials: string
    result: string
    createdAt?: Date | string
    recipe: RecipeCreateNestedOneWithoutCraftingHistoryInput
  }

  export type CraftingHistoryUncheckedCreateWithoutPlayerInput = {
    id?: string
    recipeId: string
    success: boolean
    quantity?: number
    materials: string
    result: string
    createdAt?: Date | string
  }

  export type CraftingHistoryCreateOrConnectWithoutPlayerInput = {
    where: CraftingHistoryWhereUniqueInput
    create: XOR<CraftingHistoryCreateWithoutPlayerInput, CraftingHistoryUncheckedCreateWithoutPlayerInput>
  }

  export type CraftingHistoryCreateManyPlayerInputEnvelope = {
    data: CraftingHistoryCreateManyPlayerInput | CraftingHistoryCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerFurnaceCreateWithoutPlayerInput = {
    id?: string
    level?: number
    experience?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    furnace: DaoFurnaceCreateNestedOneWithoutPlayerFurnacesInput
  }

  export type PlayerFurnaceUncheckedCreateWithoutPlayerInput = {
    id?: string
    furnaceId: string
    level?: number
    experience?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerFurnaceCreateOrConnectWithoutPlayerInput = {
    where: PlayerFurnaceWhereUniqueInput
    create: XOR<PlayerFurnaceCreateWithoutPlayerInput, PlayerFurnaceUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerFurnaceCreateManyPlayerInputEnvelope = {
    data: PlayerFurnaceCreateManyPlayerInput | PlayerFurnaceCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type SpiritBeastCreateWithoutPlayerInput = {
    id?: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: SpiritBeastTypeCreateNestedOneWithoutBeastsInput
    feedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutBeastInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutBeastInput
  }

  export type SpiritBeastUncheckedCreateWithoutPlayerInput = {
    id?: string
    typeId: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutBeastInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutBeastInput
  }

  export type SpiritBeastCreateOrConnectWithoutPlayerInput = {
    where: SpiritBeastWhereUniqueInput
    create: XOR<SpiritBeastCreateWithoutPlayerInput, SpiritBeastUncheckedCreateWithoutPlayerInput>
  }

  export type SpiritBeastCreateManyPlayerInputEnvelope = {
    data: SpiritBeastCreateManyPlayerInput | SpiritBeastCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type BeastFeedingHistoryCreateWithoutPlayerInput = {
    id?: string
    quantity?: number
    effects: string
    createdAt?: Date | string
    beast: SpiritBeastCreateNestedOneWithoutFeedingHistoryInput
    food: BeastFoodCreateNestedOneWithoutFeedingHistoryInput
  }

  export type BeastFeedingHistoryUncheckedCreateWithoutPlayerInput = {
    id?: string
    beastId: string
    foodId: string
    quantity?: number
    effects: string
    createdAt?: Date | string
  }

  export type BeastFeedingHistoryCreateOrConnectWithoutPlayerInput = {
    where: BeastFeedingHistoryWhereUniqueInput
    create: XOR<BeastFeedingHistoryCreateWithoutPlayerInput, BeastFeedingHistoryUncheckedCreateWithoutPlayerInput>
  }

  export type BeastFeedingHistoryCreateManyPlayerInputEnvelope = {
    data: BeastFeedingHistoryCreateManyPlayerInput | BeastFeedingHistoryCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type HuntingHistoryCreateWithoutPlayerInput = {
    id?: string
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
    ground: HuntingGroundCreateNestedOneWithoutHuntingHistoryInput
    beast?: SpiritBeastCreateNestedOneWithoutHuntingHistoryInput
  }

  export type HuntingHistoryUncheckedCreateWithoutPlayerInput = {
    id?: string
    groundId: string
    beastId?: string | null
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
  }

  export type HuntingHistoryCreateOrConnectWithoutPlayerInput = {
    where: HuntingHistoryWhereUniqueInput
    create: XOR<HuntingHistoryCreateWithoutPlayerInput, HuntingHistoryUncheckedCreateWithoutPlayerInput>
  }

  export type HuntingHistoryCreateManyPlayerInputEnvelope = {
    data: HuntingHistoryCreateManyPlayerInput | HuntingHistoryCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type CultivationLogCreateWithoutPlayerInput = {
    id?: string
    type?: string
    description: string
    expGained?: number
    levelGained?: number
    timestamp?: Date | string
  }

  export type CultivationLogUncheckedCreateWithoutPlayerInput = {
    id?: string
    type?: string
    description: string
    expGained?: number
    levelGained?: number
    timestamp?: Date | string
  }

  export type CultivationLogCreateOrConnectWithoutPlayerInput = {
    where: CultivationLogWhereUniqueInput
    create: XOR<CultivationLogCreateWithoutPlayerInput, CultivationLogUncheckedCreateWithoutPlayerInput>
  }

  export type CultivationLogCreateManyPlayerInputEnvelope = {
    data: CultivationLogCreateManyPlayerInput | CultivationLogCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCultivationCreateWithoutPlayerInput = {
    id?: string
    currentRealm?: number
    currentFloor?: number
    currentExp?: number
    totalExpGained?: number
    currentQuality?: string
    eternalTitles?: string
    hasAscended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCultivationUncheckedCreateWithoutPlayerInput = {
    id?: string
    currentRealm?: number
    currentFloor?: number
    currentExp?: number
    totalExpGained?: number
    currentQuality?: string
    eternalTitles?: string
    hasAscended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCultivationCreateOrConnectWithoutPlayerInput = {
    where: PlayerCultivationWhereUniqueInput
    create: XOR<PlayerCultivationCreateWithoutPlayerInput, PlayerCultivationUncheckedCreateWithoutPlayerInput>
  }

  export type UserUpsertWithoutPlayerInput = {
    update: XOR<UserUpdateWithoutPlayerInput, UserUncheckedUpdateWithoutPlayerInput>
    create: XOR<UserCreateWithoutPlayerInput, UserUncheckedCreateWithoutPlayerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayerInput, UserUncheckedUpdateWithoutPlayerInput>
  }

  export type UserUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlayerResourceUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerResourceWhereUniqueInput
    update: XOR<PlayerResourceUpdateWithoutPlayerInput, PlayerResourceUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerResourceCreateWithoutPlayerInput, PlayerResourceUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerResourceUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerResourceWhereUniqueInput
    data: XOR<PlayerResourceUpdateWithoutPlayerInput, PlayerResourceUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerResourceUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerResourceScalarWhereInput
    data: XOR<PlayerResourceUpdateManyMutationInput, PlayerResourceUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerResourceScalarWhereInput = {
    AND?: PlayerResourceScalarWhereInput | PlayerResourceScalarWhereInput[]
    OR?: PlayerResourceScalarWhereInput[]
    NOT?: PlayerResourceScalarWhereInput | PlayerResourceScalarWhereInput[]
    id?: StringFilter<"PlayerResource"> | string
    playerId?: StringFilter<"PlayerResource"> | string
    resourceId?: StringFilter<"PlayerResource"> | string
    amount?: DecimalFilter<"PlayerResource"> | Decimal | DecimalJsLike | number | string
    locked?: DecimalFilter<"PlayerResource"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PlayerResource"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerResource"> | Date | string
  }

  export type PlayerCompanionUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerCompanionWhereUniqueInput
    update: XOR<PlayerCompanionUpdateWithoutPlayerInput, PlayerCompanionUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerCompanionCreateWithoutPlayerInput, PlayerCompanionUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerCompanionUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerCompanionWhereUniqueInput
    data: XOR<PlayerCompanionUpdateWithoutPlayerInput, PlayerCompanionUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerCompanionUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerCompanionScalarWhereInput
    data: XOR<PlayerCompanionUpdateManyMutationInput, PlayerCompanionUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerCompanionScalarWhereInput = {
    AND?: PlayerCompanionScalarWhereInput | PlayerCompanionScalarWhereInput[]
    OR?: PlayerCompanionScalarWhereInput[]
    NOT?: PlayerCompanionScalarWhereInput | PlayerCompanionScalarWhereInput[]
    id?: StringFilter<"PlayerCompanion"> | string
    playerId?: StringFilter<"PlayerCompanion"> | string
    companionId?: StringFilter<"PlayerCompanion"> | string
    level?: IntFilter<"PlayerCompanion"> | number
    power?: IntFilter<"PlayerCompanion"> | number
    isActive?: BoolFilter<"PlayerCompanion"> | boolean
    createdAt?: DateTimeFilter<"PlayerCompanion"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerCompanion"> | Date | string
  }

  export type PlayerAchievementUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerAchievementWhereUniqueInput
    update: XOR<PlayerAchievementUpdateWithoutPlayerInput, PlayerAchievementUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerAchievementCreateWithoutPlayerInput, PlayerAchievementUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerAchievementUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerAchievementWhereUniqueInput
    data: XOR<PlayerAchievementUpdateWithoutPlayerInput, PlayerAchievementUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerAchievementUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerAchievementScalarWhereInput
    data: XOR<PlayerAchievementUpdateManyMutationInput, PlayerAchievementUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerAchievementScalarWhereInput = {
    AND?: PlayerAchievementScalarWhereInput | PlayerAchievementScalarWhereInput[]
    OR?: PlayerAchievementScalarWhereInput[]
    NOT?: PlayerAchievementScalarWhereInput | PlayerAchievementScalarWhereInput[]
    id?: StringFilter<"PlayerAchievement"> | string
    playerId?: StringFilter<"PlayerAchievement"> | string
    achievementId?: StringFilter<"PlayerAchievement"> | string
    unlockedAt?: DateTimeFilter<"PlayerAchievement"> | Date | string
  }

  export type PlayerQuestUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerQuestWhereUniqueInput
    update: XOR<PlayerQuestUpdateWithoutPlayerInput, PlayerQuestUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerQuestCreateWithoutPlayerInput, PlayerQuestUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerQuestUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerQuestWhereUniqueInput
    data: XOR<PlayerQuestUpdateWithoutPlayerInput, PlayerQuestUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerQuestUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerQuestScalarWhereInput
    data: XOR<PlayerQuestUpdateManyMutationInput, PlayerQuestUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerQuestScalarWhereInput = {
    AND?: PlayerQuestScalarWhereInput | PlayerQuestScalarWhereInput[]
    OR?: PlayerQuestScalarWhereInput[]
    NOT?: PlayerQuestScalarWhereInput | PlayerQuestScalarWhereInput[]
    id?: StringFilter<"PlayerQuest"> | string
    playerId?: StringFilter<"PlayerQuest"> | string
    questId?: StringFilter<"PlayerQuest"> | string
    status?: StringFilter<"PlayerQuest"> | string
    progress?: StringNullableFilter<"PlayerQuest"> | string | null
    startedAt?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    lastCompletedAt?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    cooldownUntil?: DateTimeNullableFilter<"PlayerQuest"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerQuest"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerQuest"> | Date | string
  }

  export type PlayerStatsUpsertWithoutPlayerInput = {
    update: XOR<PlayerStatsUpdateWithoutPlayerInput, PlayerStatsUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
    where?: PlayerStatsWhereInput
  }

  export type PlayerStatsUpdateToOneWithWhereWithoutPlayerInput = {
    where?: PlayerStatsWhereInput
    data: XOR<PlayerStatsUpdateWithoutPlayerInput, PlayerStatsUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerStatsUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    hp?: IntFieldUpdateOperationsInput | number
    mp?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    spirit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatsUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    hp?: IntFieldUpdateOperationsInput | number
    mp?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    spirit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerEquipmentWhereUniqueInput
    update: XOR<PlayerEquipmentUpdateWithoutPlayerInput, PlayerEquipmentUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerEquipmentUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerEquipmentWhereUniqueInput
    data: XOR<PlayerEquipmentUpdateWithoutPlayerInput, PlayerEquipmentUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerEquipmentUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerEquipmentScalarWhereInput
    data: XOR<PlayerEquipmentUpdateManyMutationInput, PlayerEquipmentUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerEquipmentScalarWhereInput = {
    AND?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
    OR?: PlayerEquipmentScalarWhereInput[]
    NOT?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
    id?: StringFilter<"PlayerEquipment"> | string
    playerId?: StringFilter<"PlayerEquipment"> | string
    equipmentId?: StringFilter<"PlayerEquipment"> | string
    isEquipped?: BoolFilter<"PlayerEquipment"> | boolean
    durability?: IntFilter<"PlayerEquipment"> | number
    enhancement?: IntFilter<"PlayerEquipment"> | number
    createdAt?: DateTimeFilter<"PlayerEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerEquipment"> | Date | string
  }

  export type PlayerSkillUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerSkillWhereUniqueInput
    update: XOR<PlayerSkillUpdateWithoutPlayerInput, PlayerSkillUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerSkillUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerSkillWhereUniqueInput
    data: XOR<PlayerSkillUpdateWithoutPlayerInput, PlayerSkillUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerSkillUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerSkillScalarWhereInput
    data: XOR<PlayerSkillUpdateManyMutationInput, PlayerSkillUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerSkillScalarWhereInput = {
    AND?: PlayerSkillScalarWhereInput | PlayerSkillScalarWhereInput[]
    OR?: PlayerSkillScalarWhereInput[]
    NOT?: PlayerSkillScalarWhereInput | PlayerSkillScalarWhereInput[]
    id?: StringFilter<"PlayerSkill"> | string
    playerId?: StringFilter<"PlayerSkill"> | string
    skillId?: StringFilter<"PlayerSkill"> | string
    level?: IntFilter<"PlayerSkill"> | number
    isLearned?: BoolFilter<"PlayerSkill"> | boolean
    learnedAt?: DateTimeNullableFilter<"PlayerSkill"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerSkill"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerSkill"> | Date | string
  }

  export type PlayerTalentUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerTalentWhereUniqueInput
    update: XOR<PlayerTalentUpdateWithoutPlayerInput, PlayerTalentUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerTalentCreateWithoutPlayerInput, PlayerTalentUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerTalentUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerTalentWhereUniqueInput
    data: XOR<PlayerTalentUpdateWithoutPlayerInput, PlayerTalentUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerTalentUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerTalentScalarWhereInput
    data: XOR<PlayerTalentUpdateManyMutationInput, PlayerTalentUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerTalentScalarWhereInput = {
    AND?: PlayerTalentScalarWhereInput | PlayerTalentScalarWhereInput[]
    OR?: PlayerTalentScalarWhereInput[]
    NOT?: PlayerTalentScalarWhereInput | PlayerTalentScalarWhereInput[]
    id?: StringFilter<"PlayerTalent"> | string
    playerId?: StringFilter<"PlayerTalent"> | string
    talentId?: StringFilter<"PlayerTalent"> | string
    level?: IntFilter<"PlayerTalent"> | number
    isUnlocked?: BoolFilter<"PlayerTalent"> | boolean
    unlockedAt?: DateTimeNullableFilter<"PlayerTalent"> | Date | string | null
    isActive?: BoolFilter<"PlayerTalent"> | boolean
    createdAt?: DateTimeFilter<"PlayerTalent"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerTalent"> | Date | string
  }

  export type PlayerBuffUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerBuffWhereUniqueInput
    update: XOR<PlayerBuffUpdateWithoutPlayerInput, PlayerBuffUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerBuffCreateWithoutPlayerInput, PlayerBuffUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerBuffUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerBuffWhereUniqueInput
    data: XOR<PlayerBuffUpdateWithoutPlayerInput, PlayerBuffUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerBuffUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerBuffScalarWhereInput
    data: XOR<PlayerBuffUpdateManyMutationInput, PlayerBuffUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerBuffScalarWhereInput = {
    AND?: PlayerBuffScalarWhereInput | PlayerBuffScalarWhereInput[]
    OR?: PlayerBuffScalarWhereInput[]
    NOT?: PlayerBuffScalarWhereInput | PlayerBuffScalarWhereInput[]
    id?: StringFilter<"PlayerBuff"> | string
    playerId?: StringFilter<"PlayerBuff"> | string
    buffId?: StringFilter<"PlayerBuff"> | string
    level?: IntFilter<"PlayerBuff"> | number
    stacks?: IntFilter<"PlayerBuff"> | number
    expiresAt?: DateTimeNullableFilter<"PlayerBuff"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerBuff"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerBuff"> | Date | string
  }

  export type PurchaseHistoryUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PurchaseHistoryWhereUniqueInput
    update: XOR<PurchaseHistoryUpdateWithoutPlayerInput, PurchaseHistoryUncheckedUpdateWithoutPlayerInput>
    create: XOR<PurchaseHistoryCreateWithoutPlayerInput, PurchaseHistoryUncheckedCreateWithoutPlayerInput>
  }

  export type PurchaseHistoryUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PurchaseHistoryWhereUniqueInput
    data: XOR<PurchaseHistoryUpdateWithoutPlayerInput, PurchaseHistoryUncheckedUpdateWithoutPlayerInput>
  }

  export type PurchaseHistoryUpdateManyWithWhereWithoutPlayerInput = {
    where: PurchaseHistoryScalarWhereInput
    data: XOR<PurchaseHistoryUpdateManyMutationInput, PurchaseHistoryUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PurchaseHistoryScalarWhereInput = {
    AND?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
    OR?: PurchaseHistoryScalarWhereInput[]
    NOT?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
    id?: StringFilter<"PurchaseHistory"> | string
    playerId?: StringFilter<"PurchaseHistory"> | string
    shopId?: StringFilter<"PurchaseHistory"> | string
    itemId?: StringFilter<"PurchaseHistory"> | string
    itemName?: StringFilter<"PurchaseHistory"> | string
    quantity?: IntFilter<"PurchaseHistory"> | number
    price?: IntFilter<"PurchaseHistory"> | number
    currency?: StringFilter<"PurchaseHistory"> | string
    totalCost?: IntFilter<"PurchaseHistory"> | number
    createdAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutPlayerInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutPlayerInput, InventoryUncheckedUpdateWithoutPlayerInput>
    create: XOR<InventoryCreateWithoutPlayerInput, InventoryUncheckedCreateWithoutPlayerInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutPlayerInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutPlayerInput, InventoryUncheckedUpdateWithoutPlayerInput>
  }

  export type InventoryUpdateManyWithWhereWithoutPlayerInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutPlayerInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: StringFilter<"Inventory"> | string
    playerId?: StringFilter<"Inventory"> | string
    itemType?: StringFilter<"Inventory"> | string
    itemId?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    quantity?: IntFilter<"Inventory"> | number
    stackable?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
  }

  export type CraftingHistoryUpsertWithWhereUniqueWithoutPlayerInput = {
    where: CraftingHistoryWhereUniqueInput
    update: XOR<CraftingHistoryUpdateWithoutPlayerInput, CraftingHistoryUncheckedUpdateWithoutPlayerInput>
    create: XOR<CraftingHistoryCreateWithoutPlayerInput, CraftingHistoryUncheckedCreateWithoutPlayerInput>
  }

  export type CraftingHistoryUpdateWithWhereUniqueWithoutPlayerInput = {
    where: CraftingHistoryWhereUniqueInput
    data: XOR<CraftingHistoryUpdateWithoutPlayerInput, CraftingHistoryUncheckedUpdateWithoutPlayerInput>
  }

  export type CraftingHistoryUpdateManyWithWhereWithoutPlayerInput = {
    where: CraftingHistoryScalarWhereInput
    data: XOR<CraftingHistoryUpdateManyMutationInput, CraftingHistoryUncheckedUpdateManyWithoutPlayerInput>
  }

  export type CraftingHistoryScalarWhereInput = {
    AND?: CraftingHistoryScalarWhereInput | CraftingHistoryScalarWhereInput[]
    OR?: CraftingHistoryScalarWhereInput[]
    NOT?: CraftingHistoryScalarWhereInput | CraftingHistoryScalarWhereInput[]
    id?: StringFilter<"CraftingHistory"> | string
    playerId?: StringFilter<"CraftingHistory"> | string
    recipeId?: StringFilter<"CraftingHistory"> | string
    success?: BoolFilter<"CraftingHistory"> | boolean
    quantity?: IntFilter<"CraftingHistory"> | number
    materials?: StringFilter<"CraftingHistory"> | string
    result?: StringFilter<"CraftingHistory"> | string
    createdAt?: DateTimeFilter<"CraftingHistory"> | Date | string
  }

  export type PlayerFurnaceUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerFurnaceWhereUniqueInput
    update: XOR<PlayerFurnaceUpdateWithoutPlayerInput, PlayerFurnaceUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerFurnaceCreateWithoutPlayerInput, PlayerFurnaceUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerFurnaceUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerFurnaceWhereUniqueInput
    data: XOR<PlayerFurnaceUpdateWithoutPlayerInput, PlayerFurnaceUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerFurnaceUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerFurnaceScalarWhereInput
    data: XOR<PlayerFurnaceUpdateManyMutationInput, PlayerFurnaceUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerFurnaceScalarWhereInput = {
    AND?: PlayerFurnaceScalarWhereInput | PlayerFurnaceScalarWhereInput[]
    OR?: PlayerFurnaceScalarWhereInput[]
    NOT?: PlayerFurnaceScalarWhereInput | PlayerFurnaceScalarWhereInput[]
    id?: StringFilter<"PlayerFurnace"> | string
    playerId?: StringFilter<"PlayerFurnace"> | string
    furnaceId?: StringFilter<"PlayerFurnace"> | string
    level?: IntFilter<"PlayerFurnace"> | number
    experience?: IntFilter<"PlayerFurnace"> | number
    isActive?: BoolFilter<"PlayerFurnace"> | boolean
    createdAt?: DateTimeFilter<"PlayerFurnace"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerFurnace"> | Date | string
  }

  export type SpiritBeastUpsertWithWhereUniqueWithoutPlayerInput = {
    where: SpiritBeastWhereUniqueInput
    update: XOR<SpiritBeastUpdateWithoutPlayerInput, SpiritBeastUncheckedUpdateWithoutPlayerInput>
    create: XOR<SpiritBeastCreateWithoutPlayerInput, SpiritBeastUncheckedCreateWithoutPlayerInput>
  }

  export type SpiritBeastUpdateWithWhereUniqueWithoutPlayerInput = {
    where: SpiritBeastWhereUniqueInput
    data: XOR<SpiritBeastUpdateWithoutPlayerInput, SpiritBeastUncheckedUpdateWithoutPlayerInput>
  }

  export type SpiritBeastUpdateManyWithWhereWithoutPlayerInput = {
    where: SpiritBeastScalarWhereInput
    data: XOR<SpiritBeastUpdateManyMutationInput, SpiritBeastUncheckedUpdateManyWithoutPlayerInput>
  }

  export type SpiritBeastScalarWhereInput = {
    AND?: SpiritBeastScalarWhereInput | SpiritBeastScalarWhereInput[]
    OR?: SpiritBeastScalarWhereInput[]
    NOT?: SpiritBeastScalarWhereInput | SpiritBeastScalarWhereInput[]
    id?: StringFilter<"SpiritBeast"> | string
    playerId?: StringFilter<"SpiritBeast"> | string
    typeId?: StringFilter<"SpiritBeast"> | string
    name?: StringFilter<"SpiritBeast"> | string
    level?: IntFilter<"SpiritBeast"> | number
    experience?: IntFilter<"SpiritBeast"> | number
    stats?: StringFilter<"SpiritBeast"> | string
    skills?: StringNullableFilter<"SpiritBeast"> | string | null
    happiness?: IntFilter<"SpiritBeast"> | number
    hunger?: IntFilter<"SpiritBeast"> | number
    health?: IntFilter<"SpiritBeast"> | number
    isActive?: BoolFilter<"SpiritBeast"> | boolean
    isFighting?: BoolFilter<"SpiritBeast"> | boolean
    capturedAt?: DateTimeFilter<"SpiritBeast"> | Date | string
    lastFedAt?: DateTimeNullableFilter<"SpiritBeast"> | Date | string | null
    lastPlayedAt?: DateTimeNullableFilter<"SpiritBeast"> | Date | string | null
    createdAt?: DateTimeFilter<"SpiritBeast"> | Date | string
    updatedAt?: DateTimeFilter<"SpiritBeast"> | Date | string
  }

  export type BeastFeedingHistoryUpsertWithWhereUniqueWithoutPlayerInput = {
    where: BeastFeedingHistoryWhereUniqueInput
    update: XOR<BeastFeedingHistoryUpdateWithoutPlayerInput, BeastFeedingHistoryUncheckedUpdateWithoutPlayerInput>
    create: XOR<BeastFeedingHistoryCreateWithoutPlayerInput, BeastFeedingHistoryUncheckedCreateWithoutPlayerInput>
  }

  export type BeastFeedingHistoryUpdateWithWhereUniqueWithoutPlayerInput = {
    where: BeastFeedingHistoryWhereUniqueInput
    data: XOR<BeastFeedingHistoryUpdateWithoutPlayerInput, BeastFeedingHistoryUncheckedUpdateWithoutPlayerInput>
  }

  export type BeastFeedingHistoryUpdateManyWithWhereWithoutPlayerInput = {
    where: BeastFeedingHistoryScalarWhereInput
    data: XOR<BeastFeedingHistoryUpdateManyMutationInput, BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerInput>
  }

  export type BeastFeedingHistoryScalarWhereInput = {
    AND?: BeastFeedingHistoryScalarWhereInput | BeastFeedingHistoryScalarWhereInput[]
    OR?: BeastFeedingHistoryScalarWhereInput[]
    NOT?: BeastFeedingHistoryScalarWhereInput | BeastFeedingHistoryScalarWhereInput[]
    id?: StringFilter<"BeastFeedingHistory"> | string
    playerId?: StringFilter<"BeastFeedingHistory"> | string
    beastId?: StringFilter<"BeastFeedingHistory"> | string
    foodId?: StringFilter<"BeastFeedingHistory"> | string
    quantity?: IntFilter<"BeastFeedingHistory"> | number
    effects?: StringFilter<"BeastFeedingHistory"> | string
    createdAt?: DateTimeFilter<"BeastFeedingHistory"> | Date | string
  }

  export type HuntingHistoryUpsertWithWhereUniqueWithoutPlayerInput = {
    where: HuntingHistoryWhereUniqueInput
    update: XOR<HuntingHistoryUpdateWithoutPlayerInput, HuntingHistoryUncheckedUpdateWithoutPlayerInput>
    create: XOR<HuntingHistoryCreateWithoutPlayerInput, HuntingHistoryUncheckedCreateWithoutPlayerInput>
  }

  export type HuntingHistoryUpdateWithWhereUniqueWithoutPlayerInput = {
    where: HuntingHistoryWhereUniqueInput
    data: XOR<HuntingHistoryUpdateWithoutPlayerInput, HuntingHistoryUncheckedUpdateWithoutPlayerInput>
  }

  export type HuntingHistoryUpdateManyWithWhereWithoutPlayerInput = {
    where: HuntingHistoryScalarWhereInput
    data: XOR<HuntingHistoryUpdateManyMutationInput, HuntingHistoryUncheckedUpdateManyWithoutPlayerInput>
  }

  export type HuntingHistoryScalarWhereInput = {
    AND?: HuntingHistoryScalarWhereInput | HuntingHistoryScalarWhereInput[]
    OR?: HuntingHistoryScalarWhereInput[]
    NOT?: HuntingHistoryScalarWhereInput | HuntingHistoryScalarWhereInput[]
    id?: StringFilter<"HuntingHistory"> | string
    playerId?: StringFilter<"HuntingHistory"> | string
    groundId?: StringFilter<"HuntingHistory"> | string
    beastId?: StringNullableFilter<"HuntingHistory"> | string | null
    success?: BoolFilter<"HuntingHistory"> | boolean
    duration?: IntFilter<"HuntingHistory"> | number
    rewards?: StringNullableFilter<"HuntingHistory"> | string | null
    createdAt?: DateTimeFilter<"HuntingHistory"> | Date | string
  }

  export type CultivationLogUpsertWithWhereUniqueWithoutPlayerInput = {
    where: CultivationLogWhereUniqueInput
    update: XOR<CultivationLogUpdateWithoutPlayerInput, CultivationLogUncheckedUpdateWithoutPlayerInput>
    create: XOR<CultivationLogCreateWithoutPlayerInput, CultivationLogUncheckedCreateWithoutPlayerInput>
  }

  export type CultivationLogUpdateWithWhereUniqueWithoutPlayerInput = {
    where: CultivationLogWhereUniqueInput
    data: XOR<CultivationLogUpdateWithoutPlayerInput, CultivationLogUncheckedUpdateWithoutPlayerInput>
  }

  export type CultivationLogUpdateManyWithWhereWithoutPlayerInput = {
    where: CultivationLogScalarWhereInput
    data: XOR<CultivationLogUpdateManyMutationInput, CultivationLogUncheckedUpdateManyWithoutPlayerInput>
  }

  export type CultivationLogScalarWhereInput = {
    AND?: CultivationLogScalarWhereInput | CultivationLogScalarWhereInput[]
    OR?: CultivationLogScalarWhereInput[]
    NOT?: CultivationLogScalarWhereInput | CultivationLogScalarWhereInput[]
    id?: StringFilter<"CultivationLog"> | string
    playerId?: StringFilter<"CultivationLog"> | string
    type?: StringFilter<"CultivationLog"> | string
    description?: StringFilter<"CultivationLog"> | string
    expGained?: IntFilter<"CultivationLog"> | number
    levelGained?: IntFilter<"CultivationLog"> | number
    timestamp?: DateTimeFilter<"CultivationLog"> | Date | string
  }

  export type PlayerCultivationUpsertWithoutPlayerInput = {
    update: XOR<PlayerCultivationUpdateWithoutPlayerInput, PlayerCultivationUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerCultivationCreateWithoutPlayerInput, PlayerCultivationUncheckedCreateWithoutPlayerInput>
    where?: PlayerCultivationWhereInput
  }

  export type PlayerCultivationUpdateToOneWithWhereWithoutPlayerInput = {
    where?: PlayerCultivationWhereInput
    data: XOR<PlayerCultivationUpdateWithoutPlayerInput, PlayerCultivationUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerCultivationUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRealm?: IntFieldUpdateOperationsInput | number
    currentFloor?: IntFieldUpdateOperationsInput | number
    currentExp?: IntFieldUpdateOperationsInput | number
    totalExpGained?: IntFieldUpdateOperationsInput | number
    currentQuality?: StringFieldUpdateOperationsInput | string
    eternalTitles?: StringFieldUpdateOperationsInput | string
    hasAscended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCultivationUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRealm?: IntFieldUpdateOperationsInput | number
    currentFloor?: IntFieldUpdateOperationsInput | number
    currentExp?: IntFieldUpdateOperationsInput | number
    totalExpGained?: IntFieldUpdateOperationsInput | number
    currentQuality?: StringFieldUpdateOperationsInput | string
    eternalTitles?: StringFieldUpdateOperationsInput | string
    hasAscended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerResourceCreateWithoutResourceInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutResourcesInput
  }

  export type PlayerResourceUncheckedCreateWithoutResourceInput = {
    id?: string
    playerId: string
    amount?: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerResourceCreateOrConnectWithoutResourceInput = {
    where: PlayerResourceWhereUniqueInput
    create: XOR<PlayerResourceCreateWithoutResourceInput, PlayerResourceUncheckedCreateWithoutResourceInput>
  }

  export type PlayerResourceCreateManyResourceInputEnvelope = {
    data: PlayerResourceCreateManyResourceInput | PlayerResourceCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type PlayerResourceUpsertWithWhereUniqueWithoutResourceInput = {
    where: PlayerResourceWhereUniqueInput
    update: XOR<PlayerResourceUpdateWithoutResourceInput, PlayerResourceUncheckedUpdateWithoutResourceInput>
    create: XOR<PlayerResourceCreateWithoutResourceInput, PlayerResourceUncheckedCreateWithoutResourceInput>
  }

  export type PlayerResourceUpdateWithWhereUniqueWithoutResourceInput = {
    where: PlayerResourceWhereUniqueInput
    data: XOR<PlayerResourceUpdateWithoutResourceInput, PlayerResourceUncheckedUpdateWithoutResourceInput>
  }

  export type PlayerResourceUpdateManyWithWhereWithoutResourceInput = {
    where: PlayerResourceScalarWhereInput
    data: XOR<PlayerResourceUpdateManyMutationInput, PlayerResourceUncheckedUpdateManyWithoutResourceInput>
  }

  export type PlayerCreateWithoutResourcesInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutResourcesInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutResourcesInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutResourcesInput, PlayerUncheckedCreateWithoutResourcesInput>
  }

  export type ResourceCreateWithoutPlayerResourcesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUncheckedCreateWithoutPlayerResourcesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceCreateOrConnectWithoutPlayerResourcesInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutPlayerResourcesInput, ResourceUncheckedCreateWithoutPlayerResourcesInput>
  }

  export type PlayerUpsertWithoutResourcesInput = {
    update: XOR<PlayerUpdateWithoutResourcesInput, PlayerUncheckedUpdateWithoutResourcesInput>
    create: XOR<PlayerCreateWithoutResourcesInput, PlayerUncheckedCreateWithoutResourcesInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutResourcesInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutResourcesInput, PlayerUncheckedUpdateWithoutResourcesInput>
  }

  export type PlayerUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type ResourceUpsertWithoutPlayerResourcesInput = {
    update: XOR<ResourceUpdateWithoutPlayerResourcesInput, ResourceUncheckedUpdateWithoutPlayerResourcesInput>
    create: XOR<ResourceCreateWithoutPlayerResourcesInput, ResourceUncheckedCreateWithoutPlayerResourcesInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutPlayerResourcesInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutPlayerResourcesInput, ResourceUncheckedUpdateWithoutPlayerResourcesInput>
  }

  export type ResourceUpdateWithoutPlayerResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateWithoutPlayerResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCompanionCreateWithoutCompanionInput = {
    id?: string
    level?: number
    power?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutCompanionsInput
  }

  export type PlayerCompanionUncheckedCreateWithoutCompanionInput = {
    id?: string
    playerId: string
    level?: number
    power?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCompanionCreateOrConnectWithoutCompanionInput = {
    where: PlayerCompanionWhereUniqueInput
    create: XOR<PlayerCompanionCreateWithoutCompanionInput, PlayerCompanionUncheckedCreateWithoutCompanionInput>
  }

  export type PlayerCompanionCreateManyCompanionInputEnvelope = {
    data: PlayerCompanionCreateManyCompanionInput | PlayerCompanionCreateManyCompanionInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCompanionUpsertWithWhereUniqueWithoutCompanionInput = {
    where: PlayerCompanionWhereUniqueInput
    update: XOR<PlayerCompanionUpdateWithoutCompanionInput, PlayerCompanionUncheckedUpdateWithoutCompanionInput>
    create: XOR<PlayerCompanionCreateWithoutCompanionInput, PlayerCompanionUncheckedCreateWithoutCompanionInput>
  }

  export type PlayerCompanionUpdateWithWhereUniqueWithoutCompanionInput = {
    where: PlayerCompanionWhereUniqueInput
    data: XOR<PlayerCompanionUpdateWithoutCompanionInput, PlayerCompanionUncheckedUpdateWithoutCompanionInput>
  }

  export type PlayerCompanionUpdateManyWithWhereWithoutCompanionInput = {
    where: PlayerCompanionScalarWhereInput
    data: XOR<PlayerCompanionUpdateManyMutationInput, PlayerCompanionUncheckedUpdateManyWithoutCompanionInput>
  }

  export type PlayerCreateWithoutCompanionsInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutCompanionsInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutCompanionsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutCompanionsInput, PlayerUncheckedCreateWithoutCompanionsInput>
  }

  export type CompanionCreateWithoutPlayerCompanionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    rarity?: string
    basePower?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanionUncheckedCreateWithoutPlayerCompanionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    rarity?: string
    basePower?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanionCreateOrConnectWithoutPlayerCompanionsInput = {
    where: CompanionWhereUniqueInput
    create: XOR<CompanionCreateWithoutPlayerCompanionsInput, CompanionUncheckedCreateWithoutPlayerCompanionsInput>
  }

  export type PlayerUpsertWithoutCompanionsInput = {
    update: XOR<PlayerUpdateWithoutCompanionsInput, PlayerUncheckedUpdateWithoutCompanionsInput>
    create: XOR<PlayerCreateWithoutCompanionsInput, PlayerUncheckedCreateWithoutCompanionsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutCompanionsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutCompanionsInput, PlayerUncheckedUpdateWithoutCompanionsInput>
  }

  export type PlayerUpdateWithoutCompanionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutCompanionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type CompanionUpsertWithoutPlayerCompanionsInput = {
    update: XOR<CompanionUpdateWithoutPlayerCompanionsInput, CompanionUncheckedUpdateWithoutPlayerCompanionsInput>
    create: XOR<CompanionCreateWithoutPlayerCompanionsInput, CompanionUncheckedCreateWithoutPlayerCompanionsInput>
    where?: CompanionWhereInput
  }

  export type CompanionUpdateToOneWithWhereWithoutPlayerCompanionsInput = {
    where?: CompanionWhereInput
    data: XOR<CompanionUpdateWithoutPlayerCompanionsInput, CompanionUncheckedUpdateWithoutPlayerCompanionsInput>
  }

  export type CompanionUpdateWithoutPlayerCompanionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    basePower?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanionUncheckedUpdateWithoutPlayerCompanionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    basePower?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerAchievementCreateWithoutAchievementInput = {
    id?: string
    unlockedAt?: Date | string
    player: PlayerCreateNestedOneWithoutAchievementsInput
  }

  export type PlayerAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    playerId: string
    unlockedAt?: Date | string
  }

  export type PlayerAchievementCreateOrConnectWithoutAchievementInput = {
    where: PlayerAchievementWhereUniqueInput
    create: XOR<PlayerAchievementCreateWithoutAchievementInput, PlayerAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type PlayerAchievementCreateManyAchievementInputEnvelope = {
    data: PlayerAchievementCreateManyAchievementInput | PlayerAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type PlayerAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: PlayerAchievementWhereUniqueInput
    update: XOR<PlayerAchievementUpdateWithoutAchievementInput, PlayerAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<PlayerAchievementCreateWithoutAchievementInput, PlayerAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type PlayerAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: PlayerAchievementWhereUniqueInput
    data: XOR<PlayerAchievementUpdateWithoutAchievementInput, PlayerAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type PlayerAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: PlayerAchievementScalarWhereInput
    data: XOR<PlayerAchievementUpdateManyMutationInput, PlayerAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type PlayerCreateWithoutAchievementsInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutAchievementsInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutAchievementsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutAchievementsInput, PlayerUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutPlayerAchievementsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    category?: string
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutPlayerAchievementsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    category?: string
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutPlayerAchievementsInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutPlayerAchievementsInput, AchievementUncheckedCreateWithoutPlayerAchievementsInput>
  }

  export type PlayerUpsertWithoutAchievementsInput = {
    update: XOR<PlayerUpdateWithoutAchievementsInput, PlayerUncheckedUpdateWithoutAchievementsInput>
    create: XOR<PlayerCreateWithoutAchievementsInput, PlayerUncheckedCreateWithoutAchievementsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutAchievementsInput, PlayerUncheckedUpdateWithoutAchievementsInput>
  }

  export type PlayerUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type AchievementUpsertWithoutPlayerAchievementsInput = {
    update: XOR<AchievementUpdateWithoutPlayerAchievementsInput, AchievementUncheckedUpdateWithoutPlayerAchievementsInput>
    create: XOR<AchievementCreateWithoutPlayerAchievementsInput, AchievementUncheckedCreateWithoutPlayerAchievementsInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutPlayerAchievementsInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutPlayerAchievementsInput, AchievementUncheckedUpdateWithoutPlayerAchievementsInput>
  }

  export type AchievementUpdateWithoutPlayerAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutPlayerAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerQuestCreateWithoutQuestInput = {
    id?: string
    status?: string
    progress?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lastCompletedAt?: Date | string | null
    cooldownUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutQuestsInput
  }

  export type PlayerQuestUncheckedCreateWithoutQuestInput = {
    id?: string
    playerId: string
    status?: string
    progress?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lastCompletedAt?: Date | string | null
    cooldownUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerQuestCreateOrConnectWithoutQuestInput = {
    where: PlayerQuestWhereUniqueInput
    create: XOR<PlayerQuestCreateWithoutQuestInput, PlayerQuestUncheckedCreateWithoutQuestInput>
  }

  export type PlayerQuestCreateManyQuestInputEnvelope = {
    data: PlayerQuestCreateManyQuestInput | PlayerQuestCreateManyQuestInput[]
    skipDuplicates?: boolean
  }

  export type PlayerQuestUpsertWithWhereUniqueWithoutQuestInput = {
    where: PlayerQuestWhereUniqueInput
    update: XOR<PlayerQuestUpdateWithoutQuestInput, PlayerQuestUncheckedUpdateWithoutQuestInput>
    create: XOR<PlayerQuestCreateWithoutQuestInput, PlayerQuestUncheckedCreateWithoutQuestInput>
  }

  export type PlayerQuestUpdateWithWhereUniqueWithoutQuestInput = {
    where: PlayerQuestWhereUniqueInput
    data: XOR<PlayerQuestUpdateWithoutQuestInput, PlayerQuestUncheckedUpdateWithoutQuestInput>
  }

  export type PlayerQuestUpdateManyWithWhereWithoutQuestInput = {
    where: PlayerQuestScalarWhereInput
    data: XOR<PlayerQuestUpdateManyMutationInput, PlayerQuestUncheckedUpdateManyWithoutQuestInput>
  }

  export type PlayerCreateWithoutQuestsInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutQuestsInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutQuestsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutQuestsInput, PlayerUncheckedCreateWithoutQuestsInput>
  }

  export type QuestCreateWithoutPlayerQuestsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    difficulty?: string
    rewards?: string | null
    requirements?: string | null
    isActive?: boolean
    isRepeatable?: boolean
    repeatInterval?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestUncheckedCreateWithoutPlayerQuestsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    difficulty?: string
    rewards?: string | null
    requirements?: string | null
    isActive?: boolean
    isRepeatable?: boolean
    repeatInterval?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestCreateOrConnectWithoutPlayerQuestsInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutPlayerQuestsInput, QuestUncheckedCreateWithoutPlayerQuestsInput>
  }

  export type PlayerUpsertWithoutQuestsInput = {
    update: XOR<PlayerUpdateWithoutQuestsInput, PlayerUncheckedUpdateWithoutQuestsInput>
    create: XOR<PlayerCreateWithoutQuestsInput, PlayerUncheckedCreateWithoutQuestsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutQuestsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutQuestsInput, PlayerUncheckedUpdateWithoutQuestsInput>
  }

  export type PlayerUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type QuestUpsertWithoutPlayerQuestsInput = {
    update: XOR<QuestUpdateWithoutPlayerQuestsInput, QuestUncheckedUpdateWithoutPlayerQuestsInput>
    create: XOR<QuestCreateWithoutPlayerQuestsInput, QuestUncheckedCreateWithoutPlayerQuestsInput>
    where?: QuestWhereInput
  }

  export type QuestUpdateToOneWithWhereWithoutPlayerQuestsInput = {
    where?: QuestWhereInput
    data: XOR<QuestUpdateWithoutPlayerQuestsInput, QuestUncheckedUpdateWithoutPlayerQuestsInput>
  }

  export type QuestUpdateWithoutPlayerQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRepeatable?: BoolFieldUpdateOperationsInput | boolean
    repeatInterval?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestUncheckedUpdateWithoutPlayerQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRepeatable?: BoolFieldUpdateOperationsInput | boolean
    repeatInterval?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCreateWithoutStatsInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutStatsInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutStatsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
  }

  export type PlayerUpsertWithoutStatsInput = {
    update: XOR<PlayerUpdateWithoutStatsInput, PlayerUncheckedUpdateWithoutStatsInput>
    create: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutStatsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutStatsInput, PlayerUncheckedUpdateWithoutStatsInput>
  }

  export type PlayerUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type EquipmentCreateWithoutTypeInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    rarity?: string
    level?: number
    stats?: string | null
    requirements?: string | null
    price?: number
    isTradeable?: boolean
    isSellable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerEquipments?: PlayerEquipmentCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutTypeInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    rarity?: string
    level?: number
    stats?: string | null
    requirements?: string | null
    price?: number
    isTradeable?: boolean
    isSellable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerEquipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutTypeInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutTypeInput, EquipmentUncheckedCreateWithoutTypeInput>
  }

  export type EquipmentCreateManyTypeInputEnvelope = {
    data: EquipmentCreateManyTypeInput | EquipmentCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentUpsertWithWhereUniqueWithoutTypeInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutTypeInput, EquipmentUncheckedUpdateWithoutTypeInput>
    create: XOR<EquipmentCreateWithoutTypeInput, EquipmentUncheckedCreateWithoutTypeInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutTypeInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutTypeInput, EquipmentUncheckedUpdateWithoutTypeInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutTypeInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutTypeInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    OR?: EquipmentScalarWhereInput[]
    NOT?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    id?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    displayName?: StringFilter<"Equipment"> | string
    description?: StringNullableFilter<"Equipment"> | string | null
    typeId?: StringFilter<"Equipment"> | string
    rarity?: StringFilter<"Equipment"> | string
    level?: IntFilter<"Equipment"> | number
    stats?: StringNullableFilter<"Equipment"> | string | null
    requirements?: StringNullableFilter<"Equipment"> | string | null
    price?: IntFilter<"Equipment"> | number
    isTradeable?: BoolFilter<"Equipment"> | boolean
    isSellable?: BoolFilter<"Equipment"> | boolean
    icon?: StringNullableFilter<"Equipment"> | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
  }

  export type EquipmentTypeCreateWithoutEquipmentsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    slot: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentTypeUncheckedCreateWithoutEquipmentsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    slot: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentTypeCreateOrConnectWithoutEquipmentsInput = {
    where: EquipmentTypeWhereUniqueInput
    create: XOR<EquipmentTypeCreateWithoutEquipmentsInput, EquipmentTypeUncheckedCreateWithoutEquipmentsInput>
  }

  export type PlayerEquipmentCreateWithoutEquipmentInput = {
    id?: string
    isEquipped?: boolean
    durability?: number
    enhancement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutEquipmentsInput
  }

  export type PlayerEquipmentUncheckedCreateWithoutEquipmentInput = {
    id?: string
    playerId: string
    isEquipped?: boolean
    durability?: number
    enhancement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerEquipmentCreateOrConnectWithoutEquipmentInput = {
    where: PlayerEquipmentWhereUniqueInput
    create: XOR<PlayerEquipmentCreateWithoutEquipmentInput, PlayerEquipmentUncheckedCreateWithoutEquipmentInput>
  }

  export type PlayerEquipmentCreateManyEquipmentInputEnvelope = {
    data: PlayerEquipmentCreateManyEquipmentInput | PlayerEquipmentCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentTypeUpsertWithoutEquipmentsInput = {
    update: XOR<EquipmentTypeUpdateWithoutEquipmentsInput, EquipmentTypeUncheckedUpdateWithoutEquipmentsInput>
    create: XOR<EquipmentTypeCreateWithoutEquipmentsInput, EquipmentTypeUncheckedCreateWithoutEquipmentsInput>
    where?: EquipmentTypeWhereInput
  }

  export type EquipmentTypeUpdateToOneWithWhereWithoutEquipmentsInput = {
    where?: EquipmentTypeWhereInput
    data: XOR<EquipmentTypeUpdateWithoutEquipmentsInput, EquipmentTypeUncheckedUpdateWithoutEquipmentsInput>
  }

  export type EquipmentTypeUpdateWithoutEquipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentTypeUncheckedUpdateWithoutEquipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: PlayerEquipmentWhereUniqueInput
    update: XOR<PlayerEquipmentUpdateWithoutEquipmentInput, PlayerEquipmentUncheckedUpdateWithoutEquipmentInput>
    create: XOR<PlayerEquipmentCreateWithoutEquipmentInput, PlayerEquipmentUncheckedCreateWithoutEquipmentInput>
  }

  export type PlayerEquipmentUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: PlayerEquipmentWhereUniqueInput
    data: XOR<PlayerEquipmentUpdateWithoutEquipmentInput, PlayerEquipmentUncheckedUpdateWithoutEquipmentInput>
  }

  export type PlayerEquipmentUpdateManyWithWhereWithoutEquipmentInput = {
    where: PlayerEquipmentScalarWhereInput
    data: XOR<PlayerEquipmentUpdateManyMutationInput, PlayerEquipmentUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type PlayerCreateWithoutEquipmentsInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutEquipmentsInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutEquipmentsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutEquipmentsInput, PlayerUncheckedCreateWithoutEquipmentsInput>
  }

  export type EquipmentCreateWithoutPlayerEquipmentsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    rarity?: string
    level?: number
    stats?: string | null
    requirements?: string | null
    price?: number
    isTradeable?: boolean
    isSellable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: EquipmentTypeCreateNestedOneWithoutEquipmentsInput
  }

  export type EquipmentUncheckedCreateWithoutPlayerEquipmentsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    typeId: string
    rarity?: string
    level?: number
    stats?: string | null
    requirements?: string | null
    price?: number
    isTradeable?: boolean
    isSellable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutPlayerEquipmentsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutPlayerEquipmentsInput, EquipmentUncheckedCreateWithoutPlayerEquipmentsInput>
  }

  export type PlayerUpsertWithoutEquipmentsInput = {
    update: XOR<PlayerUpdateWithoutEquipmentsInput, PlayerUncheckedUpdateWithoutEquipmentsInput>
    create: XOR<PlayerCreateWithoutEquipmentsInput, PlayerUncheckedCreateWithoutEquipmentsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutEquipmentsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutEquipmentsInput, PlayerUncheckedUpdateWithoutEquipmentsInput>
  }

  export type PlayerUpdateWithoutEquipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutEquipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type EquipmentUpsertWithoutPlayerEquipmentsInput = {
    update: XOR<EquipmentUpdateWithoutPlayerEquipmentsInput, EquipmentUncheckedUpdateWithoutPlayerEquipmentsInput>
    create: XOR<EquipmentCreateWithoutPlayerEquipmentsInput, EquipmentUncheckedCreateWithoutPlayerEquipmentsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutPlayerEquipmentsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutPlayerEquipmentsInput, EquipmentUncheckedUpdateWithoutPlayerEquipmentsInput>
  }

  export type EquipmentUpdateWithoutPlayerEquipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isTradeable?: BoolFieldUpdateOperationsInput | boolean
    isSellable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EquipmentTypeUpdateOneRequiredWithoutEquipmentsNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutPlayerEquipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isTradeable?: BoolFieldUpdateOperationsInput | boolean
    isSellable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillCreateWithoutSkillInput = {
    id?: string
    level?: number
    isLearned?: boolean
    learnedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutSkillsInput
  }

  export type PlayerSkillUncheckedCreateWithoutSkillInput = {
    id?: string
    playerId: string
    level?: number
    isLearned?: boolean
    learnedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerSkillCreateOrConnectWithoutSkillInput = {
    where: PlayerSkillWhereUniqueInput
    create: XOR<PlayerSkillCreateWithoutSkillInput, PlayerSkillUncheckedCreateWithoutSkillInput>
  }

  export type PlayerSkillCreateManySkillInputEnvelope = {
    data: PlayerSkillCreateManySkillInput | PlayerSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type PlayerSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: PlayerSkillWhereUniqueInput
    update: XOR<PlayerSkillUpdateWithoutSkillInput, PlayerSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<PlayerSkillCreateWithoutSkillInput, PlayerSkillUncheckedCreateWithoutSkillInput>
  }

  export type PlayerSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: PlayerSkillWhereUniqueInput
    data: XOR<PlayerSkillUpdateWithoutSkillInput, PlayerSkillUncheckedUpdateWithoutSkillInput>
  }

  export type PlayerSkillUpdateManyWithWhereWithoutSkillInput = {
    where: PlayerSkillScalarWhereInput
    data: XOR<PlayerSkillUpdateManyMutationInput, PlayerSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type PlayerCreateWithoutSkillsInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutSkillsInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutSkillsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutPlayerSkillsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    type?: string
    level?: number
    maxLevel?: number
    cooldown?: number
    mpCost?: number
    damage?: number
    effects?: string | null
    requirements?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillUncheckedCreateWithoutPlayerSkillsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    type?: string
    level?: number
    maxLevel?: number
    cooldown?: number
    mpCost?: number
    damage?: number
    effects?: string | null
    requirements?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillCreateOrConnectWithoutPlayerSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutPlayerSkillsInput, SkillUncheckedCreateWithoutPlayerSkillsInput>
  }

  export type PlayerUpsertWithoutSkillsInput = {
    update: XOR<PlayerUpdateWithoutSkillsInput, PlayerUncheckedUpdateWithoutSkillsInput>
    create: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutSkillsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutSkillsInput, PlayerUncheckedUpdateWithoutSkillsInput>
  }

  export type PlayerUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type SkillUpsertWithoutPlayerSkillsInput = {
    update: XOR<SkillUpdateWithoutPlayerSkillsInput, SkillUncheckedUpdateWithoutPlayerSkillsInput>
    create: XOR<SkillCreateWithoutPlayerSkillsInput, SkillUncheckedCreateWithoutPlayerSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutPlayerSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutPlayerSkillsInput, SkillUncheckedUpdateWithoutPlayerSkillsInput>
  }

  export type SkillUpdateWithoutPlayerSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    cooldown?: IntFieldUpdateOperationsInput | number
    mpCost?: IntFieldUpdateOperationsInput | number
    damage?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateWithoutPlayerSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    cooldown?: IntFieldUpdateOperationsInput | number
    mpCost?: IntFieldUpdateOperationsInput | number
    damage?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TalentCreateWithoutTypeInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    rarity?: string
    level?: number
    maxLevel?: number
    effects?: string | null
    requirements?: string | null
    cost?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerTalents?: PlayerTalentCreateNestedManyWithoutTalentInput
  }

  export type TalentUncheckedCreateWithoutTypeInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    rarity?: string
    level?: number
    maxLevel?: number
    effects?: string | null
    requirements?: string | null
    cost?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerTalents?: PlayerTalentUncheckedCreateNestedManyWithoutTalentInput
  }

  export type TalentCreateOrConnectWithoutTypeInput = {
    where: TalentWhereUniqueInput
    create: XOR<TalentCreateWithoutTypeInput, TalentUncheckedCreateWithoutTypeInput>
  }

  export type TalentCreateManyTypeInputEnvelope = {
    data: TalentCreateManyTypeInput | TalentCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type TalentUpsertWithWhereUniqueWithoutTypeInput = {
    where: TalentWhereUniqueInput
    update: XOR<TalentUpdateWithoutTypeInput, TalentUncheckedUpdateWithoutTypeInput>
    create: XOR<TalentCreateWithoutTypeInput, TalentUncheckedCreateWithoutTypeInput>
  }

  export type TalentUpdateWithWhereUniqueWithoutTypeInput = {
    where: TalentWhereUniqueInput
    data: XOR<TalentUpdateWithoutTypeInput, TalentUncheckedUpdateWithoutTypeInput>
  }

  export type TalentUpdateManyWithWhereWithoutTypeInput = {
    where: TalentScalarWhereInput
    data: XOR<TalentUpdateManyMutationInput, TalentUncheckedUpdateManyWithoutTypeInput>
  }

  export type TalentScalarWhereInput = {
    AND?: TalentScalarWhereInput | TalentScalarWhereInput[]
    OR?: TalentScalarWhereInput[]
    NOT?: TalentScalarWhereInput | TalentScalarWhereInput[]
    id?: StringFilter<"Talent"> | string
    name?: StringFilter<"Talent"> | string
    displayName?: StringFilter<"Talent"> | string
    description?: StringNullableFilter<"Talent"> | string | null
    typeId?: StringFilter<"Talent"> | string
    rarity?: StringFilter<"Talent"> | string
    level?: IntFilter<"Talent"> | number
    maxLevel?: IntFilter<"Talent"> | number
    effects?: StringNullableFilter<"Talent"> | string | null
    requirements?: StringNullableFilter<"Talent"> | string | null
    cost?: IntFilter<"Talent"> | number
    isActive?: BoolFilter<"Talent"> | boolean
    icon?: StringNullableFilter<"Talent"> | string | null
    createdAt?: DateTimeFilter<"Talent"> | Date | string
    updatedAt?: DateTimeFilter<"Talent"> | Date | string
  }

  export type TalentTypeCreateWithoutTalentsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TalentTypeUncheckedCreateWithoutTalentsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TalentTypeCreateOrConnectWithoutTalentsInput = {
    where: TalentTypeWhereUniqueInput
    create: XOR<TalentTypeCreateWithoutTalentsInput, TalentTypeUncheckedCreateWithoutTalentsInput>
  }

  export type PlayerTalentCreateWithoutTalentInput = {
    id?: string
    level?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutTalentsInput
  }

  export type PlayerTalentUncheckedCreateWithoutTalentInput = {
    id?: string
    playerId: string
    level?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerTalentCreateOrConnectWithoutTalentInput = {
    where: PlayerTalentWhereUniqueInput
    create: XOR<PlayerTalentCreateWithoutTalentInput, PlayerTalentUncheckedCreateWithoutTalentInput>
  }

  export type PlayerTalentCreateManyTalentInputEnvelope = {
    data: PlayerTalentCreateManyTalentInput | PlayerTalentCreateManyTalentInput[]
    skipDuplicates?: boolean
  }

  export type TalentTypeUpsertWithoutTalentsInput = {
    update: XOR<TalentTypeUpdateWithoutTalentsInput, TalentTypeUncheckedUpdateWithoutTalentsInput>
    create: XOR<TalentTypeCreateWithoutTalentsInput, TalentTypeUncheckedCreateWithoutTalentsInput>
    where?: TalentTypeWhereInput
  }

  export type TalentTypeUpdateToOneWithWhereWithoutTalentsInput = {
    where?: TalentTypeWhereInput
    data: XOR<TalentTypeUpdateWithoutTalentsInput, TalentTypeUncheckedUpdateWithoutTalentsInput>
  }

  export type TalentTypeUpdateWithoutTalentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TalentTypeUncheckedUpdateWithoutTalentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerTalentUpsertWithWhereUniqueWithoutTalentInput = {
    where: PlayerTalentWhereUniqueInput
    update: XOR<PlayerTalentUpdateWithoutTalentInput, PlayerTalentUncheckedUpdateWithoutTalentInput>
    create: XOR<PlayerTalentCreateWithoutTalentInput, PlayerTalentUncheckedCreateWithoutTalentInput>
  }

  export type PlayerTalentUpdateWithWhereUniqueWithoutTalentInput = {
    where: PlayerTalentWhereUniqueInput
    data: XOR<PlayerTalentUpdateWithoutTalentInput, PlayerTalentUncheckedUpdateWithoutTalentInput>
  }

  export type PlayerTalentUpdateManyWithWhereWithoutTalentInput = {
    where: PlayerTalentScalarWhereInput
    data: XOR<PlayerTalentUpdateManyMutationInput, PlayerTalentUncheckedUpdateManyWithoutTalentInput>
  }

  export type PlayerCreateWithoutTalentsInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutTalentsInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutTalentsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutTalentsInput, PlayerUncheckedCreateWithoutTalentsInput>
  }

  export type TalentCreateWithoutPlayerTalentsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    rarity?: string
    level?: number
    maxLevel?: number
    effects?: string | null
    requirements?: string | null
    cost?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: TalentTypeCreateNestedOneWithoutTalentsInput
  }

  export type TalentUncheckedCreateWithoutPlayerTalentsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    typeId: string
    rarity?: string
    level?: number
    maxLevel?: number
    effects?: string | null
    requirements?: string | null
    cost?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TalentCreateOrConnectWithoutPlayerTalentsInput = {
    where: TalentWhereUniqueInput
    create: XOR<TalentCreateWithoutPlayerTalentsInput, TalentUncheckedCreateWithoutPlayerTalentsInput>
  }

  export type PlayerUpsertWithoutTalentsInput = {
    update: XOR<PlayerUpdateWithoutTalentsInput, PlayerUncheckedUpdateWithoutTalentsInput>
    create: XOR<PlayerCreateWithoutTalentsInput, PlayerUncheckedCreateWithoutTalentsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutTalentsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutTalentsInput, PlayerUncheckedUpdateWithoutTalentsInput>
  }

  export type PlayerUpdateWithoutTalentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutTalentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type TalentUpsertWithoutPlayerTalentsInput = {
    update: XOR<TalentUpdateWithoutPlayerTalentsInput, TalentUncheckedUpdateWithoutPlayerTalentsInput>
    create: XOR<TalentCreateWithoutPlayerTalentsInput, TalentUncheckedCreateWithoutPlayerTalentsInput>
    where?: TalentWhereInput
  }

  export type TalentUpdateToOneWithWhereWithoutPlayerTalentsInput = {
    where?: TalentWhereInput
    data: XOR<TalentUpdateWithoutPlayerTalentsInput, TalentUncheckedUpdateWithoutPlayerTalentsInput>
  }

  export type TalentUpdateWithoutPlayerTalentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: TalentTypeUpdateOneRequiredWithoutTalentsNestedInput
  }

  export type TalentUncheckedUpdateWithoutPlayerTalentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: StringFieldUpdateOperationsInput | string
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBuffCreateWithoutBuffInput = {
    id?: string
    level?: number
    stacks?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutBuffsInput
  }

  export type PlayerBuffUncheckedCreateWithoutBuffInput = {
    id?: string
    playerId: string
    level?: number
    stacks?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerBuffCreateOrConnectWithoutBuffInput = {
    where: PlayerBuffWhereUniqueInput
    create: XOR<PlayerBuffCreateWithoutBuffInput, PlayerBuffUncheckedCreateWithoutBuffInput>
  }

  export type PlayerBuffCreateManyBuffInputEnvelope = {
    data: PlayerBuffCreateManyBuffInput | PlayerBuffCreateManyBuffInput[]
    skipDuplicates?: boolean
  }

  export type PlayerBuffUpsertWithWhereUniqueWithoutBuffInput = {
    where: PlayerBuffWhereUniqueInput
    update: XOR<PlayerBuffUpdateWithoutBuffInput, PlayerBuffUncheckedUpdateWithoutBuffInput>
    create: XOR<PlayerBuffCreateWithoutBuffInput, PlayerBuffUncheckedCreateWithoutBuffInput>
  }

  export type PlayerBuffUpdateWithWhereUniqueWithoutBuffInput = {
    where: PlayerBuffWhereUniqueInput
    data: XOR<PlayerBuffUpdateWithoutBuffInput, PlayerBuffUncheckedUpdateWithoutBuffInput>
  }

  export type PlayerBuffUpdateManyWithWhereWithoutBuffInput = {
    where: PlayerBuffScalarWhereInput
    data: XOR<PlayerBuffUpdateManyMutationInput, PlayerBuffUncheckedUpdateManyWithoutBuffInput>
  }

  export type PlayerCreateWithoutBuffsInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutBuffsInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutBuffsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutBuffsInput, PlayerUncheckedCreateWithoutBuffsInput>
  }

  export type BuffCreateWithoutPlayerBuffsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    type?: string
    category?: string
    effects?: string | null
    duration?: number
    stackable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuffUncheckedCreateWithoutPlayerBuffsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    type?: string
    category?: string
    effects?: string | null
    duration?: number
    stackable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuffCreateOrConnectWithoutPlayerBuffsInput = {
    where: BuffWhereUniqueInput
    create: XOR<BuffCreateWithoutPlayerBuffsInput, BuffUncheckedCreateWithoutPlayerBuffsInput>
  }

  export type PlayerUpsertWithoutBuffsInput = {
    update: XOR<PlayerUpdateWithoutBuffsInput, PlayerUncheckedUpdateWithoutBuffsInput>
    create: XOR<PlayerCreateWithoutBuffsInput, PlayerUncheckedCreateWithoutBuffsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutBuffsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutBuffsInput, PlayerUncheckedUpdateWithoutBuffsInput>
  }

  export type PlayerUpdateWithoutBuffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutBuffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type BuffUpsertWithoutPlayerBuffsInput = {
    update: XOR<BuffUpdateWithoutPlayerBuffsInput, BuffUncheckedUpdateWithoutPlayerBuffsInput>
    create: XOR<BuffCreateWithoutPlayerBuffsInput, BuffUncheckedCreateWithoutPlayerBuffsInput>
    where?: BuffWhereInput
  }

  export type BuffUpdateToOneWithWhereWithoutPlayerBuffsInput = {
    where?: BuffWhereInput
    data: XOR<BuffUpdateWithoutPlayerBuffsInput, BuffUncheckedUpdateWithoutPlayerBuffsInput>
  }

  export type BuffUpdateWithoutPlayerBuffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuffUncheckedUpdateWithoutPlayerBuffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemCreateWithoutShopInput = {
    id?: string
    itemType: string
    itemId: string
    name: string
    displayName: string
    description?: string | null
    price: number
    currency?: string
    stock?: number
    isActive?: boolean
    level?: number
    rarity?: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopItemUncheckedCreateWithoutShopInput = {
    id?: string
    itemType: string
    itemId: string
    name: string
    displayName: string
    description?: string | null
    price: number
    currency?: string
    stock?: number
    isActive?: boolean
    level?: number
    rarity?: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopItemCreateOrConnectWithoutShopInput = {
    where: ShopItemWhereUniqueInput
    create: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput>
  }

  export type ShopItemCreateManyShopInputEnvelope = {
    data: ShopItemCreateManyShopInput | ShopItemCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseHistoryCreateWithoutShopInput = {
    id?: string
    itemId: string
    itemName: string
    quantity?: number
    price: number
    currency: string
    totalCost: number
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseHistoryUncheckedCreateWithoutShopInput = {
    id?: string
    playerId: string
    itemId: string
    itemName: string
    quantity?: number
    price: number
    currency: string
    totalCost: number
    createdAt?: Date | string
  }

  export type PurchaseHistoryCreateOrConnectWithoutShopInput = {
    where: PurchaseHistoryWhereUniqueInput
    create: XOR<PurchaseHistoryCreateWithoutShopInput, PurchaseHistoryUncheckedCreateWithoutShopInput>
  }

  export type PurchaseHistoryCreateManyShopInputEnvelope = {
    data: PurchaseHistoryCreateManyShopInput | PurchaseHistoryCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type ShopItemUpsertWithWhereUniqueWithoutShopInput = {
    where: ShopItemWhereUniqueInput
    update: XOR<ShopItemUpdateWithoutShopInput, ShopItemUncheckedUpdateWithoutShopInput>
    create: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput>
  }

  export type ShopItemUpdateWithWhereUniqueWithoutShopInput = {
    where: ShopItemWhereUniqueInput
    data: XOR<ShopItemUpdateWithoutShopInput, ShopItemUncheckedUpdateWithoutShopInput>
  }

  export type ShopItemUpdateManyWithWhereWithoutShopInput = {
    where: ShopItemScalarWhereInput
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopItemScalarWhereInput = {
    AND?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
    OR?: ShopItemScalarWhereInput[]
    NOT?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
    id?: StringFilter<"ShopItem"> | string
    shopId?: StringFilter<"ShopItem"> | string
    itemType?: StringFilter<"ShopItem"> | string
    itemId?: StringFilter<"ShopItem"> | string
    name?: StringFilter<"ShopItem"> | string
    displayName?: StringFilter<"ShopItem"> | string
    description?: StringNullableFilter<"ShopItem"> | string | null
    price?: IntFilter<"ShopItem"> | number
    currency?: StringFilter<"ShopItem"> | string
    stock?: IntFilter<"ShopItem"> | number
    isActive?: BoolFilter<"ShopItem"> | boolean
    level?: IntFilter<"ShopItem"> | number
    rarity?: StringFilter<"ShopItem"> | string
    icon?: StringNullableFilter<"ShopItem"> | string | null
    createdAt?: DateTimeFilter<"ShopItem"> | Date | string
    updatedAt?: DateTimeFilter<"ShopItem"> | Date | string
  }

  export type PurchaseHistoryUpsertWithWhereUniqueWithoutShopInput = {
    where: PurchaseHistoryWhereUniqueInput
    update: XOR<PurchaseHistoryUpdateWithoutShopInput, PurchaseHistoryUncheckedUpdateWithoutShopInput>
    create: XOR<PurchaseHistoryCreateWithoutShopInput, PurchaseHistoryUncheckedCreateWithoutShopInput>
  }

  export type PurchaseHistoryUpdateWithWhereUniqueWithoutShopInput = {
    where: PurchaseHistoryWhereUniqueInput
    data: XOR<PurchaseHistoryUpdateWithoutShopInput, PurchaseHistoryUncheckedUpdateWithoutShopInput>
  }

  export type PurchaseHistoryUpdateManyWithWhereWithoutShopInput = {
    where: PurchaseHistoryScalarWhereInput
    data: XOR<PurchaseHistoryUpdateManyMutationInput, PurchaseHistoryUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopCreateWithoutItemsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseHistoryCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutItemsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutItemsInput, ShopUncheckedCreateWithoutItemsInput>
  }

  export type ShopUpsertWithoutItemsInput = {
    update: XOR<ShopUpdateWithoutItemsInput, ShopUncheckedUpdateWithoutItemsInput>
    create: XOR<ShopCreateWithoutItemsInput, ShopUncheckedCreateWithoutItemsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutItemsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutItemsInput, ShopUncheckedUpdateWithoutItemsInput>
  }

  export type ShopUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseHistoryUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutShopNestedInput
  }

  export type PlayerCreateWithoutPurchasesInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutPurchasesInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutPurchasesInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPurchasesInput, PlayerUncheckedCreateWithoutPurchasesInput>
  }

  export type ShopCreateWithoutPurchasesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ShopItemCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutPurchasesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ShopItemUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutPurchasesInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutPurchasesInput, ShopUncheckedCreateWithoutPurchasesInput>
  }

  export type PlayerUpsertWithoutPurchasesInput = {
    update: XOR<PlayerUpdateWithoutPurchasesInput, PlayerUncheckedUpdateWithoutPurchasesInput>
    create: XOR<PlayerCreateWithoutPurchasesInput, PlayerUncheckedCreateWithoutPurchasesInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutPurchasesInput, PlayerUncheckedUpdateWithoutPurchasesInput>
  }

  export type PlayerUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type ShopUpsertWithoutPurchasesInput = {
    update: XOR<ShopUpdateWithoutPurchasesInput, ShopUncheckedUpdateWithoutPurchasesInput>
    create: XOR<ShopCreateWithoutPurchasesInput, ShopUncheckedCreateWithoutPurchasesInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutPurchasesInput, ShopUncheckedUpdateWithoutPurchasesInput>
  }

  export type ShopUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ShopItemUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ShopItemUncheckedUpdateManyWithoutShopNestedInput
  }

  export type PlayerCreateWithoutInventoryInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutInventoryInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutInventoryInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
  }

  export type PlayerUpsertWithoutInventoryInput = {
    update: XOR<PlayerUpdateWithoutInventoryInput, PlayerUncheckedUpdateWithoutInventoryInput>
    create: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutInventoryInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutInventoryInput, PlayerUncheckedUpdateWithoutInventoryInput>
  }

  export type PlayerUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type CraftingHistoryCreateWithoutRecipeInput = {
    id?: string
    success: boolean
    quantity?: number
    materials: string
    result: string
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutCraftingHistoryInput
  }

  export type CraftingHistoryUncheckedCreateWithoutRecipeInput = {
    id?: string
    playerId: string
    success: boolean
    quantity?: number
    materials: string
    result: string
    createdAt?: Date | string
  }

  export type CraftingHistoryCreateOrConnectWithoutRecipeInput = {
    where: CraftingHistoryWhereUniqueInput
    create: XOR<CraftingHistoryCreateWithoutRecipeInput, CraftingHistoryUncheckedCreateWithoutRecipeInput>
  }

  export type CraftingHistoryCreateManyRecipeInputEnvelope = {
    data: CraftingHistoryCreateManyRecipeInput | CraftingHistoryCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type CraftingHistoryUpsertWithWhereUniqueWithoutRecipeInput = {
    where: CraftingHistoryWhereUniqueInput
    update: XOR<CraftingHistoryUpdateWithoutRecipeInput, CraftingHistoryUncheckedUpdateWithoutRecipeInput>
    create: XOR<CraftingHistoryCreateWithoutRecipeInput, CraftingHistoryUncheckedCreateWithoutRecipeInput>
  }

  export type CraftingHistoryUpdateWithWhereUniqueWithoutRecipeInput = {
    where: CraftingHistoryWhereUniqueInput
    data: XOR<CraftingHistoryUpdateWithoutRecipeInput, CraftingHistoryUncheckedUpdateWithoutRecipeInput>
  }

  export type CraftingHistoryUpdateManyWithWhereWithoutRecipeInput = {
    where: CraftingHistoryScalarWhereInput
    data: XOR<CraftingHistoryUpdateManyMutationInput, CraftingHistoryUncheckedUpdateManyWithoutRecipeInput>
  }

  export type PlayerCreateWithoutCraftingHistoryInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutCraftingHistoryInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutCraftingHistoryInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutCraftingHistoryInput, PlayerUncheckedCreateWithoutCraftingHistoryInput>
  }

  export type RecipeCreateWithoutCraftingHistoryInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    level?: number
    successRate?: number
    materials: string
    result: string
    experience?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipeUncheckedCreateWithoutCraftingHistoryInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    level?: number
    successRate?: number
    materials: string
    result: string
    experience?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipeCreateOrConnectWithoutCraftingHistoryInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutCraftingHistoryInput, RecipeUncheckedCreateWithoutCraftingHistoryInput>
  }

  export type PlayerUpsertWithoutCraftingHistoryInput = {
    update: XOR<PlayerUpdateWithoutCraftingHistoryInput, PlayerUncheckedUpdateWithoutCraftingHistoryInput>
    create: XOR<PlayerCreateWithoutCraftingHistoryInput, PlayerUncheckedCreateWithoutCraftingHistoryInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutCraftingHistoryInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutCraftingHistoryInput, PlayerUncheckedUpdateWithoutCraftingHistoryInput>
  }

  export type PlayerUpdateWithoutCraftingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutCraftingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type RecipeUpsertWithoutCraftingHistoryInput = {
    update: XOR<RecipeUpdateWithoutCraftingHistoryInput, RecipeUncheckedUpdateWithoutCraftingHistoryInput>
    create: XOR<RecipeCreateWithoutCraftingHistoryInput, RecipeUncheckedCreateWithoutCraftingHistoryInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutCraftingHistoryInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutCraftingHistoryInput, RecipeUncheckedUpdateWithoutCraftingHistoryInput>
  }

  export type RecipeUpdateWithoutCraftingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUncheckedUpdateWithoutCraftingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFurnaceCreateWithoutFurnaceInput = {
    id?: string
    level?: number
    experience?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutFurnacesInput
  }

  export type PlayerFurnaceUncheckedCreateWithoutFurnaceInput = {
    id?: string
    playerId: string
    level?: number
    experience?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerFurnaceCreateOrConnectWithoutFurnaceInput = {
    where: PlayerFurnaceWhereUniqueInput
    create: XOR<PlayerFurnaceCreateWithoutFurnaceInput, PlayerFurnaceUncheckedCreateWithoutFurnaceInput>
  }

  export type PlayerFurnaceCreateManyFurnaceInputEnvelope = {
    data: PlayerFurnaceCreateManyFurnaceInput | PlayerFurnaceCreateManyFurnaceInput[]
    skipDuplicates?: boolean
  }

  export type PlayerFurnaceUpsertWithWhereUniqueWithoutFurnaceInput = {
    where: PlayerFurnaceWhereUniqueInput
    update: XOR<PlayerFurnaceUpdateWithoutFurnaceInput, PlayerFurnaceUncheckedUpdateWithoutFurnaceInput>
    create: XOR<PlayerFurnaceCreateWithoutFurnaceInput, PlayerFurnaceUncheckedCreateWithoutFurnaceInput>
  }

  export type PlayerFurnaceUpdateWithWhereUniqueWithoutFurnaceInput = {
    where: PlayerFurnaceWhereUniqueInput
    data: XOR<PlayerFurnaceUpdateWithoutFurnaceInput, PlayerFurnaceUncheckedUpdateWithoutFurnaceInput>
  }

  export type PlayerFurnaceUpdateManyWithWhereWithoutFurnaceInput = {
    where: PlayerFurnaceScalarWhereInput
    data: XOR<PlayerFurnaceUpdateManyMutationInput, PlayerFurnaceUncheckedUpdateManyWithoutFurnaceInput>
  }

  export type PlayerCreateWithoutFurnacesInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutFurnacesInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutFurnacesInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutFurnacesInput, PlayerUncheckedCreateWithoutFurnacesInput>
  }

  export type DaoFurnaceCreateWithoutPlayerFurnacesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    level?: number
    maxLevel?: number
    efficiency?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DaoFurnaceUncheckedCreateWithoutPlayerFurnacesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    level?: number
    maxLevel?: number
    efficiency?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DaoFurnaceCreateOrConnectWithoutPlayerFurnacesInput = {
    where: DaoFurnaceWhereUniqueInput
    create: XOR<DaoFurnaceCreateWithoutPlayerFurnacesInput, DaoFurnaceUncheckedCreateWithoutPlayerFurnacesInput>
  }

  export type PlayerUpsertWithoutFurnacesInput = {
    update: XOR<PlayerUpdateWithoutFurnacesInput, PlayerUncheckedUpdateWithoutFurnacesInput>
    create: XOR<PlayerCreateWithoutFurnacesInput, PlayerUncheckedCreateWithoutFurnacesInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutFurnacesInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutFurnacesInput, PlayerUncheckedUpdateWithoutFurnacesInput>
  }

  export type PlayerUpdateWithoutFurnacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutFurnacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type DaoFurnaceUpsertWithoutPlayerFurnacesInput = {
    update: XOR<DaoFurnaceUpdateWithoutPlayerFurnacesInput, DaoFurnaceUncheckedUpdateWithoutPlayerFurnacesInput>
    create: XOR<DaoFurnaceCreateWithoutPlayerFurnacesInput, DaoFurnaceUncheckedCreateWithoutPlayerFurnacesInput>
    where?: DaoFurnaceWhereInput
  }

  export type DaoFurnaceUpdateToOneWithWhereWithoutPlayerFurnacesInput = {
    where?: DaoFurnaceWhereInput
    data: XOR<DaoFurnaceUpdateWithoutPlayerFurnacesInput, DaoFurnaceUncheckedUpdateWithoutPlayerFurnacesInput>
  }

  export type DaoFurnaceUpdateWithoutPlayerFurnacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    efficiency?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DaoFurnaceUncheckedUpdateWithoutPlayerFurnacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    efficiency?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpiritBeastCreateWithoutTypeInput = {
    id?: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutSpiritBeastsInput
    feedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutBeastInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutBeastInput
  }

  export type SpiritBeastUncheckedCreateWithoutTypeInput = {
    id?: string
    playerId: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutBeastInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutBeastInput
  }

  export type SpiritBeastCreateOrConnectWithoutTypeInput = {
    where: SpiritBeastWhereUniqueInput
    create: XOR<SpiritBeastCreateWithoutTypeInput, SpiritBeastUncheckedCreateWithoutTypeInput>
  }

  export type SpiritBeastCreateManyTypeInputEnvelope = {
    data: SpiritBeastCreateManyTypeInput | SpiritBeastCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type SpiritBeastUpsertWithWhereUniqueWithoutTypeInput = {
    where: SpiritBeastWhereUniqueInput
    update: XOR<SpiritBeastUpdateWithoutTypeInput, SpiritBeastUncheckedUpdateWithoutTypeInput>
    create: XOR<SpiritBeastCreateWithoutTypeInput, SpiritBeastUncheckedCreateWithoutTypeInput>
  }

  export type SpiritBeastUpdateWithWhereUniqueWithoutTypeInput = {
    where: SpiritBeastWhereUniqueInput
    data: XOR<SpiritBeastUpdateWithoutTypeInput, SpiritBeastUncheckedUpdateWithoutTypeInput>
  }

  export type SpiritBeastUpdateManyWithWhereWithoutTypeInput = {
    where: SpiritBeastScalarWhereInput
    data: XOR<SpiritBeastUpdateManyMutationInput, SpiritBeastUncheckedUpdateManyWithoutTypeInput>
  }

  export type PlayerCreateWithoutSpiritBeastsInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutSpiritBeastsInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutSpiritBeastsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutSpiritBeastsInput, PlayerUncheckedCreateWithoutSpiritBeastsInput>
  }

  export type SpiritBeastTypeCreateWithoutBeastsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    baseStats: string
    growthRate: string
    skills?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpiritBeastTypeUncheckedCreateWithoutBeastsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    baseStats: string
    growthRate: string
    skills?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpiritBeastTypeCreateOrConnectWithoutBeastsInput = {
    where: SpiritBeastTypeWhereUniqueInput
    create: XOR<SpiritBeastTypeCreateWithoutBeastsInput, SpiritBeastTypeUncheckedCreateWithoutBeastsInput>
  }

  export type BeastFeedingHistoryCreateWithoutBeastInput = {
    id?: string
    quantity?: number
    effects: string
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutBeastFeedingHistoryInput
    food: BeastFoodCreateNestedOneWithoutFeedingHistoryInput
  }

  export type BeastFeedingHistoryUncheckedCreateWithoutBeastInput = {
    id?: string
    playerId: string
    foodId: string
    quantity?: number
    effects: string
    createdAt?: Date | string
  }

  export type BeastFeedingHistoryCreateOrConnectWithoutBeastInput = {
    where: BeastFeedingHistoryWhereUniqueInput
    create: XOR<BeastFeedingHistoryCreateWithoutBeastInput, BeastFeedingHistoryUncheckedCreateWithoutBeastInput>
  }

  export type BeastFeedingHistoryCreateManyBeastInputEnvelope = {
    data: BeastFeedingHistoryCreateManyBeastInput | BeastFeedingHistoryCreateManyBeastInput[]
    skipDuplicates?: boolean
  }

  export type HuntingHistoryCreateWithoutBeastInput = {
    id?: string
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutHuntingHistoryInput
    ground: HuntingGroundCreateNestedOneWithoutHuntingHistoryInput
  }

  export type HuntingHistoryUncheckedCreateWithoutBeastInput = {
    id?: string
    playerId: string
    groundId: string
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
  }

  export type HuntingHistoryCreateOrConnectWithoutBeastInput = {
    where: HuntingHistoryWhereUniqueInput
    create: XOR<HuntingHistoryCreateWithoutBeastInput, HuntingHistoryUncheckedCreateWithoutBeastInput>
  }

  export type HuntingHistoryCreateManyBeastInputEnvelope = {
    data: HuntingHistoryCreateManyBeastInput | HuntingHistoryCreateManyBeastInput[]
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithoutSpiritBeastsInput = {
    update: XOR<PlayerUpdateWithoutSpiritBeastsInput, PlayerUncheckedUpdateWithoutSpiritBeastsInput>
    create: XOR<PlayerCreateWithoutSpiritBeastsInput, PlayerUncheckedCreateWithoutSpiritBeastsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutSpiritBeastsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutSpiritBeastsInput, PlayerUncheckedUpdateWithoutSpiritBeastsInput>
  }

  export type PlayerUpdateWithoutSpiritBeastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutSpiritBeastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type SpiritBeastTypeUpsertWithoutBeastsInput = {
    update: XOR<SpiritBeastTypeUpdateWithoutBeastsInput, SpiritBeastTypeUncheckedUpdateWithoutBeastsInput>
    create: XOR<SpiritBeastTypeCreateWithoutBeastsInput, SpiritBeastTypeUncheckedCreateWithoutBeastsInput>
    where?: SpiritBeastTypeWhereInput
  }

  export type SpiritBeastTypeUpdateToOneWithWhereWithoutBeastsInput = {
    where?: SpiritBeastTypeWhereInput
    data: XOR<SpiritBeastTypeUpdateWithoutBeastsInput, SpiritBeastTypeUncheckedUpdateWithoutBeastsInput>
  }

  export type SpiritBeastTypeUpdateWithoutBeastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseStats?: StringFieldUpdateOperationsInput | string
    growthRate?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpiritBeastTypeUncheckedUpdateWithoutBeastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseStats?: StringFieldUpdateOperationsInput | string
    growthRate?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFeedingHistoryUpsertWithWhereUniqueWithoutBeastInput = {
    where: BeastFeedingHistoryWhereUniqueInput
    update: XOR<BeastFeedingHistoryUpdateWithoutBeastInput, BeastFeedingHistoryUncheckedUpdateWithoutBeastInput>
    create: XOR<BeastFeedingHistoryCreateWithoutBeastInput, BeastFeedingHistoryUncheckedCreateWithoutBeastInput>
  }

  export type BeastFeedingHistoryUpdateWithWhereUniqueWithoutBeastInput = {
    where: BeastFeedingHistoryWhereUniqueInput
    data: XOR<BeastFeedingHistoryUpdateWithoutBeastInput, BeastFeedingHistoryUncheckedUpdateWithoutBeastInput>
  }

  export type BeastFeedingHistoryUpdateManyWithWhereWithoutBeastInput = {
    where: BeastFeedingHistoryScalarWhereInput
    data: XOR<BeastFeedingHistoryUpdateManyMutationInput, BeastFeedingHistoryUncheckedUpdateManyWithoutBeastInput>
  }

  export type HuntingHistoryUpsertWithWhereUniqueWithoutBeastInput = {
    where: HuntingHistoryWhereUniqueInput
    update: XOR<HuntingHistoryUpdateWithoutBeastInput, HuntingHistoryUncheckedUpdateWithoutBeastInput>
    create: XOR<HuntingHistoryCreateWithoutBeastInput, HuntingHistoryUncheckedCreateWithoutBeastInput>
  }

  export type HuntingHistoryUpdateWithWhereUniqueWithoutBeastInput = {
    where: HuntingHistoryWhereUniqueInput
    data: XOR<HuntingHistoryUpdateWithoutBeastInput, HuntingHistoryUncheckedUpdateWithoutBeastInput>
  }

  export type HuntingHistoryUpdateManyWithWhereWithoutBeastInput = {
    where: HuntingHistoryScalarWhereInput
    data: XOR<HuntingHistoryUpdateManyMutationInput, HuntingHistoryUncheckedUpdateManyWithoutBeastInput>
  }

  export type BeastFeedingHistoryCreateWithoutFoodInput = {
    id?: string
    quantity?: number
    effects: string
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutBeastFeedingHistoryInput
    beast: SpiritBeastCreateNestedOneWithoutFeedingHistoryInput
  }

  export type BeastFeedingHistoryUncheckedCreateWithoutFoodInput = {
    id?: string
    playerId: string
    beastId: string
    quantity?: number
    effects: string
    createdAt?: Date | string
  }

  export type BeastFeedingHistoryCreateOrConnectWithoutFoodInput = {
    where: BeastFeedingHistoryWhereUniqueInput
    create: XOR<BeastFeedingHistoryCreateWithoutFoodInput, BeastFeedingHistoryUncheckedCreateWithoutFoodInput>
  }

  export type BeastFeedingHistoryCreateManyFoodInputEnvelope = {
    data: BeastFeedingHistoryCreateManyFoodInput | BeastFeedingHistoryCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type BeastFeedingHistoryUpsertWithWhereUniqueWithoutFoodInput = {
    where: BeastFeedingHistoryWhereUniqueInput
    update: XOR<BeastFeedingHistoryUpdateWithoutFoodInput, BeastFeedingHistoryUncheckedUpdateWithoutFoodInput>
    create: XOR<BeastFeedingHistoryCreateWithoutFoodInput, BeastFeedingHistoryUncheckedCreateWithoutFoodInput>
  }

  export type BeastFeedingHistoryUpdateWithWhereUniqueWithoutFoodInput = {
    where: BeastFeedingHistoryWhereUniqueInput
    data: XOR<BeastFeedingHistoryUpdateWithoutFoodInput, BeastFeedingHistoryUncheckedUpdateWithoutFoodInput>
  }

  export type BeastFeedingHistoryUpdateManyWithWhereWithoutFoodInput = {
    where: BeastFeedingHistoryScalarWhereInput
    data: XOR<BeastFeedingHistoryUpdateManyMutationInput, BeastFeedingHistoryUncheckedUpdateManyWithoutFoodInput>
  }

  export type PlayerCreateWithoutBeastFeedingHistoryInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutBeastFeedingHistoryInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutBeastFeedingHistoryInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutBeastFeedingHistoryInput, PlayerUncheckedCreateWithoutBeastFeedingHistoryInput>
  }

  export type SpiritBeastCreateWithoutFeedingHistoryInput = {
    id?: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutSpiritBeastsInput
    type: SpiritBeastTypeCreateNestedOneWithoutBeastsInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutBeastInput
  }

  export type SpiritBeastUncheckedCreateWithoutFeedingHistoryInput = {
    id?: string
    playerId: string
    typeId: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutBeastInput
  }

  export type SpiritBeastCreateOrConnectWithoutFeedingHistoryInput = {
    where: SpiritBeastWhereUniqueInput
    create: XOR<SpiritBeastCreateWithoutFeedingHistoryInput, SpiritBeastUncheckedCreateWithoutFeedingHistoryInput>
  }

  export type BeastFoodCreateWithoutFeedingHistoryInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    effects: string
    price?: number
    currency?: string
    icon?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BeastFoodUncheckedCreateWithoutFeedingHistoryInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category?: string
    effects: string
    price?: number
    currency?: string
    icon?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BeastFoodCreateOrConnectWithoutFeedingHistoryInput = {
    where: BeastFoodWhereUniqueInput
    create: XOR<BeastFoodCreateWithoutFeedingHistoryInput, BeastFoodUncheckedCreateWithoutFeedingHistoryInput>
  }

  export type PlayerUpsertWithoutBeastFeedingHistoryInput = {
    update: XOR<PlayerUpdateWithoutBeastFeedingHistoryInput, PlayerUncheckedUpdateWithoutBeastFeedingHistoryInput>
    create: XOR<PlayerCreateWithoutBeastFeedingHistoryInput, PlayerUncheckedCreateWithoutBeastFeedingHistoryInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutBeastFeedingHistoryInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutBeastFeedingHistoryInput, PlayerUncheckedUpdateWithoutBeastFeedingHistoryInput>
  }

  export type PlayerUpdateWithoutBeastFeedingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutBeastFeedingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type SpiritBeastUpsertWithoutFeedingHistoryInput = {
    update: XOR<SpiritBeastUpdateWithoutFeedingHistoryInput, SpiritBeastUncheckedUpdateWithoutFeedingHistoryInput>
    create: XOR<SpiritBeastCreateWithoutFeedingHistoryInput, SpiritBeastUncheckedCreateWithoutFeedingHistoryInput>
    where?: SpiritBeastWhereInput
  }

  export type SpiritBeastUpdateToOneWithWhereWithoutFeedingHistoryInput = {
    where?: SpiritBeastWhereInput
    data: XOR<SpiritBeastUpdateWithoutFeedingHistoryInput, SpiritBeastUncheckedUpdateWithoutFeedingHistoryInput>
  }

  export type SpiritBeastUpdateWithoutFeedingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutSpiritBeastsNestedInput
    type?: SpiritBeastTypeUpdateOneRequiredWithoutBeastsNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutBeastNestedInput
  }

  export type SpiritBeastUncheckedUpdateWithoutFeedingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutBeastNestedInput
  }

  export type BeastFoodUpsertWithoutFeedingHistoryInput = {
    update: XOR<BeastFoodUpdateWithoutFeedingHistoryInput, BeastFoodUncheckedUpdateWithoutFeedingHistoryInput>
    create: XOR<BeastFoodCreateWithoutFeedingHistoryInput, BeastFoodUncheckedCreateWithoutFeedingHistoryInput>
    where?: BeastFoodWhereInput
  }

  export type BeastFoodUpdateToOneWithWhereWithoutFeedingHistoryInput = {
    where?: BeastFoodWhereInput
    data: XOR<BeastFoodUpdateWithoutFeedingHistoryInput, BeastFoodUncheckedUpdateWithoutFeedingHistoryInput>
  }

  export type BeastFoodUpdateWithoutFeedingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    effects?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFoodUncheckedUpdateWithoutFeedingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    effects?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingHistoryCreateWithoutGroundInput = {
    id?: string
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutHuntingHistoryInput
    beast?: SpiritBeastCreateNestedOneWithoutHuntingHistoryInput
  }

  export type HuntingHistoryUncheckedCreateWithoutGroundInput = {
    id?: string
    playerId: string
    beastId?: string | null
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
  }

  export type HuntingHistoryCreateOrConnectWithoutGroundInput = {
    where: HuntingHistoryWhereUniqueInput
    create: XOR<HuntingHistoryCreateWithoutGroundInput, HuntingHistoryUncheckedCreateWithoutGroundInput>
  }

  export type HuntingHistoryCreateManyGroundInputEnvelope = {
    data: HuntingHistoryCreateManyGroundInput | HuntingHistoryCreateManyGroundInput[]
    skipDuplicates?: boolean
  }

  export type HuntingHistoryUpsertWithWhereUniqueWithoutGroundInput = {
    where: HuntingHistoryWhereUniqueInput
    update: XOR<HuntingHistoryUpdateWithoutGroundInput, HuntingHistoryUncheckedUpdateWithoutGroundInput>
    create: XOR<HuntingHistoryCreateWithoutGroundInput, HuntingHistoryUncheckedCreateWithoutGroundInput>
  }

  export type HuntingHistoryUpdateWithWhereUniqueWithoutGroundInput = {
    where: HuntingHistoryWhereUniqueInput
    data: XOR<HuntingHistoryUpdateWithoutGroundInput, HuntingHistoryUncheckedUpdateWithoutGroundInput>
  }

  export type HuntingHistoryUpdateManyWithWhereWithoutGroundInput = {
    where: HuntingHistoryScalarWhereInput
    data: XOR<HuntingHistoryUpdateManyMutationInput, HuntingHistoryUncheckedUpdateManyWithoutGroundInput>
  }

  export type PlayerCreateWithoutHuntingHistoryInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutHuntingHistoryInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutHuntingHistoryInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutHuntingHistoryInput, PlayerUncheckedCreateWithoutHuntingHistoryInput>
  }

  export type HuntingGroundCreateWithoutHuntingHistoryInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    level?: number
    maxLevel?: number
    difficulty?: string
    beastTypes: string
    dropRates: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HuntingGroundUncheckedCreateWithoutHuntingHistoryInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    level?: number
    maxLevel?: number
    difficulty?: string
    beastTypes: string
    dropRates: string
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HuntingGroundCreateOrConnectWithoutHuntingHistoryInput = {
    where: HuntingGroundWhereUniqueInput
    create: XOR<HuntingGroundCreateWithoutHuntingHistoryInput, HuntingGroundUncheckedCreateWithoutHuntingHistoryInput>
  }

  export type SpiritBeastCreateWithoutHuntingHistoryInput = {
    id?: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutSpiritBeastsInput
    type: SpiritBeastTypeCreateNestedOneWithoutBeastsInput
    feedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutBeastInput
  }

  export type SpiritBeastUncheckedCreateWithoutHuntingHistoryInput = {
    id?: string
    playerId: string
    typeId: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutBeastInput
  }

  export type SpiritBeastCreateOrConnectWithoutHuntingHistoryInput = {
    where: SpiritBeastWhereUniqueInput
    create: XOR<SpiritBeastCreateWithoutHuntingHistoryInput, SpiritBeastUncheckedCreateWithoutHuntingHistoryInput>
  }

  export type PlayerUpsertWithoutHuntingHistoryInput = {
    update: XOR<PlayerUpdateWithoutHuntingHistoryInput, PlayerUncheckedUpdateWithoutHuntingHistoryInput>
    create: XOR<PlayerCreateWithoutHuntingHistoryInput, PlayerUncheckedCreateWithoutHuntingHistoryInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutHuntingHistoryInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutHuntingHistoryInput, PlayerUncheckedUpdateWithoutHuntingHistoryInput>
  }

  export type PlayerUpdateWithoutHuntingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutHuntingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type HuntingGroundUpsertWithoutHuntingHistoryInput = {
    update: XOR<HuntingGroundUpdateWithoutHuntingHistoryInput, HuntingGroundUncheckedUpdateWithoutHuntingHistoryInput>
    create: XOR<HuntingGroundCreateWithoutHuntingHistoryInput, HuntingGroundUncheckedCreateWithoutHuntingHistoryInput>
    where?: HuntingGroundWhereInput
  }

  export type HuntingGroundUpdateToOneWithWhereWithoutHuntingHistoryInput = {
    where?: HuntingGroundWhereInput
    data: XOR<HuntingGroundUpdateWithoutHuntingHistoryInput, HuntingGroundUncheckedUpdateWithoutHuntingHistoryInput>
  }

  export type HuntingGroundUpdateWithoutHuntingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    beastTypes?: StringFieldUpdateOperationsInput | string
    dropRates?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingGroundUncheckedUpdateWithoutHuntingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    beastTypes?: StringFieldUpdateOperationsInput | string
    dropRates?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpiritBeastUpsertWithoutHuntingHistoryInput = {
    update: XOR<SpiritBeastUpdateWithoutHuntingHistoryInput, SpiritBeastUncheckedUpdateWithoutHuntingHistoryInput>
    create: XOR<SpiritBeastCreateWithoutHuntingHistoryInput, SpiritBeastUncheckedCreateWithoutHuntingHistoryInput>
    where?: SpiritBeastWhereInput
  }

  export type SpiritBeastUpdateToOneWithWhereWithoutHuntingHistoryInput = {
    where?: SpiritBeastWhereInput
    data: XOR<SpiritBeastUpdateWithoutHuntingHistoryInput, SpiritBeastUncheckedUpdateWithoutHuntingHistoryInput>
  }

  export type SpiritBeastUpdateWithoutHuntingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutSpiritBeastsNestedInput
    type?: SpiritBeastTypeUpdateOneRequiredWithoutBeastsNestedInput
    feedingHistory?: BeastFeedingHistoryUpdateManyWithoutBeastNestedInput
  }

  export type SpiritBeastUncheckedUpdateWithoutHuntingHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutBeastNestedInput
  }

  export type PlayerCreateWithoutCultivationInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutCultivationInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivationLogs?: CultivationLogUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutCultivationInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutCultivationInput, PlayerUncheckedCreateWithoutCultivationInput>
  }

  export type PlayerUpsertWithoutCultivationInput = {
    update: XOR<PlayerUpdateWithoutCultivationInput, PlayerUncheckedUpdateWithoutCultivationInput>
    create: XOR<PlayerCreateWithoutCultivationInput, PlayerUncheckedCreateWithoutCultivationInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutCultivationInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutCultivationInput, PlayerUncheckedUpdateWithoutCultivationInput>
  }

  export type PlayerUpdateWithoutCultivationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutCultivationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivationLogs?: CultivationLogUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateWithoutCultivationLogsInput = {
    id?: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    resources?: PlayerResourceCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryCreateNestedManyWithoutPlayerInput
    inventory?: InventoryCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutCultivationLogsInput = {
    id?: string
    userId: string
    name: string
    level?: number
    realm?: string
    experience?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: PlayerResourceUncheckedCreateNestedManyWithoutPlayerInput
    companions?: PlayerCompanionUncheckedCreateNestedManyWithoutPlayerInput
    achievements?: PlayerAchievementUncheckedCreateNestedManyWithoutPlayerInput
    quests?: PlayerQuestUncheckedCreateNestedManyWithoutPlayerInput
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    equipments?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
    talents?: PlayerTalentUncheckedCreateNestedManyWithoutPlayerInput
    buffs?: PlayerBuffUncheckedCreateNestedManyWithoutPlayerInput
    purchases?: PurchaseHistoryUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutPlayerInput
    craftingHistory?: CraftingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    furnaces?: PlayerFurnaceUncheckedCreateNestedManyWithoutPlayerInput
    spiritBeasts?: SpiritBeastUncheckedCreateNestedManyWithoutPlayerInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    huntingHistory?: HuntingHistoryUncheckedCreateNestedManyWithoutPlayerInput
    cultivation?: PlayerCultivationUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutCultivationLogsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutCultivationLogsInput, PlayerUncheckedCreateWithoutCultivationLogsInput>
  }

  export type PlayerUpsertWithoutCultivationLogsInput = {
    update: XOR<PlayerUpdateWithoutCultivationLogsInput, PlayerUncheckedUpdateWithoutCultivationLogsInput>
    create: XOR<PlayerCreateWithoutCultivationLogsInput, PlayerUncheckedCreateWithoutCultivationLogsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutCultivationLogsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutCultivationLogsInput, PlayerUncheckedUpdateWithoutCultivationLogsInput>
  }

  export type PlayerUpdateWithoutCultivationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    resources?: PlayerResourceUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutCultivationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    realm?: StringFieldUpdateOperationsInput | string
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: PlayerResourceUncheckedUpdateManyWithoutPlayerNestedInput
    companions?: PlayerCompanionUncheckedUpdateManyWithoutPlayerNestedInput
    achievements?: PlayerAchievementUncheckedUpdateManyWithoutPlayerNestedInput
    quests?: PlayerQuestUncheckedUpdateManyWithoutPlayerNestedInput
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    equipments?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
    talents?: PlayerTalentUncheckedUpdateManyWithoutPlayerNestedInput
    buffs?: PlayerBuffUncheckedUpdateManyWithoutPlayerNestedInput
    purchases?: PurchaseHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutPlayerNestedInput
    craftingHistory?: CraftingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    furnaces?: PlayerFurnaceUncheckedUpdateManyWithoutPlayerNestedInput
    spiritBeasts?: SpiritBeastUncheckedUpdateManyWithoutPlayerNestedInput
    beastFeedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    cultivation?: PlayerCultivationUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerResourceCreateManyPlayerInput = {
    id?: string
    resourceId: string
    amount?: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCompanionCreateManyPlayerInput = {
    id?: string
    companionId: string
    level?: number
    power?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerAchievementCreateManyPlayerInput = {
    id?: string
    achievementId: string
    unlockedAt?: Date | string
  }

  export type PlayerQuestCreateManyPlayerInput = {
    id?: string
    questId: string
    status?: string
    progress?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lastCompletedAt?: Date | string | null
    cooldownUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerEquipmentCreateManyPlayerInput = {
    id?: string
    equipmentId: string
    isEquipped?: boolean
    durability?: number
    enhancement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerSkillCreateManyPlayerInput = {
    id?: string
    skillId: string
    level?: number
    isLearned?: boolean
    learnedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerTalentCreateManyPlayerInput = {
    id?: string
    talentId: string
    level?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerBuffCreateManyPlayerInput = {
    id?: string
    buffId: string
    level?: number
    stacks?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseHistoryCreateManyPlayerInput = {
    id?: string
    shopId: string
    itemId: string
    itemName: string
    quantity?: number
    price: number
    currency: string
    totalCost: number
    createdAt?: Date | string
  }

  export type InventoryCreateManyPlayerInput = {
    id?: string
    itemType: string
    itemId: string
    name: string
    quantity?: number
    stackable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CraftingHistoryCreateManyPlayerInput = {
    id?: string
    recipeId: string
    success: boolean
    quantity?: number
    materials: string
    result: string
    createdAt?: Date | string
  }

  export type PlayerFurnaceCreateManyPlayerInput = {
    id?: string
    furnaceId: string
    level?: number
    experience?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpiritBeastCreateManyPlayerInput = {
    id?: string
    typeId: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BeastFeedingHistoryCreateManyPlayerInput = {
    id?: string
    beastId: string
    foodId: string
    quantity?: number
    effects: string
    createdAt?: Date | string
  }

  export type HuntingHistoryCreateManyPlayerInput = {
    id?: string
    groundId: string
    beastId?: string | null
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
  }

  export type CultivationLogCreateManyPlayerInput = {
    id?: string
    type?: string
    description: string
    expGained?: number
    levelGained?: number
    timestamp?: Date | string
  }

  export type PlayerResourceUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resource?: ResourceUpdateOneRequiredWithoutPlayerResourcesNestedInput
  }

  export type PlayerResourceUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerResourceUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCompanionUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companion?: CompanionUpdateOneRequiredWithoutPlayerCompanionsNestedInput
  }

  export type PlayerCompanionUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companionId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCompanionUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companionId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerAchievementUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUpdateOneRequiredWithoutPlayerAchievementsNestedInput
  }

  export type PlayerAchievementUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerAchievementUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerQuestUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooldownUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quest?: QuestUpdateOneRequiredWithoutPlayerQuestsNestedInput
  }

  export type PlayerQuestUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    questId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooldownUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerQuestUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    questId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooldownUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEquipped?: BoolFieldUpdateOperationsInput | boolean
    durability?: IntFieldUpdateOperationsInput | number
    enhancement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: EquipmentUpdateOneRequiredWithoutPlayerEquipmentsNestedInput
  }

  export type PlayerEquipmentUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    isEquipped?: BoolFieldUpdateOperationsInput | boolean
    durability?: IntFieldUpdateOperationsInput | number
    enhancement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    isEquipped?: BoolFieldUpdateOperationsInput | boolean
    durability?: IntFieldUpdateOperationsInput | number
    enhancement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isLearned?: BoolFieldUpdateOperationsInput | boolean
    learnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutPlayerSkillsNestedInput
  }

  export type PlayerSkillUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isLearned?: BoolFieldUpdateOperationsInput | boolean
    learnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isLearned?: BoolFieldUpdateOperationsInput | boolean
    learnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerTalentUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    talent?: TalentUpdateOneRequiredWithoutPlayerTalentsNestedInput
  }

  export type PlayerTalentUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    talentId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerTalentUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    talentId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBuffUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stacks?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buff?: BuffUpdateOneRequiredWithoutPlayerBuffsNestedInput
  }

  export type PlayerBuffUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    buffId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stacks?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBuffUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    buffId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stacks?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    totalCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseHistoryUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    totalCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    totalCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CraftingHistoryUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: RecipeUpdateOneRequiredWithoutCraftingHistoryNestedInput
  }

  export type CraftingHistoryUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CraftingHistoryUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFurnaceUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    furnace?: DaoFurnaceUpdateOneRequiredWithoutPlayerFurnacesNestedInput
  }

  export type PlayerFurnaceUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    furnaceId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFurnaceUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    furnaceId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpiritBeastUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: SpiritBeastTypeUpdateOneRequiredWithoutBeastsNestedInput
    feedingHistory?: BeastFeedingHistoryUpdateManyWithoutBeastNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutBeastNestedInput
  }

  export type SpiritBeastUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutBeastNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutBeastNestedInput
  }

  export type SpiritBeastUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFeedingHistoryUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beast?: SpiritBeastUpdateOneRequiredWithoutFeedingHistoryNestedInput
    food?: BeastFoodUpdateOneRequiredWithoutFeedingHistoryNestedInput
  }

  export type BeastFeedingHistoryUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    beastId?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFeedingHistoryUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    beastId?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingHistoryUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ground?: HuntingGroundUpdateOneRequiredWithoutHuntingHistoryNestedInput
    beast?: SpiritBeastUpdateOneWithoutHuntingHistoryNestedInput
  }

  export type HuntingHistoryUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    groundId?: StringFieldUpdateOperationsInput | string
    beastId?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingHistoryUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    groundId?: StringFieldUpdateOperationsInput | string
    beastId?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationLogUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expGained?: IntFieldUpdateOperationsInput | number
    levelGained?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationLogUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expGained?: IntFieldUpdateOperationsInput | number
    levelGained?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationLogUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expGained?: IntFieldUpdateOperationsInput | number
    levelGained?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerResourceCreateManyResourceInput = {
    id?: string
    playerId: string
    amount?: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerResourceUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type PlayerResourceUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerResourceUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCompanionCreateManyCompanionInput = {
    id?: string
    playerId: string
    level?: number
    power?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCompanionUpdateWithoutCompanionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutCompanionsNestedInput
  }

  export type PlayerCompanionUncheckedUpdateWithoutCompanionInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCompanionUncheckedUpdateManyWithoutCompanionInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerAchievementCreateManyAchievementInput = {
    id?: string
    playerId: string
    unlockedAt?: Date | string
  }

  export type PlayerAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type PlayerAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerQuestCreateManyQuestInput = {
    id?: string
    playerId: string
    status?: string
    progress?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lastCompletedAt?: Date | string | null
    cooldownUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerQuestUpdateWithoutQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooldownUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutQuestsNestedInput
  }

  export type PlayerQuestUncheckedUpdateWithoutQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooldownUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerQuestUncheckedUpdateManyWithoutQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooldownUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCreateManyTypeInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    rarity?: string
    level?: number
    stats?: string | null
    requirements?: string | null
    price?: number
    isTradeable?: boolean
    isSellable?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isTradeable?: BoolFieldUpdateOperationsInput | boolean
    isSellable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerEquipments?: PlayerEquipmentUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isTradeable?: BoolFieldUpdateOperationsInput | boolean
    isSellable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerEquipments?: PlayerEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isTradeable?: BoolFieldUpdateOperationsInput | boolean
    isSellable?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentCreateManyEquipmentInput = {
    id?: string
    playerId: string
    isEquipped?: boolean
    durability?: number
    enhancement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerEquipmentUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEquipped?: BoolFieldUpdateOperationsInput | boolean
    durability?: IntFieldUpdateOperationsInput | number
    enhancement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutEquipmentsNestedInput
  }

  export type PlayerEquipmentUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    isEquipped?: BoolFieldUpdateOperationsInput | boolean
    durability?: IntFieldUpdateOperationsInput | number
    enhancement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    isEquipped?: BoolFieldUpdateOperationsInput | boolean
    durability?: IntFieldUpdateOperationsInput | number
    enhancement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillCreateManySkillInput = {
    id?: string
    playerId: string
    level?: number
    isLearned?: boolean
    learnedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerSkillUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isLearned?: BoolFieldUpdateOperationsInput | boolean
    learnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type PlayerSkillUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isLearned?: BoolFieldUpdateOperationsInput | boolean
    learnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isLearned?: BoolFieldUpdateOperationsInput | boolean
    learnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TalentCreateManyTypeInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    rarity?: string
    level?: number
    maxLevel?: number
    effects?: string | null
    requirements?: string | null
    cost?: number
    isActive?: boolean
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TalentUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerTalents?: PlayerTalentUpdateManyWithoutTalentNestedInput
  }

  export type TalentUncheckedUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerTalents?: PlayerTalentUncheckedUpdateManyWithoutTalentNestedInput
  }

  export type TalentUncheckedUpdateManyWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    effects?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerTalentCreateManyTalentInput = {
    id?: string
    playerId: string
    level?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerTalentUpdateWithoutTalentInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutTalentsNestedInput
  }

  export type PlayerTalentUncheckedUpdateWithoutTalentInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerTalentUncheckedUpdateManyWithoutTalentInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBuffCreateManyBuffInput = {
    id?: string
    playerId: string
    level?: number
    stacks?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerBuffUpdateWithoutBuffInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stacks?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutBuffsNestedInput
  }

  export type PlayerBuffUncheckedUpdateWithoutBuffInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stacks?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBuffUncheckedUpdateManyWithoutBuffInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stacks?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemCreateManyShopInput = {
    id?: string
    itemType: string
    itemId: string
    name: string
    displayName: string
    description?: string | null
    price: number
    currency?: string
    stock?: number
    isActive?: boolean
    level?: number
    rarity?: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseHistoryCreateManyShopInput = {
    id?: string
    playerId: string
    itemId: string
    itemName: string
    quantity?: number
    price: number
    currency: string
    totalCost: number
    createdAt?: Date | string
  }

  export type ShopItemUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    level?: IntFieldUpdateOperationsInput | number
    rarity?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    level?: IntFieldUpdateOperationsInput | number
    rarity?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    level?: IntFieldUpdateOperationsInput | number
    rarity?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    totalCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseHistoryUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    totalCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    totalCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CraftingHistoryCreateManyRecipeInput = {
    id?: string
    playerId: string
    success: boolean
    quantity?: number
    materials: string
    result: string
    createdAt?: Date | string
  }

  export type CraftingHistoryUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutCraftingHistoryNestedInput
  }

  export type CraftingHistoryUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CraftingHistoryUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    materials?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFurnaceCreateManyFurnaceInput = {
    id?: string
    playerId: string
    level?: number
    experience?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerFurnaceUpdateWithoutFurnaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutFurnacesNestedInput
  }

  export type PlayerFurnaceUncheckedUpdateWithoutFurnaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFurnaceUncheckedUpdateManyWithoutFurnaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpiritBeastCreateManyTypeInput = {
    id?: string
    playerId: string
    name: string
    level?: number
    experience?: number
    stats: string
    skills?: string | null
    happiness?: number
    hunger?: number
    health?: number
    isActive?: boolean
    isFighting?: boolean
    capturedAt?: Date | string
    lastFedAt?: Date | string | null
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpiritBeastUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutSpiritBeastsNestedInput
    feedingHistory?: BeastFeedingHistoryUpdateManyWithoutBeastNestedInput
    huntingHistory?: HuntingHistoryUpdateManyWithoutBeastNestedInput
  }

  export type SpiritBeastUncheckedUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedingHistory?: BeastFeedingHistoryUncheckedUpdateManyWithoutBeastNestedInput
    huntingHistory?: HuntingHistoryUncheckedUpdateManyWithoutBeastNestedInput
  }

  export type SpiritBeastUncheckedUpdateManyWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    stats?: StringFieldUpdateOperationsInput | string
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    happiness?: IntFieldUpdateOperationsInput | number
    hunger?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFighting?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFeedingHistoryCreateManyBeastInput = {
    id?: string
    playerId: string
    foodId: string
    quantity?: number
    effects: string
    createdAt?: Date | string
  }

  export type HuntingHistoryCreateManyBeastInput = {
    id?: string
    playerId: string
    groundId: string
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
  }

  export type BeastFeedingHistoryUpdateWithoutBeastInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutBeastFeedingHistoryNestedInput
    food?: BeastFoodUpdateOneRequiredWithoutFeedingHistoryNestedInput
  }

  export type BeastFeedingHistoryUncheckedUpdateWithoutBeastInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFeedingHistoryUncheckedUpdateManyWithoutBeastInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingHistoryUpdateWithoutBeastInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutHuntingHistoryNestedInput
    ground?: HuntingGroundUpdateOneRequiredWithoutHuntingHistoryNestedInput
  }

  export type HuntingHistoryUncheckedUpdateWithoutBeastInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    groundId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingHistoryUncheckedUpdateManyWithoutBeastInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    groundId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFeedingHistoryCreateManyFoodInput = {
    id?: string
    playerId: string
    beastId: string
    quantity?: number
    effects: string
    createdAt?: Date | string
  }

  export type BeastFeedingHistoryUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutBeastFeedingHistoryNestedInput
    beast?: SpiritBeastUpdateOneRequiredWithoutFeedingHistoryNestedInput
  }

  export type BeastFeedingHistoryUncheckedUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    beastId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeastFeedingHistoryUncheckedUpdateManyWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    beastId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    effects?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingHistoryCreateManyGroundInput = {
    id?: string
    playerId: string
    beastId?: string | null
    success: boolean
    duration: number
    rewards?: string | null
    createdAt?: Date | string
  }

  export type HuntingHistoryUpdateWithoutGroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutHuntingHistoryNestedInput
    beast?: SpiritBeastUpdateOneWithoutHuntingHistoryNestedInput
  }

  export type HuntingHistoryUncheckedUpdateWithoutGroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    beastId?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HuntingHistoryUncheckedUpdateManyWithoutGroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    beastId?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerCountOutputTypeDefaultArgs instead
     */
    export type PlayerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceCountOutputTypeDefaultArgs instead
     */
    export type ResourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanionCountOutputTypeDefaultArgs instead
     */
    export type CompanionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementCountOutputTypeDefaultArgs instead
     */
    export type AchievementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestCountOutputTypeDefaultArgs instead
     */
    export type QuestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentTypeCountOutputTypeDefaultArgs instead
     */
    export type EquipmentTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentCountOutputTypeDefaultArgs instead
     */
    export type EquipmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillCountOutputTypeDefaultArgs instead
     */
    export type SkillCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TalentTypeCountOutputTypeDefaultArgs instead
     */
    export type TalentTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TalentTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TalentCountOutputTypeDefaultArgs instead
     */
    export type TalentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TalentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuffCountOutputTypeDefaultArgs instead
     */
    export type BuffCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuffCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopCountOutputTypeDefaultArgs instead
     */
    export type ShopCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeCountOutputTypeDefaultArgs instead
     */
    export type RecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DaoFurnaceCountOutputTypeDefaultArgs instead
     */
    export type DaoFurnaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DaoFurnaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpiritBeastTypeCountOutputTypeDefaultArgs instead
     */
    export type SpiritBeastTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpiritBeastTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpiritBeastCountOutputTypeDefaultArgs instead
     */
    export type SpiritBeastCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpiritBeastCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BeastFoodCountOutputTypeDefaultArgs instead
     */
    export type BeastFoodCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BeastFoodCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HuntingGroundCountOutputTypeDefaultArgs instead
     */
    export type HuntingGroundCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HuntingGroundCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerDefaultArgs instead
     */
    export type PlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceDefaultArgs instead
     */
    export type ResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerResourceDefaultArgs instead
     */
    export type PlayerResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanionDefaultArgs instead
     */
    export type CompanionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerCompanionDefaultArgs instead
     */
    export type PlayerCompanionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerCompanionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementDefaultArgs instead
     */
    export type AchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerAchievementDefaultArgs instead
     */
    export type PlayerAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestDefaultArgs instead
     */
    export type QuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerQuestDefaultArgs instead
     */
    export type PlayerQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerQuestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerStatsDefaultArgs instead
     */
    export type PlayerStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerStatsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentTypeDefaultArgs instead
     */
    export type EquipmentTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentDefaultArgs instead
     */
    export type EquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerEquipmentDefaultArgs instead
     */
    export type PlayerEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerEquipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillDefaultArgs instead
     */
    export type SkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerSkillDefaultArgs instead
     */
    export type PlayerSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TalentTypeDefaultArgs instead
     */
    export type TalentTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TalentTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TalentDefaultArgs instead
     */
    export type TalentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TalentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerTalentDefaultArgs instead
     */
    export type PlayerTalentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerTalentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuffDefaultArgs instead
     */
    export type BuffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerBuffDefaultArgs instead
     */
    export type PlayerBuffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerBuffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameConfigDefaultArgs instead
     */
    export type GameConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopDefaultArgs instead
     */
    export type ShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopItemDefaultArgs instead
     */
    export type ShopItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseHistoryDefaultArgs instead
     */
    export type PurchaseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryDefaultArgs instead
     */
    export type InventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeDefaultArgs instead
     */
    export type RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CraftingHistoryDefaultArgs instead
     */
    export type CraftingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CraftingHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DaoFurnaceDefaultArgs instead
     */
    export type DaoFurnaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DaoFurnaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerFurnaceDefaultArgs instead
     */
    export type PlayerFurnaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerFurnaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpiritBeastTypeDefaultArgs instead
     */
    export type SpiritBeastTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpiritBeastTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpiritBeastDefaultArgs instead
     */
    export type SpiritBeastArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpiritBeastDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BeastFoodDefaultArgs instead
     */
    export type BeastFoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BeastFoodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BeastFeedingHistoryDefaultArgs instead
     */
    export type BeastFeedingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BeastFeedingHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HuntingGroundDefaultArgs instead
     */
    export type HuntingGroundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HuntingGroundDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HuntingHistoryDefaultArgs instead
     */
    export type HuntingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HuntingHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerCultivationDefaultArgs instead
     */
    export type PlayerCultivationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerCultivationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CultivationLogDefaultArgs instead
     */
    export type CultivationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CultivationLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}